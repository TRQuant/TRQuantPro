---
title: "3.1 è¶‹åŠ¿åˆ†æ"
description: "æ·±å…¥è§£æè¶‹åŠ¿åˆ†ææœºåˆ¶ï¼ŒåŒ…æ‹¬æŠ€æœ¯æŒ‡æ ‡è®¡ç®—ã€è¶‹åŠ¿è¯†åˆ«ç®—æ³•ã€è¶‹åŠ¿å¼ºåº¦è¯„ä¼°å’ŒAIè¾…åŠ©é¢„æµ‹"
lang: "zh-CN"
layout: "/src/layouts/HandbookLayout.astro"
currentBook: "ashare-book6"
updateDate: "2025-12-12"
---

# ğŸ“ˆ 3.1 è¶‹åŠ¿åˆ†æ

> **æ ¸å¿ƒæ‘˜è¦ï¼š**
> 
> æœ¬èŠ‚ç³»ç»Ÿä»‹ç»TRQuantç³»ç»Ÿçš„è¶‹åŠ¿åˆ†æåŠŸèƒ½ï¼ŒåŒ…æ‹¬æŠ€æœ¯æŒ‡æ ‡è®¡ç®—ã€è¶‹åŠ¿è¯†åˆ«ç®—æ³•ã€è¶‹åŠ¿å¼ºåº¦è¯„ä¼°å’ŒAIè¾…åŠ©é¢„æµ‹ã€‚é€šè¿‡ç†è§£ç§»åŠ¨å¹³å‡çº¿ã€è¶‹åŠ¿æŒ‡æ ‡ã€æ³¢åŠ¨æŒ‡æ ‡çš„è®¡ç®—æ–¹æ³•ï¼ŒæŒæ¡ä¸Šå‡è¶‹åŠ¿ã€ä¸‹é™è¶‹åŠ¿ã€æ¨ªç›˜æ•´ç†çš„è¯†åˆ«é€»è¾‘ï¼Œä»¥åŠè¶‹åŠ¿å¼ºåº¦ã€æŒç»­æ€§ã€å¯é æ€§çš„è¯„ä¼°æœºåˆ¶ï¼Œå¸®åŠ©å¼€å‘è€…æ„å»ºå‡†ç¡®çš„å¸‚åœºè¶‹åŠ¿åˆ†æç³»ç»Ÿã€‚

## ğŸ“‹ ç« èŠ‚æ¦‚è§ˆ

<script>
function scrollToSection(sectionId) {
  const element = document.getElementById(sectionId);
  if (element) {
    const headerOffset = 100;
    const elementPosition = element.getBoundingClientRect().top;
    const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
    window.scrollTo({
      top: offsetPosition,
      behavior: 'smooth'
    });
  }
}
</script>

<div class="section-overview">
  <div class="section-item" onclick="scrollToSection('section-3-1-1')">
    <h4>ğŸ“Š 3.1.1 æŠ€æœ¯æŒ‡æ ‡åˆ†æ</h4>
    <p>ç§»åŠ¨å¹³å‡çº¿ã€è¶‹åŠ¿æŒ‡æ ‡ã€æ³¢åŠ¨æŒ‡æ ‡çš„è®¡ç®—å’Œåº”ç”¨</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-3-1-2')">
    <h4>ğŸ” 3.1.2 è¶‹åŠ¿è¯†åˆ«</h4>
    <p>ä¸Šå‡è¶‹åŠ¿ã€ä¸‹é™è¶‹åŠ¿ã€æ¨ªç›˜æ•´ç†çš„è¯†åˆ«ç®—æ³•</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-3-1-3')">
    <h4>ğŸ’ª 3.1.3 è¶‹åŠ¿å¼ºåº¦è¯„ä¼°</h4>
    <p>è¶‹åŠ¿å¼ºåº¦å¾—åˆ†ã€æŒç»­æ€§è¯„ä¼°ã€å¯é æ€§åˆ¤æ–­</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-3-1-4')">
    <h4>ğŸ¤– 3.1.4 AIè¾…åŠ©é¢„æµ‹</h4>
    <p>AIè¶‹åŠ¿è¯†åˆ«ã€æ™ºèƒ½è¶‹åŠ¿é¢„æµ‹ã€å¤šæ¨¡å‹èåˆ</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-3-1-5')">
    <h4>ğŸ”„ 3.1.5 è‡ªåŠ¨åŒ–å®ç°</h4>
    <p>å®šæ—¶åˆ†æã€è‡ªåŠ¨æ›´æ–°ã€è¶‹åŠ¿å‘Šè­¦æœºåˆ¶</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-3-1-6')">
    <h4>ğŸ› ï¸ 3.1.6 MCPå·¥å…·ä½¿ç”¨</h4>
    <p>ä½¿ç”¨MCPå·¥å…·æŸ¥è¯¢è¶‹åŠ¿åˆ†ææ–‡æ¡£ã€æ”¶é›†ç ”ç©¶èµ„æ–™</p>
  </div>
</div>

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬èŠ‚å­¦ä¹ ï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- **æŒæ¡æŠ€æœ¯æŒ‡æ ‡**ï¼šç†è§£ç§»åŠ¨å¹³å‡çº¿ã€MACDã€RSIã€KDJã€å¸ƒæ—å¸¦ç­‰æŒ‡æ ‡çš„è®¡ç®—æ–¹æ³•
- **ç†è§£è¶‹åŠ¿è¯†åˆ«**ï¼šæŒæ¡ä¸Šå‡è¶‹åŠ¿ã€ä¸‹é™è¶‹åŠ¿ã€æ¨ªç›˜æ•´ç†çš„è¯†åˆ«ç®—æ³•å’Œåˆ¤æ–­é€»è¾‘
- **ç†Ÿæ‚‰å¼ºåº¦è¯„ä¼°**ï¼šç†è§£è¶‹åŠ¿å¼ºåº¦å¾—åˆ†ã€æŒç»­æ€§è¯„ä¼°ã€å¯é æ€§åˆ¤æ–­çš„è®¡ç®—æ–¹æ³•
- **äº†è§£AIè¾…åŠ©**ï¼šæŒæ¡AIæŠ€æœ¯åœ¨è¶‹åŠ¿è¯†åˆ«å’Œé¢„æµ‹ä¸­çš„åº”ç”¨
- **å®ç°è‡ªåŠ¨åŒ–**ï¼šç†è§£å®šæ—¶åˆ†æã€è‡ªåŠ¨æ›´æ–°ã€è¶‹åŠ¿å‘Šè­¦çš„å®ç°æœºåˆ¶
- **ä½¿ç”¨MCPå·¥å…·**ï¼šæŒæ¡ä½¿ç”¨MCPå·¥å…·è¿›è¡Œè¶‹åŠ¿åˆ†æç›¸å…³ç ”ç©¶

<h2 id="section-3-1-1">ğŸ“Š 3.1.1 æŠ€æœ¯æŒ‡æ ‡åˆ†æ</h2>

æŠ€æœ¯æŒ‡æ ‡åˆ†ææ˜¯è¶‹åŠ¿åˆ†æçš„åŸºç¡€ï¼Œé€šè¿‡è®¡ç®—å„ç§æŠ€æœ¯æŒ‡æ ‡ï¼Œä¸ºè¶‹åŠ¿è¯†åˆ«æä¾›æ•°æ®æ”¯æ’‘ã€‚

### è®¾è®¡åŸåˆ™

<div class="key-points">
  <div class="key-point">
    <h4>ğŸ“ˆ å¤šæŒ‡æ ‡èåˆ</h4>
    <p>ç»¼åˆä½¿ç”¨å¤šç§æŠ€æœ¯æŒ‡æ ‡ï¼Œé¿å…å•ä¸€æŒ‡æ ‡çš„å±€é™æ€§</p>
  </div>
  <div class="key-point">
    <h4>âš¡ é«˜æ•ˆè®¡ç®—</h4>
    <p>ä½¿ç”¨å‘é‡åŒ–è®¡ç®—å’Œç¼“å­˜æœºåˆ¶ï¼Œæé«˜è®¡ç®—æ•ˆç‡</p>
  </div>
  <div class="key-point">
    <h4>ğŸ”§ å‚æ•°å¯é…ç½®</h4>
    <p>æ‰€æœ‰æŒ‡æ ‡å‚æ•°å¯é…ç½®ï¼Œé€‚åº”ä¸åŒå¸‚åœºç¯å¢ƒ</p>
  </div>
  <div class="key-point">
    <h4>ğŸ“Š ç»Ÿä¸€æ¥å£</h4>
    <p>æ‰€æœ‰æŒ‡æ ‡è®¡ç®—ä½¿ç”¨ç»Ÿä¸€çš„æ¥å£è§„èŒƒ</p>
  </div>
</div>

### ç§»åŠ¨å¹³å‡çº¿æŒ‡æ ‡

ç§»åŠ¨å¹³å‡çº¿ï¼ˆMoving Averageï¼‰æ˜¯æœ€åŸºç¡€çš„è¶‹åŠ¿æŒ‡æ ‡ï¼Œç”¨äºå¹³æ»‘ä»·æ ¼æ³¢åŠ¨ï¼Œè¯†åˆ«è¶‹åŠ¿æ–¹å‘ã€‚

#### ç®€å•ç§»åŠ¨å¹³å‡çº¿ï¼ˆSMAï¼‰

ç®€å•ç§»åŠ¨å¹³å‡çº¿æ˜¯Nä¸ªå‘¨æœŸæ”¶ç›˜ä»·çš„ç®—æœ¯å¹³å‡å€¼ï¼š

<CodeFromFile 
  filePath="code_library/003_Chapter3_Market_Analysis/3.1/code_3_1_1_calculate_sma.py"
  language="python"
  showDesignPrinciples="true"
/>

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```python
data = get_market_data('000001.SH', '2024-01-01', '2024-12-31')
sma_5 = calculate_sma(data, period=5)   # 5æ—¥å‡çº¿
sma_20 = calculate_sma(data, period=20)   # 20æ—¥å‡çº¿
sma_60 = calculate_sma(data, period=60)   # 60æ—¥å‡çº¿
```

#### æŒ‡æ•°ç§»åŠ¨å¹³å‡çº¿ï¼ˆEMAï¼‰

æŒ‡æ•°ç§»åŠ¨å¹³å‡çº¿å¯¹è¿‘æœŸä»·æ ¼èµ‹äºˆæ›´é«˜æƒé‡ï¼Œååº”æ›´çµæ•ï¼š

<CodeFromFile 
  filePath="code_library/003_Chapter3_Market_Analysis/3.1/code_3_1_1_calculate_ema.py"
  language="python"
  showDesignPrinciples="true"
/>

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```python
ema_12 = calculate_ema(data, period=12)  # 12æ—¥EMA
ema_26 = calculate_ema(data, period=26)    # 26æ—¥EMA
```

### è¶‹åŠ¿æŒ‡æ ‡

#### MACDæŒ‡æ ‡

MACDï¼ˆMoving Average Convergence Divergenceï¼‰æ˜¯å¸¸ç”¨çš„è¶‹åŠ¿æŒ‡æ ‡ï¼Œç”±å¿«çº¿ã€æ…¢çº¿å’Œä¿¡å·çº¿ç»„æˆï¼š

<CodeFromFile 
  filePath="code_library/003_Chapter3_Market_Analysis/3.1/code_3_1_1_calculate_macd.py"
  language="python"
  showDesignPrinciples="true"
/>

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```python
macd_data = calculate_macd(data)
# MACDé‡‘å‰ï¼šDIFä¸Šç©¿DEAï¼Œä¹°å…¥ä¿¡å·
# MACDæ­»å‰ï¼šDIFä¸‹ç©¿DEAï¼Œå–å‡ºä¿¡å·
```

#### RSIæŒ‡æ ‡

RSIï¼ˆRelative Strength Indexï¼‰æ˜¯ç›¸å¯¹å¼ºå¼±æŒ‡æ ‡ï¼Œç”¨äºåˆ¤æ–­è¶…ä¹°è¶…å–ï¼š

<CodeFromFile 
  filePath="code_library/003_Chapter3_Market_Analysis/3.1/code_3_1_1_calculate_rsi.py"
  language="python"
  showDesignPrinciples="true"
/>

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```python
rsi = calculate_rsi(data, period=14)
# RSI > 70ï¼šè¶…ä¹°ï¼Œå¯èƒ½å›è°ƒ
# RSI < 30ï¼šè¶…å–ï¼Œå¯èƒ½åå¼¹
```

### æ³¢åŠ¨æŒ‡æ ‡

#### å¸ƒæ—å¸¦ï¼ˆBollinger Bandsï¼‰

å¸ƒæ—å¸¦ç”±ä¸­è½¨ï¼ˆSMAï¼‰ã€ä¸Šè½¨ï¼ˆSMA + 2*æ ‡å‡†å·®ï¼‰ã€ä¸‹è½¨ï¼ˆSMA - 2*æ ‡å‡†å·®ï¼‰ç»„æˆï¼š

<CodeFromFile 
  filePath="code_library/003_Chapter3_Market_Analysis/3.1/code_3_1_1_calculate_bollinger_bands.py"
  language="python"
  showDesignPrinciples="true"
/>

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```python
bb = calculate_bollinger_bands(data)
# ä»·æ ¼è§¦åŠä¸Šè½¨ï¼šå¯èƒ½è¶…ä¹°
# ä»·æ ¼è§¦åŠä¸‹è½¨ï¼šå¯èƒ½è¶…å–
# å¸ƒæ—å¸¦æ”¶çª„ï¼šæ³¢åŠ¨ç‡é™ä½ï¼Œå¯èƒ½å˜ç›˜
```

### æŒ‡æ ‡ç®¡ç†å™¨å®ç°

```python
from typing import Dict, List, Optional
import pandas as pd
import logging

logger = logging.getLogger(__name__)


class IndicatorCalculator:
    """æŠ€æœ¯æŒ‡æ ‡è®¡ç®—å™¨"""
    
    def __init__(self):
        """
        åˆå§‹åŒ–æŠ€æœ¯æŒ‡æ ‡è®¡ç®—å™¨
        
        **è®¾è®¡åŸç†**ï¼š
        - **ç¼“å­˜æœºåˆ¶**ï¼šç¼“å­˜è®¡ç®—ç»“æœï¼Œé¿å…é‡å¤è®¡ç®—
        - **ç»Ÿä¸€æ¥å£**ï¼šæ‰€æœ‰æŒ‡æ ‡ä½¿ç”¨ç›¸åŒçš„æ¥å£ï¼Œç®€åŒ–è°ƒç”¨
        - **å»¶è¿Ÿè®¡ç®—**ï¼šæŒ‰éœ€è®¡ç®—ï¼Œä¸é¢„è®¡ç®—æ‰€æœ‰æŒ‡æ ‡
        
        **ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡**ï¼š
        1. **æ€§èƒ½ä¼˜åŒ–**ï¼šæŠ€æœ¯æŒ‡æ ‡è®¡ç®—å¯èƒ½è€—æ—¶ï¼Œç¼“å­˜é¿å…é‡å¤è®¡ç®—
        2. **æ¥å£ç»Ÿä¸€**ï¼šä¸åŒæŒ‡æ ‡ä½¿ç”¨ç›¸åŒæ¥å£ï¼Œä¾¿äºæ‰©å±•å’Œç»´æŠ¤
        3. **èµ„æºèŠ‚çº¦**ï¼šæŒ‰éœ€è®¡ç®—ï¼Œä¸æµªè´¹è®¡ç®—èµ„æº
        """
        self.indicators = {}
        self._cache = {}
    
    def calculate(self, data: pd.DataFrame, indicator_name: str, **kwargs) -> pd.Series:
        """
        è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
        
        **è®¾è®¡åŸç†**ï¼š
        - **ç¼“å­˜é”®ç”Ÿæˆ**ï¼šä½¿ç”¨æŒ‡æ ‡åç§°å’Œå‚æ•°ç”Ÿæˆå”¯ä¸€ç¼“å­˜é”®
        - **ç­–ç•¥æ¨¡å¼**ï¼šæ ¹æ®æŒ‡æ ‡åç§°é€‰æ‹©ç›¸åº”è®¡ç®—æ–¹æ³•
        - **ç»“æœç¼“å­˜**ï¼šè®¡ç®—ç»“æœç¼“å­˜ï¼Œæé«˜åç»­è°ƒç”¨æ•ˆç‡
        
        **ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡**ï¼š
        1. **æ€§èƒ½ä¼˜åŒ–**ï¼šç›¸åŒå‚æ•°çš„è®¡ç®—ç»“æœç¼“å­˜ï¼Œé¿å…é‡å¤è®¡ç®—
        2. **æ‰©å±•æ€§**ï¼šæ–°å¢æŒ‡æ ‡åªéœ€æ·»åŠ ä¸€ä¸ªåˆ†æ”¯ï¼Œæ— éœ€ä¿®æ”¹ç°æœ‰ä»£ç 
        3. **ä¸€è‡´æ€§**ï¼šæ‰€æœ‰æŒ‡æ ‡ä½¿ç”¨ç›¸åŒæ¥å£ï¼Œè°ƒç”¨æ–¹å¼ç»Ÿä¸€
        
        **ä½¿ç”¨åœºæ™¯**ï¼š
        - æ‰¹é‡è®¡ç®—å¤šä¸ªæŒ‡æ ‡æ—¶ï¼Œç¼“å­˜æé«˜æ•ˆç‡
        - é‡å¤è®¡ç®—ç›¸åŒæŒ‡æ ‡æ—¶ï¼Œç›´æ¥ä½¿ç”¨ç¼“å­˜
        - éœ€è¦ç»Ÿä¸€ç®¡ç†æ‰€æœ‰æŒ‡æ ‡è®¡ç®—æ—¶
        
        **æ³¨æ„äº‹é¡¹**ï¼š
        - ç¼“å­˜é”®åŸºäºå‚æ•°hashï¼Œå‚æ•°å˜åŒ–æ—¶è‡ªåŠ¨é‡æ–°è®¡ç®—
        - å¤§é‡æŒ‡æ ‡æ—¶æ³¨æ„å†…å­˜å ç”¨ï¼Œå¯è®¾ç½®ç¼“å­˜å¤§å°é™åˆ¶
        
        Args:
            data: ä»·æ ¼æ•°æ®
            indicator_name: æŒ‡æ ‡åç§°ï¼ˆSMA, EMA, MACD, RSI, BBç­‰ï¼‰
            **kwargs: æŒ‡æ ‡å‚æ•°
        
        Returns:
            æŒ‡æ ‡åºåˆ—
        """
        # è®¾è®¡åŸç†ï¼šä½¿ç”¨æŒ‡æ ‡åç§°å’Œå‚æ•°ç”Ÿæˆå”¯ä¸€ç¼“å­˜é”®
        # åŸå› ï¼šç›¸åŒæŒ‡æ ‡å’Œå‚æ•°çš„è®¡ç®—ç»“æœç›¸åŒï¼Œå¯ä»¥å¤ç”¨
        cache_key = f"{indicator_name}_{hash(str(kwargs))}"
        
        # æ£€æŸ¥ç¼“å­˜
        if cache_key in self._cache:
            return self._cache[cache_key]
        
        # è®¾è®¡åŸç†ï¼šç­–ç•¥æ¨¡å¼ï¼Œæ ¹æ®æŒ‡æ ‡åç§°é€‰æ‹©è®¡ç®—æ–¹æ³•
        # åŸå› ï¼šä¸åŒæŒ‡æ ‡è®¡ç®—é€»è¾‘ä¸åŒï¼Œéœ€è¦åˆ†åˆ«å¤„ç†
        # æ‰©å±•æ€§ï¼šæ–°å¢æŒ‡æ ‡åªéœ€æ·»åŠ ä¸€ä¸ªåˆ†æ”¯
        if indicator_name.upper() == 'SMA':
            result = calculate_sma(data, **kwargs)
        elif indicator_name.upper() == 'EMA':
            result = calculate_ema(data, **kwargs)
        elif indicator_name.upper() == 'MACD':
            result = calculate_macd(data, **kwargs)
        elif indicator_name.upper() == 'RSI':
            result = calculate_rsi(data, **kwargs)
        elif indicator_name.upper() == 'BB':
            result = calculate_bollinger_bands(data, **kwargs)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„æŒ‡æ ‡: {indicator_name}")
        
        # è®¾è®¡åŸç†ï¼šè®¡ç®—ç»“æœç¼“å­˜
        # åŸå› ï¼šç›¸åŒå‚æ•°çš„è®¡ç®—ç»“æœå¯ä»¥å¤ç”¨ï¼Œæé«˜åç»­è°ƒç”¨æ•ˆç‡
        self._cache[cache_key] = result
        return result
    
    def calculate_multiple(self, data: pd.DataFrame, 
                          indicators: List[Dict]) -> pd.DataFrame:
        """
        æ‰¹é‡è®¡ç®—å¤šä¸ªæŒ‡æ ‡
        
        Args:
            data: ä»·æ ¼æ•°æ®
            indicators: æŒ‡æ ‡é…ç½®åˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ ä¸º {'name': 'SMA', 'period': 20}
        
        Returns:
            åŒ…å«æ‰€æœ‰æŒ‡æ ‡çš„DataFrame
        """
        results = {}
        for indicator in indicators:
            name = indicator['name']
            params = {k: v for k, v in indicator.items() if k != 'name'}
            result = self.calculate(data, name, **params)
            
            if isinstance(result, pd.DataFrame):
                for col in result.columns:
                    results[f"{name}_{col}"] = result[col]
            else:
                results[name] = result
        
        return pd.DataFrame(results)
```

<h2 id="section-3-1-2">ğŸ” 3.1.2 è¶‹åŠ¿è¯†åˆ«</h2>

è¶‹åŠ¿è¯†åˆ«æ˜¯è¶‹åŠ¿åˆ†æçš„æ ¸å¿ƒï¼Œé€šè¿‡åˆ†æä»·æ ¼èµ°åŠ¿å’ŒæŠ€æœ¯æŒ‡æ ‡ï¼Œè¯†åˆ«å¸‚åœºçš„ä¸Šå‡è¶‹åŠ¿ã€ä¸‹é™è¶‹åŠ¿å’Œæ¨ªç›˜æ•´ç†ã€‚

### è¶‹åŠ¿åˆ†ç±»

å¸‚åœºè¶‹åŠ¿å¯ä»¥åˆ†ä¸ºä¸‰ç±»ï¼š

1. **ä¸Šå‡è¶‹åŠ¿**ï¼šä»·æ ¼æŒç»­ä¸Šæ¶¨ï¼Œä½ç‚¹å’Œé«˜ç‚¹é€æ­¥æŠ¬é«˜
2. **ä¸‹é™è¶‹åŠ¿**ï¼šä»·æ ¼æŒç»­ä¸‹è·Œï¼Œé«˜ç‚¹ä½ç‚¹é€æ­¥é™ä½
3. **æ¨ªç›˜æ•´ç†**ï¼šä»·æ ¼åœ¨ä¸€å®šåŒºé—´å†…éœ‡è¡ï¼Œæ— æ˜æ˜¾æ–¹å‘

### ä¸Šå‡è¶‹åŠ¿è¯†åˆ«

ä¸Šå‡è¶‹åŠ¿çš„ç‰¹å¾ï¼š
- ä»·æ ¼åœ¨ç§»åŠ¨å¹³å‡çº¿ä¸Šæ–¹
- çŸ­æœŸå‡çº¿åœ¨é•¿æœŸå‡çº¿ä¸Šæ–¹ï¼ˆå¤šå¤´æ’åˆ—ï¼‰
- MACDçš„DIFåœ¨DEAä¸Šæ–¹
- ä»·æ ¼ä½ç‚¹é€æ­¥æŠ¬é«˜

```python
def identify_uptrend(data: pd.DataFrame, 
                    sma_short: int = 5,
                    sma_long: int = 20) -> pd.Series:
    """
    è¯†åˆ«ä¸Šå‡è¶‹åŠ¿
    
    Args:
        data: ä»·æ ¼æ•°æ®
        sma_short: çŸ­æœŸå‡çº¿å‘¨æœŸ
        sma_long: é•¿æœŸå‡çº¿å‘¨æœŸ
    
    Returns:
        å¸ƒå°”åºåˆ—ï¼ŒTrueè¡¨ç¤ºä¸Šå‡è¶‹åŠ¿
    """
    sma_short_line = calculate_sma(data, period=sma_short)
    sma_long_line = calculate_sma(data, period=sma_long)
    
    # æ¡ä»¶1ï¼šçŸ­æœŸå‡çº¿åœ¨é•¿æœŸå‡çº¿ä¸Šæ–¹
    condition1 = sma_short_line > sma_long_line
    
    # æ¡ä»¶2ï¼šä»·æ ¼åœ¨çŸ­æœŸå‡çº¿ä¸Šæ–¹
    condition2 = data['close'] > sma_short_line
    
    # æ¡ä»¶3ï¼šMACDé‡‘å‰æˆ–DIFåœ¨DEAä¸Šæ–¹
    macd_data = calculate_macd(data)
    condition3 = macd_data['DIF'] > macd_data['DEA']
    
    # æ¡ä»¶4ï¼šä»·æ ¼ä½ç‚¹é€æ­¥æŠ¬é«˜ï¼ˆæœ€è¿‘3ä¸ªä½ç‚¹ï¼‰
    lows = data['low'].rolling(window=3).min()
    condition4 = lows.diff() > 0
    
    # ç»¼åˆåˆ¤æ–­ï¼šè‡³å°‘æ»¡è¶³3ä¸ªæ¡ä»¶
    uptrend = (condition1.astype(int) + 
               condition2.astype(int) + 
               condition3.astype(int) + 
               condition4.astype(int)) >= 3
    
    return uptrend
```

### ä¸‹é™è¶‹åŠ¿è¯†åˆ«

ä¸‹é™è¶‹åŠ¿çš„ç‰¹å¾ï¼š
- ä»·æ ¼åœ¨ç§»åŠ¨å¹³å‡çº¿ä¸‹æ–¹
- çŸ­æœŸå‡çº¿åœ¨é•¿æœŸå‡çº¿ä¸‹æ–¹ï¼ˆç©ºå¤´æ’åˆ—ï¼‰
- MACDçš„DIFåœ¨DEAä¸‹æ–¹
- ä»·æ ¼é«˜ç‚¹é€æ­¥é™ä½

```python
def identify_downtrend(data: pd.DataFrame,
                      sma_short: int = 5,
                      sma_long: int = 20) -> pd.Series:
    """
    è¯†åˆ«ä¸‹é™è¶‹åŠ¿
    
    Args:
        data: ä»·æ ¼æ•°æ®
        sma_short: çŸ­æœŸå‡çº¿å‘¨æœŸ
        sma_long: é•¿æœŸå‡çº¿å‘¨æœŸ
    
    Returns:
        å¸ƒå°”åºåˆ—ï¼ŒTrueè¡¨ç¤ºä¸‹é™è¶‹åŠ¿
    """
    sma_short_line = calculate_sma(data, period=sma_short)
    sma_long_line = calculate_sma(data, period=sma_long)
    
    # æ¡ä»¶1ï¼šçŸ­æœŸå‡çº¿åœ¨é•¿æœŸå‡çº¿ä¸‹æ–¹
    condition1 = sma_short_line < sma_long_line
    
    # æ¡ä»¶2ï¼šä»·æ ¼åœ¨çŸ­æœŸå‡çº¿ä¸‹æ–¹
    condition2 = data['close'] < sma_short_line
    
    # æ¡ä»¶3ï¼šMACDæ­»å‰æˆ–DIFåœ¨DEAä¸‹æ–¹
    macd_data = calculate_macd(data)
    condition3 = macd_data['DIF'] < macd_data['DEA']
    
    # æ¡ä»¶4ï¼šä»·æ ¼é«˜ç‚¹é€æ­¥é™ä½ï¼ˆæœ€è¿‘3ä¸ªé«˜ç‚¹ï¼‰
    highs = data['high'].rolling(window=3).max()
    condition4 = highs.diff() < 0
    
    # ç»¼åˆåˆ¤æ–­ï¼šè‡³å°‘æ»¡è¶³3ä¸ªæ¡ä»¶
    downtrend = (condition1.astype(int) + 
                 condition2.astype(int) + 
                 condition3.astype(int) + 
                 condition4.astype(int)) >= 3
    
    return downtrend
```

### æ¨ªç›˜æ•´ç†è¯†åˆ«

æ¨ªç›˜æ•´ç†çš„ç‰¹å¾ï¼š
- ä»·æ ¼åœ¨ä¸€å®šåŒºé—´å†…éœ‡è¡
- ç§»åŠ¨å¹³å‡çº¿è¶‹äºæ°´å¹³
- æ³¢åŠ¨ç‡è¾ƒä½
- æ— æ˜æ˜¾æ–¹å‘æ€§

```python
def identify_sideways(data: pd.DataFrame,
                     period: int = 20,
                     threshold: float = 0.02) -> pd.Series:
    """
    è¯†åˆ«æ¨ªç›˜æ•´ç†
    
    Args:
        data: ä»·æ ¼æ•°æ®
        period: åˆ†æå‘¨æœŸ
        threshold: æ³¢åŠ¨ç‡é˜ˆå€¼ï¼ˆé»˜è®¤2%ï¼‰
    
    Returns:
        å¸ƒå°”åºåˆ—ï¼ŒTrueè¡¨ç¤ºæ¨ªç›˜æ•´ç†
    """
    # è®¡ç®—æ³¢åŠ¨ç‡ï¼ˆæ ‡å‡†å·®/å‡å€¼ï¼‰
    volatility = data['close'].rolling(window=period).std() / \
                 data['close'].rolling(window=period).mean()
    
    # æ¡ä»¶1ï¼šæ³¢åŠ¨ç‡ä½äºé˜ˆå€¼
    condition1 = volatility < threshold
    
    # æ¡ä»¶2ï¼šä»·æ ¼åœ¨å¸ƒæ—å¸¦ä¸­è½¨é™„è¿‘ï¼ˆÂ±1%ï¼‰
    bb = calculate_bollinger_bands(data)
    price_deviation = abs(data['close'] - bb['middle']) / bb['middle']
    condition2 = price_deviation < 0.01
    
    # æ¡ä»¶3ï¼šç§»åŠ¨å¹³å‡çº¿æ–œç‡æ¥è¿‘0
    sma = calculate_sma(data, period=period)
    sma_slope = sma.diff() / sma
    condition3 = abs(sma_slope) < 0.001
    
    # ç»¼åˆåˆ¤æ–­ï¼šè‡³å°‘æ»¡è¶³2ä¸ªæ¡ä»¶
    sideways = (condition1.astype(int) + 
                condition2.astype(int) + 
                condition3.astype(int)) >= 2
    
    return sideways
```

### è¶‹åŠ¿è¯†åˆ«å™¨å®ç°

```python
class TrendIdentifier:
    """è¶‹åŠ¿è¯†åˆ«å™¨"""
    
    def __init__(self):
        self.calculator = IndicatorCalculator()
    
    def identify(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        è¯†åˆ«å¸‚åœºè¶‹åŠ¿
        
        Args:
            data: ä»·æ ¼æ•°æ®
        
        Returns:
            DataFrameåŒ…å«trendåˆ—ï¼ˆ'up', 'down', 'sideways'ï¼‰
        """
        uptrend = identify_uptrend(data)
        downtrend = identify_downtrend(data)
        sideways = identify_sideways(data)
        
        # ä¼˜å…ˆçº§ï¼šä¸Šå‡è¶‹åŠ¿ > ä¸‹é™è¶‹åŠ¿ > æ¨ªç›˜æ•´ç†
        trend = pd.Series('sideways', index=data.index)
        trend[uptrend] = 'up'
        trend[downtrend] = 'down'
        
        return pd.DataFrame({
            'trend': trend,
            'uptrend_signal': uptrend,
            'downtrend_signal': downtrend,
            'sideways_signal': sideways
        })
```

<h2 id="section-3-1-3">ğŸ’ª 3.1.3 è¶‹åŠ¿å¼ºåº¦è¯„ä¼°</h2>

è¶‹åŠ¿å¼ºåº¦è¯„ä¼°ç”¨äºé‡åŒ–è¶‹åŠ¿çš„å¼ºåº¦ã€æŒç»­æ€§å’Œå¯é æ€§ï¼Œä¸ºç­–ç•¥å†³ç­–æä¾›ä¾æ®ã€‚

### è¶‹åŠ¿å¼ºåº¦å¾—åˆ†

è¶‹åŠ¿å¼ºåº¦å¾—åˆ†ç»¼åˆè€ƒè™‘å¤šä¸ªå› ç´ ï¼š

```python
def calculate_trend_strength(data: pd.DataFrame, 
                            trend: pd.Series) -> pd.Series:
    """
    è®¡ç®—è¶‹åŠ¿å¼ºåº¦å¾—åˆ†ï¼ˆ0-100ï¼‰
    
    Args:
        data: ä»·æ ¼æ•°æ®
        trend: è¶‹åŠ¿åºåˆ—ï¼ˆ'up', 'down', 'sideways'ï¼‰
    
    Returns:
        è¶‹åŠ¿å¼ºåº¦å¾—åˆ†åºåˆ—
    """
    strength = pd.Series(0.0, index=data.index)
    
    for i in range(len(data)):
        if trend.iloc[i] == 'sideways':
            strength.iloc[i] = 0
            continue
        
        # å› å­1ï¼šå‡çº¿æ’åˆ—å¼ºåº¦ï¼ˆ0-30åˆ†ï¼‰
        sma_5 = calculate_sma(data.iloc[:i+1], period=5)
        sma_20 = calculate_sma(data.iloc[:i+1], period=20)
        sma_60 = calculate_sma(data.iloc[:i+1], period=60)
        
        if trend.iloc[i] == 'up':
            ma_score = 0
            if len(sma_5) > 0 and len(sma_20) > 0:
                if sma_5.iloc[-1] > sma_20.iloc[-1]:
                    ma_score += 10
            if len(sma_20) > 0 and len(sma_60) > 0:
                if sma_20.iloc[-1] > sma_60.iloc[-1]:
                    ma_score += 10
            if len(sma_5) > 0 and len(sma_60) > 0:
                if sma_5.iloc[-1] > sma_60.iloc[-1]:
                    ma_score += 10
        else:  # downtrend
            ma_score = 0
            if len(sma_5) > 0 and len(sma_20) > 0:
                if sma_5.iloc[-1] < sma_20.iloc[-1]:
                    ma_score += 10
            if len(sma_20) > 0 and len(sma_60) > 0:
                if sma_20.iloc[-1] < sma_60.iloc[-1]:
                    ma_score += 10
            if len(sma_5) > 0 and len(sma_60) > 0:
                if sma_5.iloc[-1] < sma_60.iloc[-1]:
                    ma_score += 10
        
        # å› å­2ï¼šMACDå¼ºåº¦ï¼ˆ0-30åˆ†ï¼‰
        macd_data = calculate_macd(data.iloc[:i+1])
        if len(macd_data) > 0:
            macd_value = abs(macd_data['MACD'].iloc[-1])
            macd_score = min(30, macd_value * 100)  # å½’ä¸€åŒ–åˆ°0-30
        else:
            macd_score = 0
        
        # å› å­3ï¼šä»·æ ¼æ¶¨å¹…/è·Œå¹…ï¼ˆ0-20åˆ†ï¼‰
        if i >= 20:
            price_change = (data['close'].iloc[i] - data['close'].iloc[i-20]) / \
                          data['close'].iloc[i-20]
            price_score = min(20, abs(price_change) * 100)
        else:
            price_score = 0
        
        # å› å­4ï¼šæˆäº¤é‡é…åˆï¼ˆ0-20åˆ†ï¼‰
        if i >= 20:
            volume_ratio = data['volume'].iloc[i] / data['volume'].iloc[i-20:i].mean()
            volume_score = min(20, (volume_ratio - 1) * 10) if volume_ratio > 1 else 0
        else:
            volume_score = 0
        
        strength.iloc[i] = ma_score + macd_score + price_score + volume_score
    
    return strength
```

### è¶‹åŠ¿æŒç»­æ€§è¯„ä¼°

è¶‹åŠ¿æŒç»­æ€§è¯„ä¼°è¶‹åŠ¿èƒ½å¤ŸæŒç»­çš„æ¦‚ç‡ï¼š

```python
def assess_trend_persistence(data: pd.DataFrame,
                             trend: pd.Series,
                             lookback: int = 10) -> pd.Series:
    """
    è¯„ä¼°è¶‹åŠ¿æŒç»­æ€§ï¼ˆ0-1ï¼‰
    
    Args:
        data: ä»·æ ¼æ•°æ®
        trend: è¶‹åŠ¿åºåˆ—
        lookback: å›çœ‹å‘¨æœŸ
    
    Returns:
        è¶‹åŠ¿æŒç»­æ€§å¾—åˆ†åºåˆ—
    """
    persistence = pd.Series(0.0, index=data.index)
    
    for i in range(lookback, len(data)):
        # è®¡ç®—æœ€è¿‘lookbackæœŸå†…è¶‹åŠ¿ä¸€è‡´æ€§
        recent_trends = trend.iloc[i-lookback:i]
        current_trend = trend.iloc[i]
        
        # ä¸€è‡´æ€§æ¯”ä¾‹
        consistency = (recent_trends == current_trend).sum() / len(recent_trends)
        
        # è¶‹åŠ¿æŒç»­æ—¶é—´
        duration = 0
        for j in range(i, -1, -1):
            if trend.iloc[j] == current_trend:
                duration += 1
            else:
                break
        
        # æŒç»­æ€§å¾—åˆ† = ä¸€è‡´æ€§ * 0.6 + æŒç»­æ—¶é—´å› å­ * 0.4
        duration_factor = min(1.0, duration / 20)  # æŒç»­æ—¶é—´è¶Šé•¿ï¼Œå› å­è¶Šé«˜
        persistence.iloc[i] = consistency * 0.6 + duration_factor * 0.4
    
    return persistence
```

<h2 id="section-3-1-4">ğŸ¤– 3.1.4 AIè¾…åŠ©é¢„æµ‹</h2>

AIè¾…åŠ©é¢„æµ‹ä½¿ç”¨æœºå™¨å­¦ä¹ æŠ€æœ¯ï¼Œæé«˜è¶‹åŠ¿è¯†åˆ«çš„å‡†ç¡®æ€§å’Œé¢„æµ‹èƒ½åŠ›ã€‚

### AIè¶‹åŠ¿è¯†åˆ«

ä½¿ç”¨LSTMç­‰æ·±åº¦å­¦ä¹ æ¨¡å‹è¯†åˆ«è¶‹åŠ¿ï¼š

```python
import torch
import torch.nn as nn
from sklearn.preprocessing import MinMaxScaler

class TrendLSTM(nn.Module):
    """LSTMè¶‹åŠ¿è¯†åˆ«æ¨¡å‹"""
    
    def __init__(self, input_size=10, hidden_size=64, num_layers=2, output_size=3):
        super(TrendLSTM, self).__init__()
        self.hidden_size = hidden_size
        self.num_layers = num_layers
        
        self.lstm = nn.LSTM(input_size, hidden_size, num_layers, batch_first=True)
        self.fc = nn.Linear(hidden_size, output_size)
        self.softmax = nn.Softmax(dim=1)
    
    def forward(self, x):
        out, _ = self.lstm(x)
        out = self.fc(out[:, -1, :])
        out = self.softmax(out)
        return out

# ä½¿ç”¨ç¤ºä¾‹
def predict_trend_ai(data: pd.DataFrame, model: TrendLSTM) -> pd.Series:
    """
    ä½¿ç”¨AIæ¨¡å‹é¢„æµ‹è¶‹åŠ¿
    
    Args:
        data: ä»·æ ¼æ•°æ®
        model: è®­ç»ƒå¥½çš„LSTMæ¨¡å‹
    
    Returns:
        è¶‹åŠ¿é¢„æµ‹åºåˆ—
    """
    # ç‰¹å¾å·¥ç¨‹ï¼šæå–æŠ€æœ¯æŒ‡æ ‡ä½œä¸ºç‰¹å¾
    features = pd.DataFrame()
    features['sma_5'] = calculate_sma(data, period=5)
    features['sma_20'] = calculate_sma(data, period=20)
    features['rsi'] = calculate_rsi(data)
    # ... æ›´å¤šç‰¹å¾
    
    # æ•°æ®é¢„å¤„ç†
    scaler = MinMaxScaler()
    features_scaled = scaler.fit_transform(features.fillna(0))
    
    # é¢„æµ‹
    model.eval()
    with torch.no_grad():
        # è½¬æ¢ä¸ºåºåˆ—æ•°æ®
        sequences = create_sequences(features_scaled, seq_length=10)
        predictions = model(sequences)
        
        # è½¬æ¢ä¸ºè¶‹åŠ¿æ ‡ç­¾
        trend_labels = ['up', 'down', 'sideways']
        trends = [trend_labels[pred.argmax()] for pred in predictions]
    
    return pd.Series(trends, index=data.index[-len(trends):])
```

<h2 id="section-3-1-5">ğŸ”„ 3.1.5 è‡ªåŠ¨åŒ–å®ç°</h2>

è¶‹åŠ¿åˆ†ææ¨¡å—æ”¯æŒè‡ªåŠ¨åŒ–è¿è¡Œï¼Œå®šæ—¶åˆ†æå¸‚åœºè¶‹åŠ¿ï¼Œè‡ªåŠ¨æ›´æ–°ç»“æœã€‚

### å®šæ—¶åˆ†æ

```python
import schedule
import time
from datetime import datetime

class TrendAnalyzer:
    """è¶‹åŠ¿åˆ†æå™¨"""
    
    def __init__(self):
        self.calculator = IndicatorCalculator()
        self.identifier = TrendIdentifier()
        self.last_analysis_time = None
        self.current_trend = None
    
    def analyze(self, symbol: str = '000001.SH'):
        """
        åˆ†æå¸‚åœºè¶‹åŠ¿
        
        Args:
            symbol: è‚¡ç¥¨ä»£ç æˆ–æŒ‡æ•°ä»£ç 
        """
        # è·å–æ•°æ®
        data = get_market_data(symbol, 
                              start_date=(datetime.now() - timedelta(days=120)).strftime('%Y-%m-%d'),
                              end_date=datetime.now().strftime('%Y-%m-%d'))
        
        # è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
        indicators = self.calculator.calculate_multiple(data, [
            {'name': 'SMA', 'period': 5},
            {'name': 'SMA', 'period': 20},
            {'name': 'MACD'},
            {'name': 'RSI'}
        ])
        
        # è¯†åˆ«è¶‹åŠ¿
        trend_result = self.identifier.identify(data)
        
        # è¯„ä¼°è¶‹åŠ¿å¼ºåº¦
        strength = calculate_trend_strength(data, trend_result['trend'])
        
        # è¯„ä¼°æŒç»­æ€§
        persistence = assess_trend_persistence(data, trend_result['trend'])
        
        # æ›´æ–°ç»“æœ
        self.current_trend = {
            'symbol': symbol,
            'trend': trend_result['trend'].iloc[-1],
            'strength': strength.iloc[-1],
            'persistence': persistence.iloc[-1],
            'timestamp': datetime.now()
        }
        
        self.last_analysis_time = datetime.now()
        
        logger.info(f"è¶‹åŠ¿åˆ†æå®Œæˆ: {self.current_trend}")
        
        return self.current_trend
    
    def start_auto_analysis(self, interval_minutes: int = 30):
        """
        å¯åŠ¨è‡ªåŠ¨åˆ†æ
        
        Args:
            interval_minutes: åˆ†æé—´éš”ï¼ˆåˆ†é’Ÿï¼‰
        """
        schedule.every(interval_minutes).minutes.do(self.analyze)
        
        # ç«‹å³æ‰§è¡Œä¸€æ¬¡
        self.analyze()
        
        # æŒç»­è¿è¡Œ
        while True:
            schedule.run_pending()
            time.sleep(60)
```

<h2 id="section-3-1-6">ğŸ› ï¸ 3.1.6 MCPå·¥å…·ä½¿ç”¨</h2>

è¶‹åŠ¿åˆ†ææ¨¡å—ä¸MCPå·¥å…·é›†æˆï¼Œæ”¯æŒçŸ¥è¯†åº“æŸ¥è¯¢ã€æ•°æ®æ”¶é›†ç­‰åŠŸèƒ½ã€‚

### KB MCP Serverå·¥å…·

#### kb.query

æŸ¥è¯¢çŸ¥è¯†åº“ï¼Œè·å–è¶‹åŠ¿åˆ†æç›¸å…³çš„æ–‡æ¡£å’Œä»£ç ï¼š

```python
# æŸ¥è¯¢è¶‹åŠ¿åˆ†æç›¸å…³çš„çŸ¥è¯†
results = mcp_client.call_tool(
    "kb.query",
    {
        "query": "æŠ€æœ¯æŒ‡æ ‡åˆ†ææ–¹æ³• MACD RSI è¶‹åŠ¿è¯†åˆ«",
        "collection": "manual_kb",
        "top_k": 5
    }
)

# è¿”å›ç»“æœåŒ…å«ç›¸å…³æ–‡æ¡£ç‰‡æ®µå’Œä»£ç ç¤ºä¾‹
for result in results:
    print(f"æ–‡æ¡£: {result['title']}")
    print(f"å†…å®¹: {result['content'][:200]}...")
```

### Data Collector MCPå·¥å…·

#### data_collector.crawl_web

çˆ¬å–ç½‘é¡µå†…å®¹ï¼Œæ”¶é›†è¶‹åŠ¿åˆ†æç›¸å…³çš„ç ”ç©¶èµ„æ–™ï¼š

```python
# çˆ¬å–æŠ€æœ¯åˆ†æç›¸å…³ç½‘é¡µ
content = mcp_client.call_tool(
    "data_collector.crawl_web",
    {
        "url": "https://example.com/technical-analysis",
        "extract_text": True
    }
)
```

## ğŸ”— ç›¸å…³ç« èŠ‚

- **ç¬¬2ç« ï¼šæ•°æ®æºæ¨¡å—** - äº†è§£æ•°æ®è·å–æœºåˆ¶ï¼Œä¸ºè¶‹åŠ¿åˆ†ææä¾›æ•°æ®æ”¯æ’‘
- **ç¬¬3ç« ï¼šå¸‚åœºåˆ†ææ¨¡å—** - äº†è§£å¸‚åœºåˆ†ææ¨¡å—çš„æ•´ä½“è®¾è®¡
- **ç¬¬3.2èŠ‚ï¼šå¸‚åœºçŠ¶æ€** - è¶‹åŠ¿åˆ†æç»“æœç”¨äºå¸‚åœºçŠ¶æ€åˆ¤æ–­
- **ç¬¬4ç« ï¼šæŠ•èµ„ä¸»çº¿è¯†åˆ«** - è¶‹åŠ¿åˆ†æç»“æœç”¨äºä¸»çº¿è¯†åˆ«
- **ç¬¬6ç« ï¼šå› å­åº“** - è¶‹åŠ¿åˆ†æç»“æœç”¨äºå› å­æ¨è
- **ç¬¬7ç« ï¼šç­–ç•¥å¼€å‘** - è¶‹åŠ¿åˆ†æç»“æœç”¨äºç­–ç•¥ç”Ÿæˆ
- **ç¬¬10ç« ï¼šå¼€å‘æŒ‡å—** - äº†è§£è¶‹åŠ¿åˆ†ææ¨¡å—çš„å¼€å‘è§„èŒƒ

## ğŸ”® æ€»ç»“ä¸å±•æœ›

<div class="summary-outlook">
  <h3>æœ¬èŠ‚å›é¡¾</h3>
  <p>æœ¬èŠ‚ç³»ç»Ÿä»‹ç»äº†è¶‹åŠ¿åˆ†æåŠŸèƒ½ï¼ŒåŒ…æ‹¬æŠ€æœ¯æŒ‡æ ‡åˆ†æã€è¶‹åŠ¿è¯†åˆ«ç®—æ³•å’Œè¶‹åŠ¿å¼ºåº¦è¯„ä¼°æ–¹æ³•ã€‚é€šè¿‡ç†è§£å¸‚åœºè¶‹åŠ¿åˆ¤æ–­çš„æ ¸å¿ƒæŠ€æœ¯ï¼Œå¸®åŠ©å¼€å‘è€…æŒæ¡å¦‚ä½•è¯†åˆ«å’Œè¯„ä¼°å¸‚åœºè¶‹åŠ¿ï¼Œä¸ºæŠ•èµ„å†³ç­–æä¾›æŠ€æœ¯æ”¯æ’‘ã€‚</p>
  
  <h3>ä¸‹èŠ‚é¢„å‘Š</h3>
  <p>æŒæ¡äº†è¶‹åŠ¿åˆ†ææ–¹æ³•åï¼Œä¸‹ä¸€èŠ‚å°†ä»‹ç»å¸‚åœºçŠ¶æ€åˆ¤æ–­ï¼ŒåŒ…æ‹¬å¸‚åœºçŠ¶æ€åˆ†ç±»ä½“ç³»ã€å¤šç»´åº¦åˆ¤æ–­æœºåˆ¶å’ŒçŠ¶æ€è¯„åˆ†æ–¹æ³•ã€‚é€šè¿‡ç†è§£å¸‚åœºç¯å¢ƒè¯„ä¼°æŠ€æœ¯ï¼Œå¸®åŠ©å¼€å‘è€…æŒæ¡å¦‚ä½•å…¨é¢åˆ¤æ–­å¸‚åœºçŠ¶æ€ã€‚</p>
  
  <a href="/ashare-book6/003_Chapter3_Market_Analysis/3.2_Market_Status_CN" class="next-section">
    ç»§ç»­å­¦ä¹ ï¼š3.2 å¸‚åœºçŠ¶æ€ â†’
  </a>
</div>

> **é€‚ç”¨ç‰ˆæœ¬**: v1.0.0+  
> **æœ€åæ›´æ–°**: 2025-12-12
