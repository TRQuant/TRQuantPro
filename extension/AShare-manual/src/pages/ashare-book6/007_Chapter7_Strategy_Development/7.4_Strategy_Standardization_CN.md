---
title: "7.4 ç­–ç•¥è§„èŒƒåŒ–"
description: "æ·±å…¥è§£æç­–ç•¥è§„èŒƒåŒ–ç³»ç»Ÿï¼ŒåŒ…æ‹¬ä»£ç è§„èŒƒåŒ–ã€å‚æ•°è§„èŒƒåŒ–ã€æ¥å£è§„èŒƒåŒ–ç­‰æ ¸å¿ƒæŠ€æœ¯"
lang: "zh-CN"
layout: "/src/layouts/HandbookLayout.astro"
currentBook: "ashare-book6"
updateDate: "2025-12-12"
---

# ğŸ“ 7.4 ç­–ç•¥è§„èŒƒåŒ–

> **æ ¸å¿ƒæ‘˜è¦ï¼š**
> 
> æœ¬èŠ‚ç³»ç»Ÿä»‹ç»TRQuantç³»ç»Ÿçš„ç­–ç•¥è§„èŒƒåŒ–ç³»ç»Ÿï¼Œåœ¨ç­–ç•¥ä¼˜åŒ–ä¹‹å‰å¯¹ç­–ç•¥è¿›è¡Œæ ‡å‡†åŒ–å¤„ç†ï¼Œç¡®ä¿ç­–ç•¥ç¬¦åˆç³»ç»Ÿè§„èŒƒã€‚é€šè¿‡ç†è§£ä»£ç è§„èŒƒåŒ–ã€å‚æ•°è§„èŒƒåŒ–ã€æ¥å£è§„èŒƒåŒ–å’Œå…ƒæ•°æ®è§„èŒƒåŒ–ï¼Œå¸®åŠ©å¼€å‘è€…æŒæ¡å¦‚ä½•ç¡®ä¿ç”Ÿæˆçš„ç­–ç•¥ä»£ç ç¬¦åˆè§„èŒƒï¼Œä¸ºç­–ç•¥ä¼˜åŒ–å’Œå›æµ‹éªŒè¯æä¾›æ ‡å‡†åŒ–çš„ç­–ç•¥ä»£ç ã€‚

ç­–ç•¥è§„èŒƒåŒ–æ˜¯åœ¨ç­–ç•¥ä¼˜åŒ–ä¹‹å‰å¯¹ç­–ç•¥è¿›è¡Œæ ‡å‡†åŒ–å¤„ç†ï¼Œç¡®ä¿ç­–ç•¥ç¬¦åˆç³»ç»Ÿè§„èŒƒï¼Œä¾¿äºåç»­çš„ä¼˜åŒ–å’Œå›æµ‹ã€‚

## ğŸ“‹ ç« èŠ‚æ¦‚è§ˆ

<script>
function scrollToSection(sectionId) {
  const element = document.getElementById(sectionId);
  if (element) {
    const headerOffset = 100;
    const elementPosition = element.getBoundingClientRect().top;
    const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
    window.scrollTo({
      top: offsetPosition,
      behavior: 'smooth'
    });
  }
}
</script>

<div class="section-overview">
  <div class="section-item" onclick="scrollToSection('section-7-4-1')">
    <h4>ğŸ“‹ 7.4.1 ä»£ç è§„èŒƒåŒ–</h4>
    <p>ä»£ç æ ¼å¼ã€å‘½åè§„èŒƒã€æ³¨é‡Šè§„èŒƒã€PEP8è§„èŒƒã€ä»£ç é£æ ¼ç»Ÿä¸€</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-7-4-2')">
    <h4>âš™ï¸ 7.4.2 å‚æ•°è§„èŒƒåŒ–</h4>
    <p>å‚æ•°ç±»å‹ã€å‚æ•°èŒƒå›´ã€å‚æ•°é»˜è®¤å€¼ã€å‚æ•°éªŒè¯ã€å‚æ•°æ–‡æ¡£</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-7-4-3')">
    <h4>ğŸ”Œ 7.4.3 æ¥å£è§„èŒƒåŒ–</h4>
    <p>ç­–ç•¥æ¥å£ã€è¾“å…¥è¾“å‡ºæ ¼å¼ã€å¼‚å¸¸å¤„ç†ã€æ¥å£æ–‡æ¡£</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-7-4-4')">
    <h4>ğŸ—ï¸ 7.4.4 ç»“æ„è§„èŒƒåŒ–</h4>
    <p>ç­–ç•¥æ¨¡æ¿è½¬æ¢ã€æ¥å£ç»Ÿä¸€ã€å‚æ•°æ ‡å‡†åŒ–ã€æ¨¡å—åŒ–ç»„ç»‡</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-7-4-5')">
    <h4>ğŸ“Š 7.4.5 å…ƒæ•°æ®è§„èŒƒåŒ–</h4>
    <p>å…ƒæ•°æ®å®šä¹‰ã€å…ƒæ•°æ®éªŒè¯ã€å…ƒæ•°æ®è¡¥å……ã€å…ƒæ•°æ®æ–‡æ¡£</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-7-4-6')">
    <h4>âœ… 7.4.6 è§„èŒƒåŒ–éªŒè¯</h4>
    <p>è§„èŒƒåŒ–æ£€æŸ¥ã€éªŒè¯è§„åˆ™ã€éªŒè¯æŠ¥å‘Šã€é—®é¢˜ä¿®å¤</p>
  </div>
</div>

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬èŠ‚å­¦ä¹ ï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- **å®ç°ä»£ç è§„èŒƒåŒ–**ï¼šæŒæ¡ä»£ç æ ¼å¼ã€å‘½åè§„èŒƒå’Œæ³¨é‡Šè§„èŒƒ
- **è§„èŒƒå‚æ•°å®šä¹‰**ï¼šç†è§£å‚æ•°ç±»å‹ã€èŒƒå›´å’Œé»˜è®¤å€¼çš„è§„èŒƒåŒ–
- **ç»Ÿä¸€æ¥å£è§„èŒƒ**ï¼šæŒæ¡ç­–ç•¥æ¥å£å’Œè¾“å…¥è¾“å‡ºæ ¼å¼çš„è§„èŒƒåŒ–
- **è§„èŒƒç­–ç•¥ç»“æ„**ï¼šç†è§£ç­–ç•¥æ¨¡æ¿è½¬æ¢å’Œæ¨¡å—åŒ–ç»„ç»‡
- **ç®¡ç†å…ƒæ•°æ®**ï¼šæŒæ¡å…ƒæ•°æ®å®šä¹‰ã€éªŒè¯å’Œè¡¥å……æ–¹æ³•

## ğŸ“š æ ¸å¿ƒæ¦‚å¿µ

### æ¨¡å—å®šä½

- **å·¥ä½œæµä½ç½®**ï¼šæ­¥éª¤6 - ğŸ› ï¸ ç­–ç•¥ç”Ÿæˆï¼ˆç­–ç•¥ä¼˜åŒ–ä¹‹å‰ï¼‰
- **æ ¸å¿ƒèŒè´£**ï¼šä»£ç è§„èŒƒåŒ–ã€å‚æ•°è§„èŒƒåŒ–ã€æ¥å£è§„èŒƒåŒ–ã€å…ƒæ•°æ®è§„èŒƒåŒ–
- **æœåŠ¡å¯¹è±¡**ï¼šç­–ç•¥ä¼˜åŒ–ã€å›æµ‹éªŒè¯

### è®¾è®¡ç†å¿µ

ç­–ç•¥è§„èŒƒåŒ–ç³»ç»Ÿéµå¾ªä»¥ä¸‹è®¾è®¡ç†å¿µï¼š

1. **æ ‡å‡†åŒ–**ï¼šç¡®ä¿æ‰€æœ‰ç­–ç•¥ä»£ç ç¬¦åˆç»Ÿä¸€çš„è§„èŒƒå’Œæ ‡å‡†
2. **å¯ç»´æŠ¤æ€§**ï¼šè§„èŒƒåŒ–åçš„ä»£ç æ˜“äºç†è§£å’Œç»´æŠ¤
3. **ä¸€è‡´æ€§**ï¼šä¸åŒç­–ç•¥ä¹‹é—´ä¿æŒä¸€è‡´çš„ä»£ç é£æ ¼å’Œç»“æ„
4. **è‡ªåŠ¨åŒ–**ï¼šæ”¯æŒè‡ªåŠ¨è§„èŒƒåŒ–ï¼Œå‡å°‘äººå·¥å¹²é¢„
5. **å¯éªŒè¯æ€§**ï¼šè§„èŒƒåŒ–ç»“æœå¯éªŒè¯ï¼Œç¡®ä¿è´¨é‡

<h2 id="section-7-4-1">ğŸ“‹ 7.4.1 ä»£ç è§„èŒƒåŒ–</h2>

ä»£ç è§„èŒƒåŒ–ç¡®ä¿ç­–ç•¥ä»£ç ç¬¦åˆPEP8è§„èŒƒå’Œé¡¹ç›®ä»£ç é£æ ¼ã€‚

### ä»£ç æ ¼å¼è§„èŒƒ

```python
import autopep8
import black
from typing import List, Dict, Any

class CodeFormatter:
    """ä»£ç æ ¼å¼åŒ–å™¨"""
    
    def format_code(
        self,
        code: str,
        style: str = "pep8"
    ) -> str:
        """
        æ ¼å¼åŒ–ä»£ç 
        
        Args:
            code: åŸå§‹ä»£ç 
            style: ä»£ç é£æ ¼ï¼ˆpep8/blackï¼‰
        
        Returns:
            str: æ ¼å¼åŒ–åçš„ä»£ç 
        """
        if style == "pep8":
            return self._format_pep8(code)
        elif style == "black":
            return self._format_black(code)
        else:
            return code
    
    def _format_pep8(self, code: str) -> str:
        """ä½¿ç”¨autopep8æ ¼å¼åŒ–"""
        try:
            formatted = autopep8.fix_code(
                code,
                options={
                    'aggressive': 2,
                    'max_line_length': 100,
                    'ignore': ['E501']  # å¿½ç•¥è¡Œé•¿åº¦é™åˆ¶
                }
            )
            return formatted
        except Exception as e:
            logger.warning(f"PEP8æ ¼å¼åŒ–å¤±è´¥: {e}")
            return code
    
    def _format_black(self, code: str) -> str:
        """ä½¿ç”¨blackæ ¼å¼åŒ–"""
        try:
            formatted = black.format_str(
                code,
                mode=black.FileMode(line_length=100)
            )
            return formatted
        except Exception as e:
            logger.warning(f"Blackæ ¼å¼åŒ–å¤±è´¥: {e}")
            return code
```

### å‘½åè§„èŒƒ

```python
import re
from typing import Dict, List

class NamingStandardizer:
    """å‘½åè§„èŒƒåŒ–å™¨"""
    
    NAMING_RULES = {
        'class': r'^[A-Z][a-zA-Z0-9]*$',  # PascalCase
        'function': r'^[a-z][a-z0-9_]*$',  # snake_case
        'variable': r'^[a-z][a-z0-9_]*$',  # snake_case
        'constant': r'^[A-Z][A-Z0-9_]*$',  # UPPER_SNAKE_CASE
        'private': r'^_[a-z][a-z0-9_]*$'   # _leading_underscore
    }
    
    def standardize_names(self, code: str) -> str:
        """
        è§„èŒƒåŒ–å‘½å
        
        Args:
            code: åŸå§‹ä»£ç 
        
        Returns:
            str: è§„èŒƒåŒ–åçš„ä»£ç 
        """
        # è§£æASTå¹¶è§„èŒƒåŒ–å‘½å
        import ast
        
        try:
            tree = ast.parse(code)
            standardizer = NameStandardizer()
            standardizer.visit(tree)
            return ast.unparse(tree)
        except Exception as e:
            logger.warning(f"å‘½åè§„èŒƒåŒ–å¤±è´¥: {e}")
            return code

class NameStandardizer(ast.NodeTransformer):
    """ASTèŠ‚ç‚¹è½¬æ¢å™¨ï¼Œç”¨äºè§„èŒƒåŒ–å‘½å"""
    
    def visit_FunctionDef(self, node):
        """è§„èŒƒåŒ–å‡½æ•°å"""
        if not re.match(r'^[a-z][a-z0-9_]*$', node.name):
            # è½¬æ¢ä¸ºsnake_case
            node.name = self._to_snake_case(node.name)
        return self.generic_visit(node)
    
    def visit_ClassDef(self, node):
        """è§„èŒƒåŒ–ç±»å"""
        if not re.match(r'^[A-Z][a-zA-Z0-9]*$', node.name):
            # è½¬æ¢ä¸ºPascalCase
            node.name = self._to_pascal_case(node.name)
        return self.generic_visit(node)
    
    def _to_snake_case(self, name: str) -> str:
        """è½¬æ¢ä¸ºsnake_case"""
        # å¤„ç†é©¼å³°å‘½å
        s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
        return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()
    
    def _to_pascal_case(self, name: str) -> str:
        """è½¬æ¢ä¸ºPascalCase"""
        words = name.split('_')
        return ''.join(word.capitalize() for word in words)
```

### æ³¨é‡Šè§„èŒƒ

```python
class CommentStandardizer:
    """æ³¨é‡Šè§„èŒƒåŒ–å™¨"""
    
    def add_docstrings(self, code: str) -> str:
        """
        æ·»åŠ æ–‡æ¡£å­—ç¬¦ä¸²
        
        Args:
            code: åŸå§‹ä»£ç 
        
        Returns:
            str: æ·»åŠ æ–‡æ¡£å­—ç¬¦ä¸²åçš„ä»£ç 
        """
        import ast
        
        try:
            tree = ast.parse(code)
            standardizer = DocstringAdder()
            standardizer.visit(tree)
            return ast.unparse(tree)
        except Exception as e:
            logger.warning(f"æ·»åŠ æ–‡æ¡£å­—ç¬¦ä¸²å¤±è´¥: {e}")
            return code
    
    def standardize_comments(self, code: str) -> str:
        """
        è§„èŒƒåŒ–æ³¨é‡Š
        
        Args:
            code: åŸå§‹ä»£ç 
        
        Returns:
            str: è§„èŒƒåŒ–åçš„ä»£ç 
        """
        lines = code.split('\n')
        standardized = []
        
        for line in lines:
            # è§„èŒƒåŒ–è¡Œå†…æ³¨é‡Š
            if '#' in line and not line.strip().startswith('#'):
                # ç¡®ä¿æ³¨é‡Šå‰æœ‰è‡³å°‘ä¸¤ä¸ªç©ºæ ¼
                parts = line.split('#', 1)
                if len(parts) == 2:
                    code_part = parts[0].rstrip()
                    comment_part = parts[1].strip()
                    if code_part and not code_part.endswith('  '):
                        line = f"{code_part}  # {comment_part}"
            
            standardized.append(line)
        
        return '\n'.join(standardized)

class DocstringAdder(ast.NodeTransformer):
    """æ·»åŠ æ–‡æ¡£å­—ç¬¦ä¸²çš„ASTè½¬æ¢å™¨"""
    
    def visit_FunctionDef(self, node):
        """ä¸ºå‡½æ•°æ·»åŠ æ–‡æ¡£å­—ç¬¦ä¸²"""
        if not ast.get_docstring(node):
            # ç”Ÿæˆé»˜è®¤æ–‡æ¡£å­—ç¬¦ä¸²
            docstring = self._generate_docstring(node)
            node.body.insert(0, ast.Expr(ast.Constant(docstring)))
        return self.generic_visit(node)
    
    def _generate_docstring(self, node: ast.FunctionDef) -> str:
        """ç”Ÿæˆæ–‡æ¡£å­—ç¬¦ä¸²"""
        params = [arg.arg for arg in node.args.args]
        param_docs = '\n'.join([f"        {p}: å‚æ•°è¯´æ˜" for p in params])
        
        return f'''"""
        {node.name}å‡½æ•°è¯´æ˜
        
        Args:
{param_docs}
        
        Returns:
            è¿”å›å€¼è¯´æ˜
        '''.strip()
```

<h2 id="section-7-4-2">âš™ï¸ 7.4.2 å‚æ•°è§„èŒƒåŒ–</h2>

å‚æ•°è§„èŒƒåŒ–ç¡®ä¿ç­–ç•¥å‚æ•°çš„ç±»å‹ã€èŒƒå›´å’Œé»˜è®¤å€¼ç¬¦åˆè§„èŒƒã€‚

### å‚æ•°ç±»å‹è§„èŒƒ

```python
from typing import Type, Any, Dict
from dataclasses import dataclass

@dataclass
class ParameterDefinition:
    """å‚æ•°å®šä¹‰"""
    
    name: str
    type: Type
    default: Any = None
    min_value: Any = None
    max_value: Any = None
    description: str = ""
    required: bool = False

class ParameterStandardizer:
    """å‚æ•°è§„èŒƒåŒ–å™¨"""
    
    def standardize_parameters(
        self,
        code: str,
        parameter_definitions: Dict[str, ParameterDefinition]
    ) -> str:
        """
        è§„èŒƒåŒ–å‚æ•°
        
        Args:
            code: åŸå§‹ä»£ç 
            parameter_definitions: å‚æ•°å®šä¹‰å­—å…¸
        
        Returns:
            str: è§„èŒƒåŒ–åçš„ä»£ç 
        """
        import ast
        
        try:
            tree = ast.parse(code)
            standardizer = ParameterStandardizerVisitor(parameter_definitions)
            standardizer.visit(tree)
            return ast.unparse(tree)
        except Exception as e:
            logger.warning(f"å‚æ•°è§„èŒƒåŒ–å¤±è´¥: {e}")
            return code
    
    def validate_parameters(
        self,
        parameters: Dict[str, Any],
        parameter_definitions: Dict[str, ParameterDefinition]
    ) -> Tuple[bool, List[str]]:
        """
        éªŒè¯å‚æ•°
        
        Args:
            parameters: å‚æ•°å­—å…¸
            parameter_definitions: å‚æ•°å®šä¹‰å­—å…¸
        
        Returns:
            Tuple[bool, List[str]]: (æ˜¯å¦æœ‰æ•ˆ, é”™è¯¯åˆ—è¡¨)
        """
        errors = []
        
        for name, value in parameters.items():
            if name not in parameter_definitions:
                errors.append(f"æœªçŸ¥å‚æ•°: {name}")
                continue
            
            param_def = parameter_definitions[name]
            
            # ç±»å‹æ£€æŸ¥
            if not isinstance(value, param_def.type):
                errors.append(
                    f"å‚æ•° {name} ç±»å‹é”™è¯¯: æœŸæœ› {param_def.type.__name__}, "
                    f"å®é™… {type(value).__name__}"
                )
            
            # èŒƒå›´æ£€æŸ¥
            if isinstance(value, (int, float)):
                if param_def.min_value is not None and value < param_def.min_value:
                    errors.append(
                        f"å‚æ•° {name} å€¼è¿‡å°: {value} < {param_def.min_value}"
                    )
                if param_def.max_value is not None and value > param_def.max_value:
                    errors.append(
                        f"å‚æ•° {name} å€¼è¿‡å¤§: {value} > {param_def.max_value}"
                    )
        
        # æ£€æŸ¥å¿…éœ€å‚æ•°
        for name, param_def in parameter_definitions.items():
            if param_def.required and name not in parameters:
                errors.append(f"ç¼ºå°‘å¿…éœ€å‚æ•°: {name}")
        
        return len(errors) == 0, errors
```

<h2 id="section-7-4-3">ğŸ”Œ 7.4.3 æ¥å£è§„èŒƒåŒ–</h2>

æ¥å£è§„èŒƒåŒ–ç¡®ä¿ç­–ç•¥æ¥å£ç¬¦åˆå¹³å°è§„èŒƒã€‚

### PTradeæ¥å£è§„èŒƒ

```python
class PTRADEInterfaceStandardizer:
    """PTradeæ¥å£è§„èŒƒåŒ–å™¨"""
    
    REQUIRED_FUNCTIONS = {
        'initialize': {
            'signature': 'def initialize(context):',
            'description': 'ç­–ç•¥åˆå§‹åŒ–å‡½æ•°'
        },
        'market_open': {
            'signature': 'def market_open(context):',
            'description': 'å¼€ç›˜å¤„ç†å‡½æ•°'
        }
    }
    
    OPTIONAL_FUNCTIONS = {
        'before_market_open': {
            'signature': 'def before_market_open(context):',
            'description': 'ç›˜å‰å¤„ç†å‡½æ•°'
        },
        'after_market_close': {
            'signature': 'def after_market_close(context):',
            'description': 'ç›˜åå¤„ç†å‡½æ•°'
        }
    }
    
    def standardize_interface(self, code: str) -> str:
        """
        è§„èŒƒåŒ–PTradeæ¥å£
        
        Args:
            code: åŸå§‹ä»£ç 
        
        Returns:
            str: è§„èŒƒåŒ–åçš„ä»£ç 
        """
        import ast
        
        try:
            tree = ast.parse(code)
            standardizer = InterfaceStandardizerVisitor('ptrade')
            standardizer.visit(tree)
            return ast.unparse(tree)
        except Exception as e:
            logger.warning(f"æ¥å£è§„èŒƒåŒ–å¤±è´¥: {e}")
            return code
    
    def validate_interface(self, code: str) -> Tuple[bool, List[str]]:
        """
        éªŒè¯æ¥å£
        
        Args:
            code: ç­–ç•¥ä»£ç 
        
        Returns:
            Tuple[bool, List[str]]: (æ˜¯å¦æœ‰æ•ˆ, é”™è¯¯åˆ—è¡¨)
        """
        import ast
        
        errors = []
        
        try:
            tree = ast.parse(code)
            function_names = {
                node.name for node in ast.walk(tree)
                if isinstance(node, ast.FunctionDef)
            }
            
            # æ£€æŸ¥å¿…éœ€å‡½æ•°
            for func_name in self.REQUIRED_FUNCTIONS.keys():
                if func_name not in function_names:
                    errors.append(f"ç¼ºå°‘å¿…éœ€å‡½æ•°: {func_name}")
            
            return len(errors) == 0, errors
        except Exception as e:
            return False, [f"ä»£ç è§£æå¤±è´¥: {e}"]
```

<h2 id="section-7-4-4">ğŸ—ï¸ 7.4.4 ç»“æ„è§„èŒƒåŒ–</h2>

ç»“æ„è§„èŒƒåŒ–ç¡®ä¿ç­–ç•¥ä»£ç ç»“æ„ç¬¦åˆæ ‡å‡†æ¨¡æ¿æ ¼å¼ã€‚

### ç­–ç•¥ç»“æ„æ ‡å‡†

```python
STRATEGY_STRUCTURE = {
    'header': 'æ–‡ä»¶å¤´éƒ¨ï¼ˆç¼–ç ã€æ–‡æ¡£å­—ç¬¦ä¸²ï¼‰',
    'imports': 'å¯¼å…¥è¯­å¥',
    'parameters': 'ç­–ç•¥å‚æ•°å®šä¹‰',
    'initialize': 'åˆå§‹åŒ–å‡½æ•°',
    'before_market_open': 'ç›˜å‰å¤„ç†å‡½æ•°ï¼ˆå¯é€‰ï¼‰',
    'market_open': 'å¼€ç›˜å¤„ç†å‡½æ•°',
    'after_market_close': 'ç›˜åå¤„ç†å‡½æ•°ï¼ˆå¯é€‰ï¼‰',
    'helper_functions': 'è¾…åŠ©å‡½æ•°',
    'risk_control': 'é£é™©æ§åˆ¶å‡½æ•°'
}

class StructureStandardizer:
    """ç»“æ„è§„èŒƒåŒ–å™¨"""
    
    def standardize_structure(
        self,
        code: str,
        template: StrategyTemplate = None
    ) -> str:
        """
        è§„èŒƒåŒ–ç­–ç•¥ç»“æ„
        
        Args:
            code: åŸå§‹ä»£ç 
            template: ç­–ç•¥æ¨¡æ¿ï¼ˆå¯é€‰ï¼‰
        
        Returns:
            str: è§„èŒƒåŒ–åçš„ä»£ç 
        """
        # 1. è§£æä»£ç ç»“æ„
        structure = self._parse_structure(code)
        
        # 2. æ£€æŸ¥ç¼ºå¤±éƒ¨åˆ†
        missing = self._check_missing_parts(structure)
        
        # 3. è¡¥å……ç¼ºå¤±éƒ¨åˆ†
        if missing:
            code = self._add_missing_parts(code, missing, template)
        
        # 4. é‡æ–°ç»„ç»‡ä»£ç ç»“æ„
        code = self._reorganize_structure(code, template)
        
        return code
    
    def _parse_structure(self, code: str) -> Dict[str, Any]:
        """è§£æä»£ç ç»“æ„"""
        import ast
        
        structure = {
            'header': '',
            'imports': [],
            'parameters': [],
            'functions': {},
            'classes': {}
        }
        
        try:
            tree = ast.parse(code)
            
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    structure['functions'][node.name] = {
                        'line_start': node.lineno,
                        'line_end': node.end_lineno,
                        'args': [arg.arg for arg in node.args.args]
                    }
                elif isinstance(node, ast.ClassDef):
                    structure['classes'][node.name] = {
                        'line_start': node.lineno,
                        'line_end': node.end_lineno
                    }
            
            return structure
        except Exception as e:
            logger.warning(f"è§£æä»£ç ç»“æ„å¤±è´¥: {e}")
            return structure
```

<h2 id="section-7-4-5">ğŸ“Š 7.4.5 å…ƒæ•°æ®è§„èŒƒåŒ–</h2>

å…ƒæ•°æ®è§„èŒƒåŒ–ç¡®ä¿ç­–ç•¥å…ƒæ•°æ®å®Œæ•´ä¸”ç¬¦åˆè§„èŒƒã€‚

### å…ƒæ•°æ®å®šä¹‰

```python
@dataclass
class StrategyMetadata:
    """ç­–ç•¥å…ƒæ•°æ®å®šä¹‰"""
    
    name: str
    description: str = ""
    author: str = ""
    version: str = "1.0.0"
    platform: str = "ptrade"
    strategy_type: str = ""
    factors: List[str] = field(default_factory=list)
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())
    updated_at: str = field(default_factory=lambda: datetime.now().isoformat())
    tags: List[str] = field(default_factory=list)
    research_card_refs: List[str] = field(default_factory=list)
    rule_refs: List[str] = field(default_factory=list)

class MetadataStandardizer:
    """å…ƒæ•°æ®è§„èŒƒåŒ–å™¨"""
    
    def extract_metadata(self, code: str) -> StrategyMetadata:
        """
        ä»ä»£ç ä¸­æå–å…ƒæ•°æ®
        
        Args:
            code: ç­–ç•¥ä»£ç 
        
        Returns:
            StrategyMetadata: æå–çš„å…ƒæ•°æ®
        """
        metadata = StrategyMetadata(name="æœªå‘½åç­–ç•¥")
        
        # ä»æ–‡æ¡£å­—ç¬¦ä¸²æå–
        docstring = self._extract_docstring(code)
        if docstring:
            metadata.description = self._parse_description(docstring)
            metadata.author = self._parse_author(docstring)
        
        # ä»ä»£ç ä¸­æå–å‚æ•°
        metadata.parameters = self._extract_parameters(code)
        
        # ä»ä»£ç ä¸­æå–å› å­
        metadata.factors = self._extract_factors(code)
        
        return metadata
    
    def validate_metadata(
        self,
        metadata: StrategyMetadata
    ) -> Tuple[bool, List[str]]:
        """
        éªŒè¯å…ƒæ•°æ®
        
        Args:
            metadata: ç­–ç•¥å…ƒæ•°æ®
        
        Returns:
            Tuple[bool, List[str]]: (æ˜¯å¦æœ‰æ•ˆ, é”™è¯¯åˆ—è¡¨)
        """
        errors = []
        
        # æ£€æŸ¥å¿…éœ€å­—æ®µ
        if not metadata.name:
            errors.append("ç­–ç•¥åç§°ä¸èƒ½ä¸ºç©º")
        
        if not metadata.description:
            errors.append("ç­–ç•¥æè¿°ä¸èƒ½ä¸ºç©º")
        
        if not metadata.platform:
            errors.append("å¹³å°ç±»å‹ä¸èƒ½ä¸ºç©º")
        
        # éªŒè¯ç‰ˆæœ¬å·æ ¼å¼
        if not re.match(r'^\d+\.\d+\.\d+$', metadata.version):
            errors.append(f"ç‰ˆæœ¬å·æ ¼å¼é”™è¯¯: {metadata.version}")
        
        return len(errors) == 0, errors
```

<h2 id="section-7-4-6">âœ… 7.4.6 è§„èŒƒåŒ–éªŒè¯</h2>

è§„èŒƒåŒ–éªŒè¯ç¡®ä¿è§„èŒƒåŒ–åçš„ç­–ç•¥ä»£ç ç¬¦åˆæ‰€æœ‰è§„èŒƒè¦æ±‚ã€‚

### ç»¼åˆéªŒè¯å™¨

```python
class StandardizationValidator:
    """è§„èŒƒåŒ–éªŒè¯å™¨"""
    
    def __init__(self):
        self.code_formatter = CodeFormatter()
        self.naming_standardizer = NamingStandardizer()
        self.parameter_standardizer = ParameterStandardizer()
        self.interface_validator = PTRADEInterfaceStandardizer()
        self.metadata_validator = MetadataStandardizer()
    
    def validate(
        self,
        code: str,
        metadata: StrategyMetadata = None
    ) -> Dict[str, Any]:
        """
        ç»¼åˆéªŒè¯
        
        Args:
            code: ç­–ç•¥ä»£ç 
            metadata: ç­–ç•¥å…ƒæ•°æ®ï¼ˆå¯é€‰ï¼‰
        
        Returns:
            Dict: éªŒè¯ç»“æœ
        """
        result = {
            'valid': True,
            'errors': [],
            'warnings': [],
            'checks': {}
        }
        
        # 1. ä»£ç æ ¼å¼æ£€æŸ¥
        format_valid, format_errors = self._check_code_format(code)
        result['checks']['code_format'] = format_valid
        if not format_valid:
            result['errors'].extend(format_errors)
        
        # 2. å‘½åè§„èŒƒæ£€æŸ¥
        naming_valid, naming_errors = self._check_naming(code)
        result['checks']['naming'] = naming_valid
        if not naming_valid:
            result['warnings'].extend(naming_errors)
        
        # 3. æ¥å£æ£€æŸ¥
        interface_valid, interface_errors = self.interface_validator.validate_interface(code)
        result['checks']['interface'] = interface_valid
        if not interface_valid:
            result['errors'].extend(interface_errors)
        
        # 4. å…ƒæ•°æ®æ£€æŸ¥
        if metadata:
            metadata_valid, metadata_errors = self.metadata_validator.validate_metadata(metadata)
            result['checks']['metadata'] = metadata_valid
            if not metadata_valid:
                result['errors'].extend(metadata_errors)
        
        result['valid'] = len(result['errors']) == 0
        
        return result
    
    def _check_code_format(self, code: str) -> Tuple[bool, List[str]]:
        """æ£€æŸ¥ä»£ç æ ¼å¼"""
        errors = []
        
        # æ£€æŸ¥ç¼©è¿›
        lines = code.split('\n')
        for i, line in enumerate(lines, 1):
            if line.strip() and not line.startswith('#'):
                # æ£€æŸ¥æ˜¯å¦ä½¿ç”¨4ä¸ªç©ºæ ¼ç¼©è¿›
                if line.startswith('\t'):
                    errors.append(f"ç¬¬{i}è¡Œ: ä½¿ç”¨äº†Tabç¼©è¿›ï¼Œåº”ä½¿ç”¨4ä¸ªç©ºæ ¼")
        
        return len(errors) == 0, errors
    
    def _check_naming(self, code: str) -> Tuple[bool, List[str]]:
        """æ£€æŸ¥å‘½åè§„èŒƒ"""
        warnings = []
        
        import ast
        try:
            tree = ast.parse(code)
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    if not re.match(r'^[a-z][a-z0-9_]*$', node.name):
                        warnings.append(
                            f"å‡½æ•°å '{node.name}' ä¸ç¬¦åˆsnake_caseè§„èŒƒ"
                        )
                elif isinstance(node, ast.ClassDef):
                    if not re.match(r'^[A-Z][a-zA-Z0-9]*$', node.name):
                        warnings.append(
                            f"ç±»å '{node.name}' ä¸ç¬¦åˆPascalCaseè§„èŒƒ"
                        )
        except Exception as e:
            warnings.append(f"å‘½åæ£€æŸ¥å¤±è´¥: {e}")
        
        return len(warnings) == 0, warnings
```

### è§„èŒƒåŒ–æŠ¥å‘Šç”Ÿæˆ

```python
class StandardizationReportGenerator:
    """è§„èŒƒåŒ–æŠ¥å‘Šç”Ÿæˆå™¨"""
    
    def generate_report(
        self,
        validation_result: Dict[str, Any],
        before_code: str,
        after_code: str
    ) -> str:
        """
        ç”Ÿæˆè§„èŒƒåŒ–æŠ¥å‘Š
        
        Args:
            validation_result: éªŒè¯ç»“æœ
            before_code: è§„èŒƒåŒ–å‰çš„ä»£ç 
            after_code: è§„èŒƒåŒ–åçš„ä»£ç 
        """
        report = []
        report.append("=" * 60)
        report.append("ç­–ç•¥è§„èŒƒåŒ–æŠ¥å‘Š")
        report.append("=" * 60)
        report.append("")
        
        # éªŒè¯ç»“æœ
        report.append("## éªŒè¯ç»“æœ")
        report.append(f"- æ€»ä½“çŠ¶æ€: {'âœ… é€šè¿‡' if validation_result['valid'] else 'âŒ å¤±è´¥'}")
        report.append("")
        
        # æ£€æŸ¥é¡¹
        report.append("## æ£€æŸ¥é¡¹")
        for check_name, check_result in validation_result['checks'].items():
            status = "âœ…" if check_result else "âŒ"
            report.append(f"- {check_name}: {status}")
        report.append("")
        
        # é”™è¯¯åˆ—è¡¨
        if validation_result['errors']:
            report.append("## é”™è¯¯åˆ—è¡¨")
            for error in validation_result['errors']:
                report.append(f"- âŒ {error}")
            report.append("")
        
        # è­¦å‘Šåˆ—è¡¨
        if validation_result['warnings']:
            report.append("## è­¦å‘Šåˆ—è¡¨")
            for warning in validation_result['warnings']:
                report.append(f"- âš ï¸ {warning}")
            report.append("")
        
        # ä»£ç å·®å¼‚
        if before_code != after_code:
            report.append("## ä»£ç å˜æ›´")
            report.append("ä»£ç å·²è§„èŒƒåŒ–ï¼Œä¸»è¦å˜æ›´ï¼š")
            # å¯ä»¥æ·»åŠ diffä¿¡æ¯
        
        return "\n".join(report)
```

## ğŸ”— ç›¸å…³ç« èŠ‚

- **7.1 ç­–ç•¥æ¨¡æ¿**ï¼šäº†è§£ç­–ç•¥æ¨¡æ¿ï¼Œä¸ºç»“æ„è§„èŒƒåŒ–æä¾›æ¨¡æ¿
- **7.2 ç­–ç•¥ç”Ÿæˆ**ï¼šäº†è§£ç­–ç•¥ç”Ÿæˆï¼Œè§„èŒƒåŒ–åŸºäºç”Ÿæˆçš„ç­–ç•¥è¿›è¡Œ
- **7.3 ç­–ç•¥ä¼˜åŒ–**ï¼šäº†è§£ç­–ç•¥ä¼˜åŒ–ï¼Œè§„èŒƒåŒ–åçš„ç­–ç•¥ç”¨äºä¼˜åŒ–
- **ç¬¬10ç« ï¼šå¼€å‘æŒ‡å—**ï¼šäº†è§£å¼€å‘è§„èŒƒï¼Œè§„èŒƒåŒ–éµå¾ªå¼€å‘è§„èŒƒ

## ğŸ’¡ å…³é”®è¦ç‚¹

1. **æ ‡å‡†åŒ–**ï¼šç¡®ä¿æ‰€æœ‰ç­–ç•¥ä»£ç ç¬¦åˆç»Ÿä¸€çš„è§„èŒƒå’Œæ ‡å‡†
2. **å¯ç»´æŠ¤æ€§**ï¼šè§„èŒƒåŒ–åçš„ä»£ç æ˜“äºç†è§£å’Œç»´æŠ¤
3. **ä¸€è‡´æ€§**ï¼šä¸åŒç­–ç•¥ä¹‹é—´ä¿æŒä¸€è‡´çš„ä»£ç é£æ ¼å’Œç»“æ„
4. **è‡ªåŠ¨åŒ–**ï¼šæ”¯æŒè‡ªåŠ¨è§„èŒƒåŒ–ï¼Œå‡å°‘äººå·¥å¹²é¢„
5. **å¯éªŒè¯æ€§**ï¼šè§„èŒƒåŒ–ç»“æœå¯éªŒè¯ï¼Œç¡®ä¿è´¨é‡

## ğŸ”® æ€»ç»“ä¸å±•æœ›

<div class="summary-outlook">
  <h3>æœ¬èŠ‚å›é¡¾</h3>
  <p>æœ¬èŠ‚ç³»ç»Ÿä»‹ç»äº†TRQuantç³»ç»Ÿçš„ç­–ç•¥è§„èŒƒåŒ–ç³»ç»Ÿï¼Œåœ¨ç­–ç•¥ä¼˜åŒ–ä¹‹å‰å¯¹ç­–ç•¥è¿›è¡Œæ ‡å‡†åŒ–å¤„ç†ï¼Œç¡®ä¿ç­–ç•¥ç¬¦åˆç³»ç»Ÿè§„èŒƒã€‚é€šè¿‡ç†è§£ä»£ç è§„èŒƒåŒ–ã€å‚æ•°è§„èŒƒåŒ–ã€æ¥å£è§„èŒƒåŒ–å’Œå…ƒæ•°æ®è§„èŒƒåŒ–ï¼Œå¸®åŠ©å¼€å‘è€…æŒæ¡å¦‚ä½•ç¡®ä¿ç”Ÿæˆçš„ç­–ç•¥ä»£ç ç¬¦åˆè§„èŒƒï¼Œä¸ºç­–ç•¥ä¼˜åŒ–å’Œå›æµ‹éªŒè¯æä¾›æ ‡å‡†åŒ–çš„ç­–ç•¥ä»£ç ã€‚</p>
  
  <h3>ä¸‹èŠ‚é¢„å‘Š</h3>
  <p>æŒæ¡äº†ç­–ç•¥è§„èŒƒåŒ–åï¼Œä¸‹ä¸€èŠ‚å°†ä»‹ç»ç­–ç•¥æµ‹è¯•ï¼ŒåŒ…æ‹¬å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•å’Œå›æµ‹éªŒè¯ã€‚é€šè¿‡ç†è§£ç­–ç•¥æµ‹è¯•çš„æ ¸å¿ƒæŠ€æœ¯ï¼Œå¸®åŠ©å¼€å‘è€…æŒæ¡å¦‚ä½•éªŒè¯ç­–ç•¥çš„æ­£ç¡®æ€§å’Œæ€§èƒ½ã€‚</p>
  
  <a href="/ashare-book6/007_Chapter7_Strategy_Development/7.5_Strategy_Testing_CN" class="next-section">
    ç»§ç»­å­¦ä¹ ï¼š7.5 ç­–ç•¥æµ‹è¯• â†’
  </a>
</div>

> **é€‚ç”¨ç‰ˆæœ¬**: v1.0.0+  
> **æœ€åæ›´æ–°**: 2025-12-12

