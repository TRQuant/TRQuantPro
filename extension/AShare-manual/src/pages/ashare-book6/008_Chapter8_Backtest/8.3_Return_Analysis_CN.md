---
title: "8.3 æ”¶ç›Šåˆ†æ"
description: "æ·±å…¥è§£ææ”¶ç›Šåˆ†æç³»ç»Ÿï¼ŒåŒ…æ‹¬æ€»æ”¶ç›Šã€å¹´åŒ–æ”¶ç›Šã€è¶…é¢æ”¶ç›Šã€æ”¶ç›Šåˆ†è§£ç­‰æ ¸å¿ƒæŠ€æœ¯"
lang: "zh-CN"
layout: "/src/layouts/HandbookLayout.astro"
currentBook: "ashare-book6"
updateDate: "2025-12-12"
---

# ğŸ’° 8.3 æ”¶ç›Šåˆ†æ

> **æ ¸å¿ƒæ‘˜è¦ï¼š**
> 
> æœ¬èŠ‚è¯¦ç»†ä»‹ç»TRQuantç³»ç»Ÿçš„æ”¶ç›Šåˆ†æåŠŸèƒ½ï¼ŒåŸºäºBulletTradeå›æµ‹ç»“æœè¿›è¡Œå…¨é¢çš„æ”¶ç›Šè¯„ä¼°ã€‚åŒ…æ‹¬æ€»æ”¶ç›Šã€å¹´åŒ–æ”¶ç›Šã€è¶…é¢æ”¶ç›Šã€æ”¶ç›Šåˆ†è§£ã€æ”¶ç›Šç¨³å®šæ€§ç­‰å¤šä¸ªç»´åº¦çš„åˆ†æã€‚é€šè¿‡ç†è§£æ”¶ç›Šåˆ†æçš„æ ¸å¿ƒæŠ€æœ¯ï¼Œå¸®åŠ©å¼€å‘è€…å…¨é¢è¯„ä¼°ç­–ç•¥çš„æ”¶ç›Šè¡¨ç°ï¼Œè¯†åˆ«æ”¶ç›Šæ¥æºå’Œæ”¶ç›Šç‰¹å¾ã€‚

æ”¶ç›Šåˆ†ææ˜¯å›æµ‹åˆ†æçš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œè´Ÿè´£å…¨é¢è¯„ä¼°ç­–ç•¥çš„æ”¶ç›Šè¡¨ç°ï¼Œä»BulletTradeå›æµ‹ç»“æœä¸­æå–æ”¶ç›Šæ•°æ®ï¼Œè¿›è¡Œå¤šç»´åº¦åˆ†æã€‚

## ğŸ“‹ ç« èŠ‚æ¦‚è§ˆ

<script>
function scrollToSection(sectionId) {
  const element = document.getElementById(sectionId);
  if (element) {
    const headerOffset = 100;
    const elementPosition = element.getBoundingClientRect().top;
    const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
    window.scrollTo({
      top: offsetPosition,
      behavior: 'smooth'
    });
  }
}
</script>

<div class="section-overview">
  <div class="section-item" onclick="scrollToSection('section-8-3-1')">
    <h4>ğŸ“Š 8.3.1 æ€»æ”¶ç›Šåˆ†æ</h4>
    <p>æ€»æ”¶ç›Šç‡è®¡ç®—ã€æ”¶ç›Šæ›²çº¿ã€æ”¶ç›Šåˆ†å¸ƒã€æ”¶ç›Šç»Ÿè®¡</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-8-3-2')">
    <h4>ğŸ“ˆ 8.3.2 å¹´åŒ–æ”¶ç›Šåˆ†æ</h4>
    <p>å¹´åŒ–æ”¶ç›Šç‡è®¡ç®—ã€å¤åˆ©æ•ˆåº”ã€æ—¶é—´åŠ æƒæ”¶ç›Šã€å¹´åŒ–æ”¶ç›Šåˆ†è§£</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-8-3-3')">
    <h4>ğŸ¯ 8.3.3 è¶…é¢æ”¶ç›Šåˆ†æ</h4>
    <p>è¶…é¢æ”¶ç›Šè®¡ç®—ã€ç›¸å¯¹åŸºå‡†è¡¨ç°ã€ä¿¡æ¯æ¯”ç‡ã€è·Ÿè¸ªè¯¯å·®</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-8-3-4')">
    <h4>ğŸ” 8.3.4 æ”¶ç›Šåˆ†è§£</h4>
    <p>æ”¶ç›Šæ¥æºåˆ†è§£ã€è¡Œä¸šè´¡çŒ®ã€ä¸ªè‚¡è´¡çŒ®ã€æ—¶é—´ç»´åº¦åˆ†è§£</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-8-3-5')">
    <h4>ğŸ“… 8.3.5 æ”¶ç›Šç¨³å®šæ€§åˆ†æ</h4>
    <p>æœˆåº¦æ”¶ç›Šç¨³å®šæ€§ã€å­£åº¦æ”¶ç›Šç¨³å®šæ€§ã€æ”¶ç›Šæ³¢åŠ¨æ€§ã€æ”¶ç›ŠæŒç»­æ€§</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-8-3-6')">
    <h4>ğŸ“Š 8.3.6 æ”¶ç›Šå¯è§†åŒ–</h4>
    <p>æ”¶ç›Šæ›²çº¿å›¾ã€æ”¶ç›Šåˆ†å¸ƒå›¾ã€æ”¶ç›Šçƒ­åŠ›å›¾ã€æ”¶ç›Šå¯¹æ¯”å›¾</p>
  </div>
</div>

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬èŠ‚å­¦ä¹ ï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- **è®¡ç®—æ€»æ”¶ç›Š**ï¼šæŒæ¡æ€»æ”¶ç›Šç‡çš„è®¡ç®—æ–¹æ³•å’Œæ”¶ç›Šæ›²çº¿åˆ†æ
- **è®¡ç®—å¹´åŒ–æ”¶ç›Š**ï¼šç†è§£å¹´åŒ–æ”¶ç›Šç‡çš„è®¡ç®—å’Œå¤åˆ©æ•ˆåº”
- **åˆ†æè¶…é¢æ”¶ç›Š**ï¼šæŒæ¡è¶…é¢æ”¶ç›Šçš„è®¡ç®—å’Œç›¸å¯¹åŸºå‡†è¡¨ç°åˆ†æ
- **åˆ†è§£æ”¶ç›Šæ¥æº**ï¼šç†è§£æ”¶ç›Šåˆ†è§£æ–¹æ³•å’Œæ”¶ç›Šæ¥æºè¯†åˆ«
- **è¯„ä¼°æ”¶ç›Šç¨³å®šæ€§**ï¼šæŒæ¡æ”¶ç›Šç¨³å®šæ€§çš„è¯„ä¼°æ–¹æ³•å’ŒæŒ‡æ ‡
- **å¯è§†åŒ–æ”¶ç›Š**ï¼šç†è§£æ”¶ç›Šå¯è§†åŒ–çš„æ–¹æ³•å’Œå›¾è¡¨ç±»å‹

## ğŸ“š æ ¸å¿ƒæ¦‚å¿µ

### æ¨¡å—å®šä½

- **å·¥ä½œæµä½ç½®**ï¼šæ­¥éª¤7 - ğŸ”„ å›æµ‹éªŒè¯ï¼ˆå›æµ‹åˆ†æå™¨ä¹‹åï¼‰
- **æ ¸å¿ƒèŒè´£**ï¼šæ€»æ”¶ç›Šåˆ†æã€å¹´åŒ–æ”¶ç›Šåˆ†æã€è¶…é¢æ”¶ç›Šåˆ†æã€æ”¶ç›Šåˆ†è§£ã€æ”¶ç›Šç¨³å®šæ€§åˆ†æ
- **æœåŠ¡å¯¹è±¡**ï¼šç­–ç•¥ä¼˜åŒ–ã€å›æµ‹æŠ¥å‘Šã€æŠ•èµ„å†³ç­–
- **æ•°æ®æ¥æº**ï¼šBulletTradeå›æµ‹ç»“æœï¼ˆå‡€å€¼æ›²çº¿ã€åŸºå‡†æ›²çº¿ï¼‰

### æŠ€æœ¯æ ˆ

æ”¶ç›Šåˆ†æåŸºäºä»¥ä¸‹æŠ€æœ¯ï¼š

1. **æ•°æ®æå–**ï¼šä»BulletTradeå›æµ‹ç»“æœä¸­æå–å‡€å€¼æ›²çº¿å’ŒåŸºå‡†æ›²çº¿
2. **æ”¶ç›Šè®¡ç®—**ï¼šä½¿ç”¨Pandaså’ŒNumPyè¿›è¡Œæ”¶ç›Šè®¡ç®—å’Œç»Ÿè®¡åˆ†æ
3. **æ”¶ç›Šåˆ†è§£**ï¼šä½¿ç”¨åˆ†ç»„å’Œèšåˆæ–¹æ³•è¿›è¡Œæ”¶ç›Šæ¥æºåˆ†è§£
4. **å¯è§†åŒ–**ï¼šä½¿ç”¨Matplotlibå’ŒPlotlyç”Ÿæˆæ”¶ç›Šåˆ†æå›¾è¡¨

<h2 id="section-8-3-1">ğŸ“Š 8.3.1 æ€»æ”¶ç›Šåˆ†æ</h2>

æ€»æ”¶ç›Šåˆ†æè¯„ä¼°ç­–ç•¥åœ¨æ•´ä¸ªå›æµ‹æœŸé—´çš„ç´¯è®¡æ”¶ç›Šè¡¨ç°ã€‚

### ä»BulletTradeç»“æœæå–å‡€å€¼æ›²çº¿

<CodeFromFile 
  filePath="code_library/008_Chapter8_Backtest/8.3/code_8_3_ä»BulletTradeç»“æœæå–å‡€å€¼æ›²çº¿.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
from core.bullettrade import BulletTradeEngine, BTConfig

# æ‰§è¡ŒBulletTradeå›æµ‹
bt_engine = BulletTradeEngine(config)
bt_result = bt_engine.run_backtest(strategy_path, start_date, end_date)

# æå–å‡€å€¼æ›²çº¿
equi<CodeFromFile 
  filePath="code_library/008_Chapter8_Backtest/8.3/code_8_3_analyze_total_return.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
import pandas as pd
import numpy as np
from typing import Dict, Any

class TotalReturnAnalyzer:
    """æ€»æ”¶ç›Šåˆ†æå™¨"""
    
    def analyze_total_return(
        self,
        equity_curve: pd.DataFrame
    ) -> Dict[str, Any]:
        """
        åˆ†ææ€»æ”¶ç›Š
        
        Args:
            equity_curve: å‡€å€¼æ›²çº¿ï¼ˆåŒ…å«dateå’Œequityåˆ—ï¼‰
        
        Returns:
            Dict: æ€»æ”¶ç›Šåˆ†æç»“æœ
        """
        equity_curve = equity_curve.sort_values('date')
        
        # åˆå§‹å’Œæœ€ç»ˆå‡€å€¼
        initial_equity = equity_curve['equity'].iloc[0]
        final_equity = equity_curve['equity'].iloc[-1]
        
        # æ€»æ”¶ç›Šç‡
        total_return = (final_equity / initial_equity) - 1
        
        # æ”¶ç›Šæ›²çº¿ï¼ˆç›¸å¯¹äºåˆå§‹å‡€å€¼ï¼‰
        equity_curve['return_curve'] = (equity_curve['equity'] / initial_equity) - 1
        
        # æ—¥æ”¶ç›Šç‡
        equity_curve['daily_return'] = equity_curve['equity'].pct_change()
        
        # æ”¶ç›Šç»Ÿè®¡
        daily_returns = equity_curve['daily_return'].dropna()
        return_stats = {
            'mean': daily_returns.mean(),
            'std': daily_returns.std(),
            'min': daily_returns.min(),
            'max': daily_returns.max(),
            'median': daily_returns.median(),
            'skewness': daily_returns.skew(),
            'kurtosis': daily_returns.kurtosis()
        }
        
        # æ”¶ç›Šåˆ†å¸ƒ
        return_distribution = self._analyze_return_distribution(daily_returns)
        
        # æœ€å¤§å•æ—¥æ”¶ç›Šå’Œæœ€å¤§å•æ—¥äºæŸ
        max_daily_gain = daily_returns.max()
        max_daily_loss = daily_returns.min()
        
        # æ”¶ç›Šä¸ºæ­£çš„å¤©æ•°å æ¯”
        positive_days_ratio = (daily_returns > 0).sum() / len(daily_returns)
        
        return {
            'initial_equity': initial_equity,
            'final_equity': final_equity,
            'total_return': total_return,
            'return_curve': equity_curve[['date', 'return_curve']],
            'return_stats': return_stats,
            'return_distribution': return_distribution,
            'max_daily_gain': max_daily_gain,
            'max_daily_loss': max_daily_loss,
            'positive_days_ratio': positive_days_ratio,
            'total_days': len(equity_curve)
        }
    
    def _analyze_return_distribution(self, returns: pd.Series) -> Dict[str, Any]:
        """åˆ†ææ”¶ç›Šåˆ†å¸ƒ"""
        return {
            'positive_count': (returns > 0).sum(),
            'negative_count': (returns < 0).sum(),
            'zero_count': (returns == 0).sum(),
            'positive_ratio': (returns > 0).sum() / len(returns),
            'negative_ratio': (returns < 0).sum() / len(returns),
            'bins': {
                '>5%': (returns > 0.05).sum(),
                '2%-5%': ((returns > 0.02) & (returns <= 0.05)).sum(),
                '0-2%': ((returns > 0) & (returns <= 0.02)).sum(),
                '-2%-0': ((returns >= -0.02) & (returns < <CodeFromFile 
  filePath="code_library/008_Chapter8_Backtest/8.3/code_8_3_ä½¿ç”¨ç¤ºä¾‹.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
# åˆ†ææ€»æ”¶ç›Š
analyzer = TotalReturnAnalyzer()
result = analyzer.analyze_total_return(bt_result.equity_curve)

print(f"åˆå§‹å‡€å€¼: {result['initial_equity']:,.2f}")
print(f"æœ€ç»ˆå‡€å€¼: {result['final_equity']:,.2f}")
print(f"æ€»æ”¶ç›Šç‡: {result['total_return']:.2%}")
print(f"æœ€å¤§å•æ—¥æ”¶ç›Š: {result['max_daily_gain']:.2%}")
print(f"æœ€å¤§å•æ—¥äºæŸ: {result['max_daily_loss']:.<CodeFromFile 
  filePath="code_library/008_Chapter8_Backtest/8.3/code_8_3_analyze_annual_return.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
class AnnualReturnAnalyzer:
    """å¹´åŒ–æ”¶ç›Šåˆ†æå™¨"""
    
    def analyze_annual_return(
        self,
        equity_curve: pd.DataFrame
    ) -> Dict[str, Any]:
        """
        åˆ†æå¹´åŒ–æ”¶ç›Š
        
        Args:
            equity_curve: å‡€å€¼æ›²çº¿
        
        Returns:
            Dict: å¹´åŒ–æ”¶ç›Šåˆ†æç»“æœ
        """
        equity_curve = equity_curve.sort_values('date')
        
        # è®¡ç®—æ€»æ”¶ç›Š
        initial_equity = equity_curve['equity'].iloc[0]
        final_equity = equity_curve['equity'].iloc[-1]
        total_return = (final_equity / initial_equity) - 1
        
        # è®¡ç®—æ—¶é—´è·¨åº¦
        start_date = pd.to_datetime(equity_curve['date'].iloc[0])
        end_date = pd.to_datetime(equity_curve['date'].iloc[-1])
        days = (end_date - start_date).days
        years = days / 365.25
        
        # è®¾è®¡åŸç†ï¼šå¹´åŒ–æ”¶ç›Šç‡ï¼ˆå¤åˆ©è®¡ç®—ï¼‰
        # åŸå› ï¼šå¤åˆ©è®¡ç®—æ›´å‡†ç¡®åæ˜ å®é™…æ”¶ç›Šï¼Œè€ƒè™‘äº†æ”¶ç›Šå†æŠ•èµ„
        # å…¬å¼ï¼šå¹´åŒ–æ”¶ç›Šç‡ = (1 + æ€»æ”¶ç›Šç‡)^(1/å¹´æ•°) - 1
        # é€‚ç”¨åœºæ™¯ï¼šé•¿æœŸæŠ•èµ„ç­–ç•¥ï¼Œæ”¶ç›Šä¼šå†æŠ•èµ„
        annual_return = (1 + total_return) ** (1 / years) - 1 if years > 0 else 0
        
        # è®¾è®¡åŸç†ï¼šå¹´åŒ–æ”¶ç›Šç‡ï¼ˆç®€å•è®¡ç®—ï¼‰
        # åŸå› ï¼šç®€å•è®¡ç®—ä¾¿äºç†è§£ï¼Œä½†ä¸è€ƒè™‘å¤åˆ©æ•ˆåº”
        # å…¬å¼ï¼šå¹´åŒ–æ”¶ç›Šç‡ = æ€»æ”¶ç›Šç‡ / å¹´æ•°
        # é€‚ç”¨åœºæ™¯ï¼šçŸ­æœŸç­–ç•¥æˆ–ç²—ç•¥ä¼°ç®—
        annual_return_simple = total_return / years if years > 0 else 0
        
        # è®¾è®¡åŸç†ï¼šæœˆåº¦æ”¶ç›Šç‡è®¡ç®—
        # åŸå› ï¼šæœˆåº¦æ”¶ç›Šæä¾›æ›´ç»†ç²’åº¦çš„æ”¶ç›Šåˆ†æ
        # å®ç°æ–¹å¼ï¼šæŒ‰å¹´æœˆåˆ†ç»„ï¼Œå–æ¯æœˆæœ€åä¸€å¤©çš„å‡€å€¼ï¼Œè®¡ç®—æœˆåº¦æ”¶ç›Šç‡
        equity_curve['year_month'] = pd.to_datetime(equity_curve['date']).dt.to_period('M')
        monthly_equity = equity_curve.groupby('year_month')['equity'].last()
        monthly_returns = monthly_equity.pct_change().dropna()
        
        # è®¾è®¡åŸç†ï¼šæœˆåº¦å¹´åŒ–æ”¶ç›Šï¼ˆå‡ ä½•å¹³å‡ï¼‰
        # åŸå› ï¼šå‡ ä½•å¹³å‡è€ƒè™‘å¤åˆ©æ•ˆåº”ï¼Œæ›´å‡†ç¡®åæ˜ é•¿æœŸæ”¶ç›Š
        # å…¬å¼ï¼šæœˆåº¦å¹´åŒ–æ”¶ç›Š = (æœˆåº¦æ”¶ç›Šä¹˜ç§¯)^(12/æœˆæ•°) - 1
        # é€‚ç”¨åœºæ™¯ï¼šè¯„ä¼°ç­–ç•¥çš„é•¿æœŸè¡¨ç°
        monthly_annual_return = (1 + monthly_returns).prod() ** (12 / len(monthly_returns)) - 1 if len(monthly_returns) > 0 else 0
        
        # å¹´åº¦æ”¶ç›Šåˆ†è§£
        equity_curve['year'] = pd.to_datetime(equity_curve['date']).dt.year
        yearly_returns = self._calculate_yearly_returns(equity_curve)
        
        return {
            'total_return': total_return,
            'years': years,
            'annual_return': annual_return,
            'annual_return_simple': annual_return_simple,
            'monthly_annual_return': monthly_annual_return,
            'monthly_returns': monthly_returns,
            'yearly_returns': yearly_returns,
            'avg_monthly_return': monthly_returns.mean(),
            'monthly_return_std': monthly_returns.std()
        }
    
    def _calculate_yearly_returns(self, equity_curve: pd.DataFrame) -> Dict[int, float]:
        """è®¡ç®—å¹´åº¦æ”¶ç›Š"""
        yearly_returns = {}
        
        for year in equity_curve['year'].unique():
            year_data = equity_curve[equity_curve['year'] == year].sort_values('date')
            if len(year_data) > 0:
                year_start = year_data['equity'].iloc[0]
   <CodeFromFile 
  filePath="code_library/008_Chapter8_Backtest/8.3/code_8_3_ä½¿ç”¨ç¤ºä¾‹.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
# åˆ†æå¹´åŒ–æ”¶ç›Š
analyzer = AnnualReturnAnalyzer()
result = analyzer.analyze_annual_return(bt_result.equity_curve)

print(f"å›æµ‹æ—¶é—´è·¨åº¦: {result['years']:.2f}å¹´")
print(f"æ€»æ”¶ç›Šç‡: {result['total_return']:.2%}")
print(f"å¹´åŒ–æ”¶ç›Šç‡ï¼ˆå¤åˆ©ï¼‰: {result['annual_return']:.2%}")
print(f"å¹´åŒ–æ”¶ç›Šç‡ï¼ˆç®€å•ï¼‰: {result['annual_return_simple']:.2%}")
print(f"æœˆåº¦å¹´åŒ–æ”¶ç›Š: {result['monthly_annual_return']:.2%}")
print(f"å¹³å‡æœˆåº¦æ”¶ç›Š: {result['avg_monthly_return']:.2%}")

# å¹´åº¦æ”¶ç›Šåˆ†è§£
for year, ret<CodeFromFile 
  filePath="code_library/008_Chapter8_Backtest/8.3/code_8_3_analyze_excess_return.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
class ExcessReturnAnalyzer:
    """è¶…é¢æ”¶ç›Šåˆ†æå™¨"""
    
    def analyze_excess_return(
        self,
        equity_curve: pd.DataFrame,
        benchmark_curve: pd.DataFrame
    ) -> Dict[str, Any]:
        """
        åˆ†æè¶…é¢æ”¶ç›Š
        
        Args:
            equity_curve: ç­–ç•¥å‡€å€¼æ›²çº¿
            benchmark_curve: åŸºå‡†å‡€å€¼æ›²çº¿
        
        Returns:
            Dict: è¶…é¢æ”¶ç›Šåˆ†æç»“æœ
        """
        # è®¾è®¡åŸç†ï¼šæ•°æ®å¯¹é½
        # åŸå› ï¼šç­–ç•¥å’ŒåŸºå‡†çš„æ•°æ®æ—¥æœŸå¯èƒ½ä¸å®Œå…¨ä¸€è‡´ï¼Œéœ€è¦å¯¹é½
        # å®ç°æ–¹å¼ï¼šæŒ‰æ—¥æœŸæ’åºï¼Œç¡®ä¿æ•°æ®é¡ºåºä¸€è‡´
        equity_curve = equity_curve.sort_values('date')
        benchmark_curve = benchmark_curve.sort_values('date')
        
        # è®¾è®¡åŸç†ï¼šæ•°æ®åˆå¹¶
        # åŸå› ï¼šéœ€è¦åŒæ—¶è®¡ç®—ç­–ç•¥å’ŒåŸºå‡†çš„æ”¶ç›Šï¼Œè¿›è¡Œå¯¹æ¯”
        # å®ç°æ–¹å¼ï¼šä½¿ç”¨pd.mergeæŒ‰æ—¥æœŸåˆå¹¶ï¼Œåªä¿ç•™å…±åŒæ—¥æœŸ
        # æ³¨æ„äº‹é¡¹ï¼šå¦‚æœæ—¥æœŸä¸åŒ¹é…ï¼Œä¼šä¸¢å¤±éƒ¨åˆ†æ•°æ®ï¼Œéœ€è¦ç¡®ä¿æ•°æ®å®Œæ•´æ€§
        merged = pd.merge(
            equity_curve[['date', 'equity']],
            benchmark_curve[['date', 'equity']],
            on='date',
            suffixes=('_strategy', '_benchmark')
        )
        
        # è®¡ç®—æ”¶ç›Šç‡
        merged['return_strategy'] = merged['equity_strategy'].pct_change()
        merged['return_benchmark'] = merged['equity_benchmark'].pct_change()
        
        # è¶…é¢æ”¶ç›Šï¼ˆæ—¥åº¦ï¼‰
        merged['excess_return'] = merged['return_strategy'] - merged['return_benchmark']
        
        # ç´¯è®¡è¶…é¢æ”¶ç›Š
        merged['cumulative_excess_return'] = (1 + merged['excess_return']).cumprod() - 1
        
        # æ€»è¶…é¢æ”¶ç›Š
        initial_strategy = merged['equity_strategy'].iloc[0]
        final_strategy = merged['equity_strategy'].iloc[-1]
        strategy_total_return = (final_strategy / initial_strategy) - 1
        
        initial_benchmark = merged['equity_benchmark'].iloc[0]
        final_benchmark = merged['equity_benchmark'].iloc[-1]
        benchmark_total_return = (final_benchmark / initial_benchmark) - 1
        
        total_excess_return = strategy_total_return - benchmark_total_return
        
        # å¹´åŒ–è¶…é¢æ”¶ç›Š
        days = (pd.to_datetime(merged['date'].iloc[-1]) - pd.to_datetime(merged['date'].iloc[0])).days
        years = days / 365.25
        annual_excess_return = total_excess_return / years if years > 0 else 0
        
        # ä¿¡æ¯æ¯”ç‡ï¼ˆè¶…é¢æ”¶ç›Šçš„å¤æ™®æ¯”ç‡ï¼‰
        excess_returns = merged['excess_return'].dropna()
        information_ratio = excess_returns.mean() * np.sqrt(252) / excess_returns.std() if excess_returns.std() > 0 else 0
        
        # è·Ÿè¸ªè¯¯å·®ï¼ˆè¶…é¢æ”¶ç›Šçš„æ ‡å‡†å·®ï¼‰
        tracking_error = excess_returns.std() * np.sqrt(252)
        
        return {
            'strategy_total_return': strategy_total_return,
            'benchmark_total_return': benchmark_total_return,
            'total_excess_return': total_excess_return,
            'annual_excess_return': annual_excess_return,
            'information_ratio': information_ratio,
            'tracking_error': tracking_error,
            'excess_return_series': merged[['date', 'excess_return', 'cumulative_excess_return']],
            'excess_return_stats': {
                'mean': excess_returns.mean(),<CodeFromFile 
  filePath="code_library/008_Chapter8_Backtest/8.3/code_8_3_ä½¿ç”¨ç¤ºä¾‹.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
# åˆ†æè¶…é¢æ”¶ç›Š
analyzer = ExcessReturnAnalyzer()
result = analyzer.analyze_excess_return(
    bt_result.equity_curve,
    bt_result.benchmark_curve
)

print(f"ç­–ç•¥æ€»æ”¶ç›Š: {result['strategy_total_return']:.2%}")
print(f"åŸºå‡†æ€»æ”¶ç›Š: {result['benchmark_total_return']:.2%}")
print(f"æ€»è¶…é¢æ”¶ç›Š: {result['total_excess_return']:.2%}")
print(f"å¹´åŒ–è¶…é¢æ”¶ç›Š: {result['annual_excess_return']:.2%}")
print(f"ä¿¡æ¯æ¯”ç‡: {result['informatio<CodeFromFile 
  filePath="code_library/008_Chapter8_Backtest/8.3/code_8_3_decompose_returns.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
class ReturnDecompositionAnalyzer:
    """æ”¶ç›Šåˆ†è§£åˆ†æå™¨"""
    
    def decompose_returns(
        self,
        trades: List[TradeRecord],
        equity_curve: pd.DataFrame
    ) -> Dict[str, Any]:
        """
        åˆ†è§£æ”¶ç›Šæ¥æº
        
        Args:
            trades: äº¤æ˜“è®°å½•
            equity_curve: å‡€å€¼æ›²çº¿
        
        Returns:
            Dict: æ”¶ç›Šåˆ†è§£ç»“æœ
        """
        trades_df = pd.DataFrame([
            {
                'date': t.date,
                'security': t.security,
                'action': t.action,
                'price': t.price,
                'amount': t.amount,
                'pnl': t.pnl
            }
            for t in trades
        ])
        
        # æŒ‰è¡Œä¸šåˆ†è§£ï¼ˆéœ€è¦è¡Œä¸šä¿¡æ¯ï¼‰
        industry_decomposition = self._decompose_by_industry(trades_df)
        
        # æŒ‰ä¸ªè‚¡åˆ†è§£
        stock_decomposition = self._decompose_by_stock(trades_df)
        
        # æŒ‰æ—¶é—´ç»´åº¦åˆ†è§£
        time_decomposition = self._decompose_by_time(equity_curve)
        
        return {
            'industry_decomposition': industry_decomposition,
            'stock_decomposition': stock_decomposition,
            'time_decomposition': time_decomposition
        }
    
    def _decompose_by_stock(self, trades_df: pd.DataFrame) -> Dict[str, Any]:
        """æŒ‰ä¸ªè‚¡åˆ†è§£æ”¶ç›Š"""
        sell_trades = trades_df[trades_df['action'] == 'sell']
        
        stock_pnl = sell_trades.groupby('security')['pnl'].sum()
        total_pnl = stock_pnl.sum()
        
        stock_contribution = {
            stock: {
                'pnl': pnl,
                'contribution': pnl / total_pnl if total_pnl != 0 else 0,
                'trade_count': len(sell_trades[sell_trades['security'] == stock])
            }
            for stock, pnl in stock_pnl.items()
        }
        
        return {
            'total_pnl': total_pnl,
            'stock_contributions': stock_contribution,
            'top_contributors': sorted(
                stock_contribution.items(),
                key=lambda x: x[1]['pnl'],
                reverse=True
            )[:10]
        }
    
    def _decompose_by_time(self, equity_curve: pd.DataFrame) -> Dict[str, Any]:
        """æŒ‰æ—¶é—´ç»´åº¦åˆ†è§£æ”¶ç›Š"""
        equity_curve = equity_curve.sort_values('date')
        equity_curve['date'] = pd.to_datetime(equity_curve['date'])
        
        # æœˆåº¦æ”¶ç›Š
        equity_curve['year_month'] = equity_curve['date'].dt.to_period('M')
        monthly_equity = equity_curve.groupby('year_month')['equity'].last()
        monthly_returns = monthly_equity.pct_change().dropna()
        
        # å­£åº¦æ”¶ç›Š
        equity_curve['quarter'] = equity_curve['date'].dt.to_period('Q')
        quarterly_equity = equity_curve.groupby('quarter')['equity'].last()
        quarterly_returns = quarterly_equity.pct_change().dropna()
        
        # å¹´åº¦æ”¶ç›Š
        equity_curve['year'] = equity_curve['date'].dt.year
        yearly_equity = equity_curve.groupby('year')['equity'].last()
        yearly_returns = yearly_equity.pct_change().dropna()
        
        return {
            'monthly_returns': monthly_returns.to_dict(),
            'quarterly_returns': quarterly_returns.to_dict(),
            'yearly_returns': yearly_returns.to_dict(),
            'best_month': monthly_returns.idxmax(),
            'worst_month': monthly_returns.idxmin(),
            'best_quarter': quarterly_returns.idxmax(),
            'worst_quarter': quarterly_returns.idxmin()
        }
    
    def _decompose_by_industry(self, trades_df: pd.DataFrame) -> Dict[str, Any]:
    <CodeFromFile 
  filePath="code_library/008_Chapter8_Backtest/8.3/code_8_3_analyze_stability.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
class ReturnStabilityAnalyzer:
    """æ”¶ç›Šç¨³å®šæ€§åˆ†æå™¨"""
    
    def analyze_stability(
        self,
        equity_curve: pd.DataFrame
    ) -> Dict[str, Any]:
        """
        åˆ†ææ”¶ç›Šç¨³å®šæ€§
        
        Args:
            equity_curve: å‡€å€¼æ›²çº¿
        
        Returns:
            Dict: æ”¶ç›Šç¨³å®šæ€§åˆ†æç»“æœ
        """
        equity_curve = equity_curve.sort_values('date')
        equity_curve['date'] = pd.to_datetime(equity_curve['date'])
        
        # æœˆåº¦æ”¶ç›Š
        equity_curve['year_month'] = equity_curve['date'].dt.to_period('M')
        monthly_equity = equity_curve.groupby('year_month')['equity'].last()
        monthly_returns = monthly_equity.pct_change().dropna()
        
        # æ”¶ç›Šç¨³å®šæ€§æŒ‡æ ‡
        stability_metrics = {
            'monthly_return_mean': monthly_returns.mean(),
            'monthly_return_std': monthly_returns.std(),
            'monthly_return_cv': monthly_returns.std() / abs(monthly_returns.mean()) if monthly_returns.mean() != 0 else 0,  # å˜å¼‚ç³»æ•°
            'positive_months_ratio': (monthly_returns > 0).sum() / len(monthly_returns),
            'consecutive_positive_months': self._max_consecutive_positive(monthly_returns),
            'consecutive_negative_months': self._max_consecutive_negative(monthly_returns)
        }
        
        # æ”¶ç›ŠæŒç»­æ€§
        persistence_metrics = self._analyze_persistence(monthly_returns)
        
        return {
            'monthly_returns': monthly_returns,
            'stability_metrics': stability_metrics,
            'persistence_metrics': persistence_metrics
        }
    
    def _max_consecutive_positive(self, returns: pd.Series) -> int:
        """æœ€å¤§è¿ç»­ç›ˆåˆ©æœˆæ•°"""
        max_consecutive = 0
        current_consecutive = 0
        
        for ret in returns:
            if ret > 0:
                current_consecutive += 1
                max_consecutive = max(max_consecutive, current_consecutive)
            else:
                current_consecutive = 0
        
        return max_consecutive
    
    def _max_consecutive_negative(self, returns: pd.Series) -> int:
        """æœ€å¤§è¿ç»­äºæŸæœˆæ•°"""
        max_consecutive = 0
        current_consecutive = 0
        
        for ret in returns:
            if ret < 0:
                current_consecutive += 1
                max_consecutive = max(max_consecutive, current_consecutive)
            else:
                current_consecutive = 0
        
        return max_consecutive
    
    def _analyze_persistence(self, monthly_returns: pd.Series) -> Dict[str, Any]:
        """åˆ†ææ”¶ç›ŠæŒç»­æ€§"""
        # è®¡ç®—è‡ªç›¸å…³
        autocorr = monthly_returns.autocorr(lag=1)
        
        # è®¡ç®—æ”¶ç›Šåºåˆ—çš„è¶‹åŠ¿
        trend = np.polyfit(range(len(monthly_returns)), monthly_returns.values, 1)[0]
        
        return {
            'autocorrelation': autocorr,
            'trend':<CodeFromFile 
  filePath="code_library/008_Chapter8_Backtest/8.3/code_8_3_plot_return_curve.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib import font_manager

class ReturnVisualizer:
    """æ”¶ç›Šå¯è§†åŒ–å™¨"""
    
    def plot_return_curve(
        self,
        equity_curve: pd.DataFrame,
        benchmark_curve: pd.DataFrame = None,
        save_path: str = None
    ):
        """ç»˜åˆ¶æ”¶ç›Šæ›²çº¿"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        equity_curve = equity_curve.sort_values('date')
        dates = pd.to_datetime(equity_curve['date'])
        
        # ç­–ç•¥æ”¶ç›Šæ›²çº¿
        initial_equity = equity_curve['equity'].iloc[0]
        strategy_return = (equity_curve['equity'] / initial_equity - 1) * 100
        ax.plot(dates, strategy_return, label='ç­–ç•¥æ”¶ç›Š', linewidth=2)
        
        # åŸºå‡†æ”¶ç›Šæ›²çº¿
        if benchmark_curve is not None:
            benchmark_curve = benchmark_curve.sort_values('date')
            benchmark_dates = pd.to_datetime(benchmark_curve['date'])
            initial_benchmark = benchmark_curve['equity'].iloc[0]
            benchmark_return = (benchmark_curve['equity'] / initial_benchmark - 1) * 100
            ax.plot(benchmark_dates, benchmark_return, label='åŸºå‡†æ”¶ç›Š', linewidth=2, linestyle='--')
        
        ax.set_xlabel('æ—¥æœŸ', fontsize=12)
        ax.set_ylabel('ç´¯è®¡æ”¶ç›Šç‡ (%)', fontsize=12)
        ax.set_title('æ”¶ç›Šæ›²çº¿å¯¹æ¯”', fontsize=14, fontweight='bold')
        ax.legend(fontsize=10)
        ax.grid(True, alpha=0.3)
        
        # æ ¼å¼åŒ–xè½´æ—¥æœŸ
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
        ax.xaxis.set_major_locator(mdates.MonthLocator(interval=3))
        plt.xticks(rotation=45)
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        
        return fig
    
    def plot_monthly_returns(
        self,
        monthly_returns: pd.Series,
        save_path: str = None
    ):
        """ç»˜åˆ¶æœˆåº¦æ”¶ç›ŠæŸ±çŠ¶å›¾"""
        fig, ax = plt.subplots(figsize=(14, 6))
        
        colors = ['green' if x > 0 else 'red' for x in monthly_returns.values]
        ax.bar(range(len(monthly_returns)), monthly_returns.values * 100, color=colors, alpha=0.7)
        
        ax.axhline(y=0, color='black', linestyle='-', linewidth=0.5)
        ax.set_xlabel('æœˆä»½', fontsize=12)
        ax.set_ylabel('æœˆåº¦æ”¶ç›Šç‡ (%)', fontsize=12)
        ax.set_title('æœˆåº¦æ”¶ç›Šåˆ†å¸ƒ', fontsize=14, fontweight='bold')
        ax.set_xticks(range(len(monthly_returns)))
        ax.set_xticklabels([str(x) for x in monthly_returns.index], rotation=45)
        ax.grid(True, alpha=0.3, axis='y')
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        
        return fig
```
-->style='--')
        
        ax.set_xlabel('æ—¥æœŸ', fontsize=12)
        ax.set_ylabel('ç´¯è®¡æ”¶ç›Šç‡ (%)', fontsize=12)
        ax.set_title('æ”¶ç›Šæ›²çº¿å¯¹æ¯”', fontsize=14, fontweight='bold')
        ax.legend(fontsize=10)
        ax.grid(True, alpha=0.3)
        
        # æ ¼å¼åŒ–xè½´æ—¥æœŸ
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
        ax.xaxis.set_major_locator(mdates.MonthLocator(interval=3))
        plt.xticks(rotation=45)
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        
        return fig
    
    def plot_monthly_returns(
        self,
        monthly_returns: pd.Series,
        save_path: str = None
    ):
        """ç»˜åˆ¶æœˆåº¦æ”¶ç›ŠæŸ±çŠ¶å›¾"""
        fig, ax = plt.subplots(figsize=(14, 6))
        
        colors = ['green' if x > 0 else 'red' for x in monthly_returns.values]
        ax.bar(range(len(monthly_returns)), monthly_returns.values * 100, color=colors, alpha=0.7)
        
        ax.axhline(y=0, color='black', linestyle='-', linewidth=0.5)
        ax.set_xlabel('æœˆä»½', fontsize=12)
        ax.set_ylabel('æœˆåº¦æ”¶ç›Šç‡ (%)', fontsize=12)
        ax.set_title('æœˆåº¦æ”¶ç›Šåˆ†å¸ƒ', fontsize=14, fontweight='bold')
        ax.set_xticks(range(len(monthly_returns)))
        ax.set_xticklabels([str(x) for x in monthly_returns.index], rotation=45)
        ax.grid(True, alpha=0.3, axis='y')
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        
        return fig
```

## ğŸ”— ç›¸å…³ç« èŠ‚

- **8.1 å›æµ‹æ¡†æ¶**ï¼šäº†è§£å›æµ‹æ¡†æ¶ï¼Œæ”¶ç›Šåˆ†æåŸºäºå›æµ‹ç»“æœ
- **8.2 å›æµ‹åˆ†æå™¨**ï¼šäº†è§£å›æµ‹åˆ†æå™¨ï¼Œæ”¶ç›Šåˆ†ææ˜¯åˆ†æå™¨çš„ä¸€éƒ¨åˆ†
- **8.4 é£é™©åˆ†æ**ï¼šäº†è§£é£é™©åˆ†æï¼Œæ”¶ç›Šå’Œé£é™©éœ€è¦ç»“åˆåˆ†æ

## ğŸ’¡ å…³é”®è¦ç‚¹

1. **æ€»æ”¶ç›Šåˆ†æ**ï¼šè¯„ä¼°ç­–ç•¥åœ¨æ•´ä¸ªå›æµ‹æœŸé—´çš„ç´¯è®¡æ”¶ç›Šè¡¨ç°
2. **å¹´åŒ–æ”¶ç›Šåˆ†æ**ï¼šå°†æ€»æ”¶ç›Šè½¬æ¢ä¸ºå¹´åŒ–æ”¶ç›Šç‡ï¼Œä¾¿äºå¯¹æ¯”
3. **è¶…é¢æ”¶ç›Šåˆ†æ**ï¼šè¯„ä¼°ç­–ç•¥ç›¸å¯¹äºåŸºå‡†çš„è¶…é¢è¡¨ç°
4. **æ”¶ç›Šåˆ†è§£**ï¼šè¯†åˆ«æ”¶ç›Šæ¥æºï¼ŒåŒ…æ‹¬è¡Œä¸šã€ä¸ªè‚¡ã€æ—¶é—´ç»´åº¦
5. **æ”¶ç›Šç¨³å®šæ€§**ï¼šè¯„ä¼°æ”¶ç›Šçš„ç¨³å®šæ€§å’ŒæŒç»­æ€§
6. **æ”¶ç›Šå¯è§†åŒ–**ï¼šé€šè¿‡å›¾è¡¨ç›´è§‚å±•ç¤ºæ”¶ç›Šåˆ†æç»“æœ

## ğŸ”® æ€»ç»“ä¸å±•æœ›

<div class="summary-outlook">
  <h3>æœ¬èŠ‚å›é¡¾</h3>
  <p>æœ¬èŠ‚è¯¦ç»†ä»‹ç»äº†æ”¶ç›Šåˆ†æåŠŸèƒ½ï¼ŒåŒ…æ‹¬æ€»æ”¶ç›Šã€å¹´åŒ–æ”¶ç›Šã€è¶…é¢æ”¶ç›Šã€æ”¶ç›Šåˆ†è§£ã€æ”¶ç›Šç¨³å®šæ€§ç­‰å¤šä¸ªç»´åº¦çš„åˆ†æã€‚é€šè¿‡ç†è§£æ”¶ç›Šåˆ†æçš„æ ¸å¿ƒæŠ€æœ¯ï¼Œå¸®åŠ©å¼€å‘è€…å…¨é¢è¯„ä¼°ç­–ç•¥çš„æ”¶ç›Šè¡¨ç°ï¼Œè¯†åˆ«æ”¶ç›Šæ¥æºå’Œæ”¶ç›Šç‰¹å¾ã€‚</p>
  
  <h3>ä¸‹èŠ‚é¢„å‘Š</h3>
  <p>æŒæ¡äº†æ”¶ç›Šåˆ†æåï¼Œä¸‹ä¸€èŠ‚å°†è¯¦ç»†ä»‹ç»é£é™©åˆ†æï¼ŒåŒ…æ‹¬æœ€å¤§å›æ’¤ã€æ³¢åŠ¨ç‡ã€å¤æ™®æ¯”ç‡ç­‰é£é™©æŒ‡æ ‡ã€‚é€šè¿‡ç†è§£é£é™©åˆ†æçš„è¯¦ç»†æ–¹æ³•ï¼Œå¸®åŠ©å¼€å‘è€…æŒæ¡å¦‚ä½•å…¨é¢è¯„ä¼°ç­–ç•¥çš„é£é™©æ°´å¹³ã€‚</p>
  
  <a href="/ashare-book6/008_Chapter8_Backtest/8.4_Risk_Analysis_CN" class="next-section">
    ç»§ç»­å­¦ä¹ ï¼š8.4 é£é™©åˆ†æ â†’
  </a>
</div>

> **é€‚ç”¨ç‰ˆæœ¬**: v1.0.0+  
> **æœ€åæ›´æ–°**: 2025-12-12

