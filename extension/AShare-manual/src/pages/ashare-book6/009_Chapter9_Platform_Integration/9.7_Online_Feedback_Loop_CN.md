---
title: "9.7 å®ç›˜åé¦ˆä¸åœ¨çº¿å†ä¼˜åŒ–"
description: "æ·±å…¥è§£æå®ç›˜åé¦ˆä¸åœ¨çº¿å†ä¼˜åŒ–ç³»ç»Ÿï¼ŒåŒ…æ‹¬å®ç›˜åé¦ˆæœºåˆ¶ã€åœ¨çº¿å†ä¼˜åŒ–æµç¨‹ã€è§¦å‘å™¨æœºåˆ¶ã€å®‰å…¨ç­–ç•¥ã€åé¦ˆé—­ç¯è®¾è®¡ç­‰æ ¸å¿ƒæŠ€æœ¯ï¼Œä¸ºé‡åŒ–æŠ•èµ„ç³»ç»Ÿæä¾›å®Œæ•´çš„å®ç›˜åé¦ˆå’Œåœ¨çº¿ä¼˜åŒ–èƒ½åŠ›"
lang: "zh-CN"
layout: "/src/layouts/HandbookLayout.astro"
currentBook: "ashare-book6"
updateDate: "2025-12-12"
---

# ğŸ”„ 9.7 å®ç›˜åé¦ˆä¸åœ¨çº¿å†ä¼˜åŒ–

> **æ ¸å¿ƒæ‘˜è¦ï¼š**
> 
> æœ¬èŠ‚ç³»ç»Ÿä»‹ç»TRQuantç³»ç»Ÿçš„å®ç›˜åé¦ˆä¸åœ¨çº¿å†ä¼˜åŒ–ç³»ç»Ÿï¼ŒåŒ…æ‹¬å®ç›˜åé¦ˆæœºåˆ¶ã€åœ¨çº¿å†ä¼˜åŒ–æµç¨‹ã€è§¦å‘å™¨æœºåˆ¶ã€å®‰å…¨ç­–ç•¥å’Œåé¦ˆé—­ç¯è®¾è®¡ã€‚é€šè¿‡ç†è§£å®ç›˜åé¦ˆçš„å®Œæ•´æœºåˆ¶ï¼Œå¸®åŠ©å¼€å‘è€…æŒæ¡å¦‚ä½•å®ç°ç­–ç•¥çš„æŒç»­ä¼˜åŒ–ï¼Œå½¢æˆç­–ç•¥ç”Ÿæˆâ†’ä¼˜åŒ–â†’å›æµ‹â†’å®ç›˜â†’å†ä¼˜åŒ–çš„å®Œæ•´é—­ç¯ã€‚

å®ç›˜åé¦ˆä¸åœ¨çº¿å†ä¼˜åŒ–æ˜¯ç­–ç•¥ä»å›æµ‹åˆ°å®ç›˜çš„å…³é”®é—­ç¯ç¯èŠ‚ï¼Œè´Ÿè´£ç›‘æ§å®ç›˜è¡¨ç°ã€è§¦å‘å†ä¼˜åŒ–ã€ç”Ÿæˆä¼˜åŒ–å€™é€‰ç­–ç•¥ï¼Œå¹¶ç¡®ä¿å®‰å…¨ä¸Šçº¿ã€‚

## ğŸ“‹ ç« èŠ‚æ¦‚è§ˆ

<script>
function scrollToSection(sectionId) {
  const element = document.getElementById(sectionId);
  if (element) {
    const headerOffset = 100;
    const elementPosition = element.getBoundingClientRect().top;
    const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
    window.scrollTo({
      top: offsetPosition,
      behavior: 'smooth'
    });
  }
}
</script>

<div class="section-overview">
  <div class="section-item" onclick="scrollToSection('section-9-7-1')">
    <h4>ğŸ“Š 9.7.1 å®ç›˜åé¦ˆæœºåˆ¶</h4>
    <p>å®ç›˜æ•°æ®æ”¶é›†ã€æ€§èƒ½ç›‘æ§ã€å¼‚å¸¸æ£€æµ‹ã€æ•°æ®å›æµ</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-9-7-2')">
    <h4>âš¡ 9.7.2 è§¦å‘å™¨æœºåˆ¶</h4>
    <p>å›æµ‹è§¦å‘å™¨ã€å®ç›˜è§¦å‘å™¨ã€æ•°æ®è§¦å‘å™¨ã€è§¦å‘æ¡ä»¶</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-9-7-3')">
    <h4>ğŸ”„ 9.7.3 åœ¨çº¿å†ä¼˜åŒ–æµç¨‹</h4>
    <p>è½»é‡çº§å“åº”ã€ä¸­ç­‰å“åº”ã€ä¸¥é‡å“åº”ã€ä¼˜åŒ–ç­–ç•¥ç”Ÿæˆ</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-9-7-4')">
    <h4>ğŸ›¡ï¸ 9.7.4 å®‰å…¨ç­–ç•¥</h4>
    <p>ä¸Šçº¿é—¨ç¦ã€dry_runæ¨¡å¼ã€confirm_tokenã€è¯æ®è®°å½•</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-9-7-5')">
    <h4>ğŸ” 9.7.5 åé¦ˆé—­ç¯è®¾è®¡</h4>
    <p>å®Œæ•´é—­ç¯æµç¨‹ã€æ•°æ®æµè½¬ã€ç‰ˆæœ¬ç®¡ç†ã€å›æ»šæœºåˆ¶</p>
  </div>
</div>

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬èŠ‚å­¦ä¹ ï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- **å®ç°å®ç›˜åé¦ˆ**ï¼šæŒæ¡å®ç›˜æ•°æ®æ”¶é›†ã€æ€§èƒ½ç›‘æ§å’Œå¼‚å¸¸æ£€æµ‹
- **è®¾è®¡è§¦å‘å™¨**ï¼šç†è§£å›æµ‹ã€å®ç›˜å’Œæ•°æ®è§¦å‘å™¨çš„è®¾è®¡
- **å®ç°åœ¨çº¿ä¼˜åŒ–**ï¼šæŒæ¡åœ¨çº¿å†ä¼˜åŒ–æµç¨‹å’Œä¼˜åŒ–ç­–ç•¥ç”Ÿæˆ
- **ç¡®ä¿å®‰å…¨**ï¼šç†è§£ä¸Šçº¿é—¨ç¦ã€dry_runæ¨¡å¼å’Œè¯æ®è®°å½•æœºåˆ¶
- **è®¾è®¡é—­ç¯**ï¼šæŒæ¡åé¦ˆé—­ç¯çš„å®Œæ•´è®¾è®¡å’Œå®ç°

## ğŸ“š æ ¸å¿ƒæ¦‚å¿µ

### æ¨¡å—å®šä½

- **å·¥ä½œæµä½ç½®**ï¼šæ­¥éª¤8ä¹‹å - å®ç›˜åé¦ˆä¸åœ¨çº¿å†ä¼˜åŒ–
- **æ ¸å¿ƒèŒè´£**ï¼šå®ç›˜ç›‘æ§ã€è§¦å‘å†ä¼˜åŒ–ã€ç”Ÿæˆä¼˜åŒ–å€™é€‰ã€å®‰å…¨ä¸Šçº¿
- **æœåŠ¡å¯¹è±¡**ï¼šå®ç›˜äº¤æ˜“ç­–ç•¥ã€ç­–ç•¥ä¼˜åŒ–ç³»ç»Ÿ

### æŠ€æœ¯æ ˆ

- **ç›‘æ§ç³»ç»Ÿ**ï¼šå®æ—¶ç›‘æ§ã€æ€§èƒ½æŒ‡æ ‡è®¡ç®—
- **è§¦å‘å™¨ç³»ç»Ÿ**ï¼šæ¡ä»¶åˆ¤æ–­ã€é˜ˆå€¼ç®¡ç†
- **ä¼˜åŒ–å¼•æ“**ï¼šç­–ç•¥ä¼˜åŒ–ã€å‚æ•°è°ƒæ•´
- **å®‰å…¨ç³»ç»Ÿ**ï¼šdry_runæ¨¡å¼ã€confirm_tokenã€è¯æ®è®°å½•

### è®¾è®¡åŸåˆ™

- **å®‰å…¨ç¬¬ä¸€**ï¼šæ‰€æœ‰å†™æ“ä½œé»˜è®¤dry_runï¼Œä¸Šçº¿éœ€è¦ç¡®è®¤
- **å¯è¿½æº¯**ï¼šæ‰€æœ‰æ“ä½œè®°å½•è¯æ®ï¼Œæ”¯æŒå›æ»š
- **è‡ªåŠ¨åŒ–**ï¼šè§¦å‘å™¨å’Œå“åº”åŠ¨ä½œè‡ªåŠ¨åŒ–æ‰§è¡Œ
- **å¯æ§åˆ¶**ï¼šæ”¯æŒæ‰‹åŠ¨å¹²é¢„å’Œç´§æ€¥åœæ­¢

<h2 id="section-9-7-1">ğŸ“Š 9.7.1 å®ç›˜åé¦ˆæœºåˆ¶</h2>

å®ç›˜åé¦ˆæœºåˆ¶è´Ÿè´£æ”¶é›†å®ç›˜äº¤æ˜“æ•°æ®ã€ç›‘æ§ç­–ç•¥æ€§èƒ½ã€æ£€æµ‹å¼‚å¸¸æƒ…å†µã€‚

### å®ç›˜æ•°æ®æ”¶é›†å™¨

<CodeFromFile 
  filePath="code_library/009_Chapter9_Platform_Integration/9.7/code_9_7___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
# core/live_feedback/data_collector.py
from typing import Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

@dataclass
class LiveTradeRecord:
    """å®ç›˜äº¤æ˜“è®°å½•"""
    strategy_id: str
    symbol: str
    side: str  # "buy" or "sell"
    quantity: int
    price: float
    fill_time: datetime
    commission: float
    stamp_tax: float

@dataclass
class LivePerformanceMetrics:
    """å®ç›˜æ€§èƒ½æŒ‡æ ‡"""
    strategy_id: str
    date: datetime
    daily_return: float
    cumulative_return: float
    sharpe_ratio: float
    max_drawdown: float
    win_rate: float
    avg_profit: float
    avg_loss: float
    total_trades: int
    slippage: float
    tracking_error: float

class LiveDataCollector:
    """å®ç›˜æ•°æ®æ”¶é›†å™¨"""
    
    def __init__(
        self,
        trading_manager=None,
        db_connection=None
    ):
        """
        åˆå§‹åŒ–æ•°æ®æ”¶é›†å™¨
        
        Args:
            trading_manager: äº¤æ˜“ç®¡ç†å™¨
            db_connection: æ•°æ®åº“è¿æ¥
        """
        self.trading_manager = trading_manager
        self.db = db_connection
    
    def collect_trade_records(
        self,
        strategy_id: str,
        start_date: datetime,
        end_date: datetime
    ) -> List[LiveTradeRecord]:
        """
        æ”¶é›†äº¤æ˜“è®°å½•
        
        Args:
            strategy_id: ç­–ç•¥ID
            start_date: å¼€å§‹æ—¥æœŸ
            end_date: ç»“æŸæ—¥æœŸ
        
        Returns:
            List[LiveTradeRecord]: äº¤æ˜“è®°å½•åˆ—è¡¨
        """
        if self.db:
            rows = self.db.fetch_all(
                """
                SELECT * FROM trade_records 
                WHERE strategy_id = %s 
                AND fill_time >= %s 
                AND fill_time <= %s
                ORDER BY fill_time
                """,
                (strategy_id, start_date, end_date)
            )
            
            records = []
            for row in rows:
                record = LiveTradeRecord(
                    strategy_id=row['strategy_id'],
                    symbol=row['symbol'],
                    side=row['side'],
                    quantity=row['quantity'],
                    price=row['price'],
                    fill_time=row['fill_time'],
                    commission=row.get('commission', 0),
                    stamp_tax=row.get('stamp_tax', 0)
                )
                records.append(record)
            
            return records
        
        return []
    
    def collect_performance_metrics(
        self,
        strategy_id: str,
        date: datetime
    ) -> Optional[LivePerformanceMetrics]:
        """
        æ”¶é›†æ€§èƒ½æŒ‡æ ‡
        
        Args:
            strategy_id: ç­–ç•¥ID
            date: æ—¥æœŸ
        
        Returns:
            Optional[LivePerformanceMetrics]: æ€§èƒ½æŒ‡æ ‡
        """
        # è·å–æŒä»“å’Œäº¤æ˜“è®°å½•
        positions = self.trading_manager.position_manager.get_positions(strategy_id)
        trade_records = self.collect_trade_records(
            strategy_id,
            date - timedelta(days=1),
            date
        )
        
        # è®¡ç®—æ€§èƒ½æŒ‡æ ‡
        metrics = self._calculate_metrics(
            strategy_id,
            positions,
            trade_records,
            date
        )
        
        # ä¿å­˜åˆ°æ•°æ®åº“
        if metrics and self.db:
            self._save_metrics(metrics)
        
        return metrics
    
    def _calculate_metrics(
        self,
        strategy_id: str,
        positions: List,
        trade_records: List[LiveTradeRecord],
        date: datetime
    ) -> LivePerformanceMetrics:
        """è®¡ç®—æ€§èƒ½æŒ‡æ ‡"""
        # è®¡ç®—æ—¥æ”¶ç›Šç‡
        daily_return = self._calculate_daily_return(positions, trade_records)
        
        # è®¡ç®—ç´¯è®¡æ”¶ç›Šç‡
        cumulative_return = self._calculate_cumulative_return(strategy_id, date)
        
        # è®¡ç®—å¤æ™®æ¯”ç‡
        sharpe_ratio = self._calculate_sharpe_ratio(strategy_id, date)
        
        # è®¡ç®—æœ€å¤§å›æ’¤
        max_drawdown = self._calculate_max_drawdown(strategy_id, date)
        
        # è®¡ç®—èƒœç‡
        win_rate = self._calculate_win_rate(trade_records)
        
        # è®¡ç®—å¹³å‡ç›ˆäº
        avg_profit, avg_loss = self._calculate_avg_profit_loss(trade_records)
        
        # è®¡ç®—æ»‘ç‚¹
        slippage = self._calculate_slippage(trade_records)
        
        # è®¡ç®—è·Ÿè¸ªè¯¯å·®
        tracking_error = self._calculate_tracking_error(strategy_id, date)
        
        return LivePerformanceMetrics(
            strategy_id=strategy_id,
            date=date,
            daily_return=daily_return,
            cumulative_return=cumulative_return,
            sharpe_ratio=sharpe_ratio,
            max_drawdown=max_drawdown,
            win_rate=win_rate,
            avg_profit=avg_profit,
            avg_loss=avg_loss,
            total_trades=len(trade_records),
            slippage=slippage,
            tracking_error=tracking_error
        )
    
    def _save_metrics(self, metrics: LivePerformanceMetrics):
        """ä¿å­˜æ€§èƒ½æŒ‡æ ‡åˆ°æ•°æ®åº“"""
        if self.db:
            self.db.execute(
                """
                INSERT INTO live_performance_metrics 
                (strategy_id, date, daily_return, cumulative_return, 
                 sharpe_ratio, max_drawdown, win_rate, avg_profit, avg_loss, 
                 total_trades, slippage, tracking_error)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                ON CONFLICT (strategy_id, date) 
                DO UPDATE SET 
                    daily_return = EXCLUDED.daily_return,
                    cumulative_return = EXCLUDED.cumulative_return,
                    sharpe_ratio = EXCLUDED.sharpe_ratio,
                    max_drawdown = EXCLUDED.max_drawdown,
                    win_rate = EXCLUDED.win_rate,
                    avg_profit = EXCLUDED.avg_profit,
                    avg_loss = EXCLUDED.avg_loss,
                    total_trades = EXCLUDED.total_trades,
                    slippage = EXCLUDED.slippage,
                    tracking_error = EXCLUDED.tracking_error
                """,
                (
                    metrics.strategy_id,
                    metrics.date,
                    metrics.daily_return,
                    metrics.cumulative_return,
                    metrics.sharpe_ratio,
                    metrics.max_drawdown,
                    metrics.win_rate,
                    metrics.avg_profit,
                    metrics.avg_loss<CodeFromFile 
  filePath="code_library/009_Chapter9_Platform_Integration/9.7/code_9_7___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
# core/live_feedback/anomaly_detector.py
from typing import Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

@dataclass
class AnomalyAlert:
    """å¼‚å¸¸å‘Šè­¦"""
    strategy_id: str
    alert_type: str  # "slippage", "tracking_error", "drawdown", "factor_exposure"
    severity: str  # "low", "medium", "high", "critical"
    message: str
    timestamp: datetime
    value: float
    threshold: float

class AnomalyDetector:
    """å¼‚å¸¸æ£€æµ‹å™¨"""
    
    def __init__(
        self,
        data_collector,
        thresholds: Dict[str, float]
    ):
        """
        åˆå§‹åŒ–å¼‚å¸¸æ£€æµ‹å™¨
        
        Args:
            data_collector: æ•°æ®æ”¶é›†å™¨
            thresholds: é˜ˆå€¼é…ç½®
        """
        self.data_collector = data_collector
        self.thresholds = thresholds
    
    def detect_anomalies(
        self,
        strategy_id: str,
        date: datetime
    ) -> List[AnomalyAlert]:
        """
        æ£€æµ‹å¼‚å¸¸
        
        Args:
            strategy_id: ç­–ç•¥ID
            date: æ—¥æœŸ
        
        Returns:
            List[AnomalyAlert]: å¼‚å¸¸å‘Šè­¦åˆ—è¡¨
        """
        alerts = []
        
        # è·å–æ€§èƒ½æŒ‡æ ‡
        metrics = self.data_collector.collect_performance_metrics(strategy_id, date)
        if not metrics:
            return alerts
        
        # æ£€æµ‹æ»‘ç‚¹å¼‚å¸¸
        slippage_alert = self._check_slippage(metrics)
        if slippage_alert:
            alerts.append(slippage_alert)
        
        # æ£€æµ‹è·Ÿè¸ªè¯¯å·®å¼‚å¸¸
        tracking_error_alert = self._check_tracking_error(metrics)
        if tracking_error_alert:
            alerts.append(tracking_error_alert)
        
        # æ£€æµ‹å›æ’¤å¼‚å¸¸
        drawdown_alert = self._check_drawdown(metrics)
        if drawdown_alert:
            alerts.append(drawdown_alert)
        
        # æ£€æµ‹å› å­æš´éœ²å¼‚å¸¸
        factor_exposure_alert = self._check_factor_exposure(strategy_id, date)
        if factor_exposure_alert:
            alerts.append(factor_exposure_alert)
        
        return alerts
    
    def _check_slippage(self, metrics: LivePerformanceMetrics) -> Optional[AnomalyAlert]:
        """æ£€æŸ¥æ»‘ç‚¹å¼‚å¸¸"""
        threshold = self.thresholds.get('slippage', 0.002)  # 0.2%
        
        if metrics.slippage > threshold:
            return AnomalyAlert(
                strategy_id=metrics.strategy_id,
                alert_type="slippage",
                severity="high" if metrics.slippage > threshold * 2 else "medium",
                message=f"æ»‘ç‚¹å¼‚å¸¸: {metrics.slippage:.4f} > {threshold:.4f}",
                timestamp=metrics.date,
                value=metrics.slippage,
                threshold=threshold
            )
        
        return None
    
    def _check_tracking_error(self, metrics: LivePerformanceMetrics) -> Optional[AnomalyAlert]:
        """æ£€æŸ¥è·Ÿè¸ªè¯¯å·®å¼‚å¸¸"""
        threshold = self.thresholds.get('tracking_error', 0.05)  # 5%
        
        if metrics.tracking_error > threshold:
            return AnomalyAlert(
                strategy_id=metrics.strategy_id,
                alert_type="tracking_error",
                severity="high" if metrics.tracking_error > threshold * 2 else "medium",
                message=f"è·Ÿè¸ªè¯¯å·®å¼‚å¸¸: {metrics.tracking_error:.4f} > {threshold:.4f}",
                timestamp=metrics.date,
                value=metrics.tracking_error,
                threshold=threshold
            )
        
        return None
    
    def _check_drawdown(self, metrics: LivePerformanceMetrics) -> Optional[AnomalyAlert]:
        """æ£€æŸ¥å›æ’¤å¼‚å¸¸"""
        threshold = self.thresholds.get('max_drawdown', 0.15)  # 15%
        
        if metrics.max_drawdown > threshold:
            return AnomalyAlert(
                strategy_id=metrics.strategy_id,
                alert_type="drawdown",
                severity="critical" if metrics.max_drawdown > threshold * 1.5 else "high",
                message=f"å›æ’¤å¼‚å¸¸: {metrics.max_drawdown:.4f} > {threshold:.4f}",
                timestamp=metrics.date,
                value=metrics.max_drawdown,
                threshold=threshold
            )
        
        return None
    
    def _check_factor_exposure(
        self,
        strategy_id: str,
        date: datetime
    ) -> Optional[AnomalyAler<CodeFromFile 
  filePath="code_library/009_Chapter9_Platform_Integration/9.7/code_9_7___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
# core/live_feedback/trigger_manager.py
from typing import Dict, List, Optional, Callable
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
import logging

logger = logging.getLogger(__name__)

class TriggerType(Enum):
    """è§¦å‘å™¨ç±»å‹"""
    BACKTEST = "backtest"      # å›æµ‹è§¦å‘å™¨
    LIVE = "live"              # å®ç›˜è§¦å‘å™¨
    DATA = "data"               # æ•°æ®è§¦å‘å™¨

@dataclass
class TriggerCondition:
    """è§¦å‘æ¡ä»¶"""
    metric: str                 # æŒ‡æ ‡åç§°
    operator: str               # æ“ä½œç¬¦: ">", "<", ">=", "<=", "=="
    threshold: float            # é˜ˆå€¼
    lookback_days: int = 1      # å›çœ‹å¤©æ•°

@dataclass
class Trigger:
    """è§¦å‘å™¨"""
    trigger_id: str
    strategy_id: str
    trigger_type: TriggerType
    conditions: List[TriggerCondition]
    enabled: bool = True
    last_triggered: Optional[datetime] = None

class TriggerManager:
    """è§¦å‘å™¨ç®¡ç†å™¨"""
    
    def __init__(
        self,
        data_collector,
        anomaly_detector
    ):
        """
        åˆå§‹åŒ–è§¦å‘å™¨ç®¡ç†å™¨
        
        Args:
            data_collector: æ•°æ®æ”¶é›†å™¨
            anomaly_detector: å¼‚å¸¸æ£€æµ‹å™¨
        """
        self.data_collector = data_collector
        self.anomaly_detector = anomaly_detector
        self.triggers: Dict[str, Trigger] = {}
        self.callbacks: Dict[str, List[Callable]] = {}
    
    def register_trigger(
        self,
        trigger: Trigger,
        callback: Callable
    ):
        """
        æ³¨å†Œè§¦å‘å™¨
        
        Args:
            trigger: è§¦å‘å™¨
            callback: å›è°ƒå‡½æ•°
        """
        self.triggers[trigger.trigger_id] = trigger
        
        if trigger.trigger_id not in self.callbacks:
            self.callbacks[trigger.trigger_id] = []
        
        self.callbacks[trigger.trigger_id].append(callback)
    
    def check_triggers(
        self,
        strategy_id: str,
        date: datetime
    ) -> List[Trigger]:
        """
        æ£€æŸ¥è§¦å‘å™¨
        
        Args:
            strategy_id: ç­–ç•¥ID
            date: æ—¥æœŸ
        
        Returns:
            List[Trigger]: è§¦å‘çš„è§¦å‘å™¨åˆ—è¡¨
        """
        triggered = []
        
        # è·å–è¯¥ç­–ç•¥çš„æ‰€æœ‰è§¦å‘å™¨
        strategy_triggers = [
            t for t in self.triggers.values()
            if t.strategy_id == strategy_id and t.enabled
        ]
        
        for trigger in strategy_triggers:
            if self._check_trigger(trigger, date):
                triggered.append(trigger)
                trigger.last_triggered = date
                
                # æ‰§è¡Œå›è°ƒ
                if trigger.trigger_id in self.callbacks:
                    for callback in self.callbacks[trigger.trigger_id]:
                        try:
                            callback(trigger, date)
                        except Exception as e:
                            logger.error(f"è§¦å‘å™¨å›è°ƒæ‰§è¡Œå¤±è´¥: {e}", exc_info=True)
        
        return triggered
    
    def _check_trigger(
        self,
        trigger: Trigger,
        date: datetime
    ) -> bool:
        """æ£€æŸ¥è§¦å‘å™¨æ˜¯å¦æ»¡è¶³æ¡ä»¶"""
        if trigger.trigger_type == TriggerType.BACKTEST:
            return self._check_backtest_trigger(trigger, date)
        elif trigger.trigger_type == TriggerType.LIVE:
            return self._check_live_trigger(trigger, date)
        elif trigger.trigger_type == TriggerType.DATA:
            return self._check_data_trigger(trigger, date)
        
        return False
    
    def _check_backtest_trigger(
        self,
        trigger: Trigger,
        date: datetime
    ) -> bool:
        """æ£€æŸ¥å›æµ‹è§¦å‘å™¨"""
        # è·å–å›æµ‹ç»“æœ
        # è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦ä»å›æµ‹ç³»ç»Ÿè·å–
        return False
    
    def _check_live_trigger(
        self,
        trigger: Trigger,
        date: datetime
    ) -> bool:
        """æ£€æŸ¥å®ç›˜è§¦å‘å™¨"""
        # è·å–æ€§èƒ½æŒ‡æ ‡
        metrics = self.data_collector.collect_performance_metrics(
            trigger.strategy_id,
            date
        )
        
        if not metrics:
            return False
        
        # æ£€æŸ¥æ‰€æœ‰æ¡ä»¶
        for condition in trigger.conditions:
            if not self._check_condition(condition, metrics):
                return False
        
        return True
    
    def _check_data_trigger(
        self,
        trigger: Trigger,
        date: datetime
    ) -> bool:
        """æ£€æŸ¥æ•°æ®è§¦å‘å™¨"""
        # æ£€æµ‹å¼‚å¸¸
        anomalies = self.anomaly_detector.detect_anomalies(
            trigger.strategy_id,
            date
        )
        
        # æ£€æŸ¥æ˜¯å¦æœ‰ä¸¥é‡å¼‚å¸¸
        critical_anomalies = [
            a for a in anomalies
            if a.severity == "critical"
        ]
        
        return len(critical_anomalies) > 0
    
    def _check_condition(
        self,
        condition: TriggerCondition,
        metrics: LivePerformanceMetrics
    ) -> bool:
        """æ£€æŸ¥å•ä¸ªæ¡ä»¶"""
        metric_value = getattr(metrics, condition.metric, None)
        if metric_value is None:
            return False
        
        operator = condition.operator
        threshold = condition.threshold
        
        if operator == ">":
            return metric_value > threshold
        elif operator == "<":
            return metric_value < threshold
        elif operator == ">=":
            return metric_value >= threshold
        elif operator == "<=":
            return metric_value <= threshold
        elif operator == "==":
 <CodeFromFile 
  filePath="code_library/009_Chapter9_Platform_Integration/9.7/code_9_7___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
# core/live_feedback/optimizer.py
from typing import Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class OptimizationMode(Enum):
    """ä¼˜åŒ–æ¨¡å¼"""
    LIGHT = "light"        # è½»é‡çº§ï¼šå‚æ•°å¾®è°ƒ
    MEDIUM = "medium"      # ä¸­ç­‰ï¼šå› å­è°ƒæ•´
    HEAVY = "heavy"        # ä¸¥é‡ï¼šç­–ç•¥é‡æ„

@dataclass
class OptimizationResult:
    """ä¼˜åŒ–ç»“æœ"""
    strategy_id: str
    optimized_strategy_id: str
    mode: OptimizationMode
    changes: Dict[str, any]
    backtest_result: Optional[Dict] = None
    recommendation: str = "keep"  # "keep", "upgrade", "downgrade"

class OnlineOptimizer:
    """åœ¨çº¿ä¼˜åŒ–å¼•æ“"""
    
    def __init__(
        self,
        strategy_generator,
        backtest_engine,
        mode: str = "dry_run"
    ):
        """
        åˆå§‹åŒ–ä¼˜åŒ–å¼•æ“
        
        Args:
            strategy_generator: ç­–ç•¥ç”Ÿæˆå™¨
            backtest_engine: å›æµ‹å¼•æ“
            mode: æ¨¡å¼ï¼ˆ"dry_run" æˆ– "execute"ï¼‰
        """
        self.strategy_generator = strategy_generator
        self.backtest_engine = backtest_engine
        self.mode = mode
    
    def optimize_strategy(
        self,
        strategy_id: str,
        trigger: Trigger,
        mode: OptimizationMode = OptimizationMode.LIGHT
    ) -> OptimizationResult:
        """
        ä¼˜åŒ–ç­–ç•¥
        
        Args:
            strategy_id: ç­–ç•¥ID
            trigger: è§¦å‘å™¨
            mode: ä¼˜åŒ–æ¨¡å¼
        
        Returns:
            OptimizationResult: ä¼˜åŒ–ç»“æœ
        """
        logger.info(f"å¼€å§‹ä¼˜åŒ–ç­–ç•¥ {strategy_id}ï¼Œæ¨¡å¼: {mode.value}")
        
        if mode == OptimizationMode.LIGHT:
            return self._light_optimization(strategy_id, trigger)
        elif mode == OptimizationMode.MEDIUM:
            return self._medium_optimization(strategy_id, trigger)
        elif mode == OptimizationMode.HEAVY:
            return self._heavy_optimization(strategy_id, trigger)
        
        raise ValueError(f"æœªçŸ¥çš„ä¼˜åŒ–æ¨¡å¼: {mode}")
    
    def _light_optimization(
        self,
        strategy_id: str,
        trigger: Trigger
    ) -> OptimizationResult:
        """è½»é‡çº§ä¼˜åŒ–ï¼šå‚æ•°å¾®è°ƒ"""
        # è·å–å½“å‰ç­–ç•¥
        current_strategy = self._get_strategy(strategy_id)
        
        # å‚æ•°ä¼˜åŒ–
        optimized_params = self._optimize_parameters(current_strategy, trigger)
        
        # ç”Ÿæˆä¼˜åŒ–åçš„ç­–ç•¥
        optimized_strategy = self._generate_optimized_strategy(
            current_strategy,
            optimized_params
        )
        
        # å›æµ‹éªŒè¯
        backtest_result = self._backtest_strategy(optimized_strategy)
        
        return OptimizationResult(
            strategy_id=strategy_id,
            optimized_strategy_id=optimized_strategy['id'],
            mode=OptimizationMode.LIGHT,
            changes={'parameters': optimized_params},
            backtest_result=backtest_result
        )
    
    def _medium_optimization(
        self,
        strategy_id: str,
        trigger: Trigger
    ) -> OptimizationResult:
        """ä¸­ç­‰ä¼˜åŒ–ï¼šå› å­è°ƒæ•´"""
        # è·å–å½“å‰ç­–ç•¥
        current_strategy = self._get_strategy(strategy_id)
        
        # å› å­é‡æ–°ç­›é€‰
        optimized_factors = self._reoptimize_factors(current_strategy, trigger)
        
        # ç”Ÿæˆä¼˜åŒ–åçš„ç­–ç•¥
        optimized_strategy = self._generate_optimized_strategy(
            current_strategy,
            {'factors': optimized_factors}
        )
        
        # å›æµ‹éªŒè¯
        backtest_result = self._backtest_strategy(optimized_strategy)
        
        return OptimizationResult(
            strategy_id=strategy_id,
            optimized_strategy_id=optimized_strategy['id'],
            mode=OptimizationMode.MEDIUM,
            changes={'factors': optimized_factors},
            backtest_result=backtest_result
        )
    
    def _heavy_optimization(
        self,
        strategy_id: str,
        trigger: Trigger
    ) -> OptimizationResult:
        """ä¸¥é‡ä¼˜åŒ–ï¼šç­–ç•¥é‡æ„"""
        # ç­–ç•¥é™çº§/åœç”¨
        # åˆ‡æ¢åˆ°å®‰å…¨ç­–ç•¥æ¨¡æ¿
        safe_strategy = self._get_safe_strategy_template()
        
        return OptimizationResult(
            strategy_id=strategy_id,
            optimized_strategy_id=safe_strategy['id'],
            mode=OptimizationMode.HEAVY,
       <CodeFromFile 
  filePath="code_library/009_Chapter9_Platform_Integration/9.7/code_9_7___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
# core/live_feedback/safety_gate.py
from typing import Dict, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import hashlib
import secrets
import logging

logger = logging.getLogger(__name__)

@dataclass
class ConfirmToken:
    """ç¡®è®¤ä»¤ç‰Œ"""
    token: str
    tool_name: str
    params_hash: str
    trace_id: str
    expires_at: datetime
    created_at: datetime

class SafetyGate:
    """ä¸Šçº¿é—¨ç¦ç³»ç»Ÿ"""
    
    def __init__(self, evidence_server=None):
        """
        åˆå§‹åŒ–é—¨ç¦ç³»ç»Ÿ
        
        Args:
            evidence_server: è¯æ®æœåŠ¡å™¨
        """
        self.evidence_server = evidence_server
        self.tokens: Dict[str, ConfirmToken] = {}
    
    def generate_confirm_token(
        self,
        tool_name: str,
        params: Dict,
        trace_id: str,
        expires_in_minutes: int = 30
    ) -> str:
        """
        ç”Ÿæˆç¡®è®¤ä»¤ç‰Œ
        
        Args:
            tool_name: å·¥å…·åç§°
            params: å‚æ•°
            trace_id: è¿½è¸ªID
            expires_in_minutes: è¿‡æœŸæ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
        
        Returns:
            str: ç¡®è®¤ä»¤ç‰Œ
        """
        # è®¡ç®—å‚æ•°hash
        params_str = str(sorted(params.items()))
        params_hash = hashlib.sha256(params_str.encode()).hexdigest()
        
        # ç”Ÿæˆä»¤ç‰Œ
        token = secrets.token_urlsafe(32)
        
        # åˆ›å»ºä»¤ç‰Œå¯¹è±¡
        now = datetime.now()
        confirm_token = ConfirmToken(
            token=token,
            tool_name=tool_name,
            params_hash=params_hash,
            trace_id=trace_id,
            expires_at=now + timedelta(minutes=expires_in_minutes),
            created_at=now
        )
        
        # ä¿å­˜ä»¤ç‰Œ
        self.tokens[token] = confirm_token
        
        logger.info(f"ç”Ÿæˆç¡®è®¤ä»¤ç‰Œ: {token[:8]}...")
        
        return token
    
    def validate_token(
        self,
        token: str,
        tool_name: str,
        params: Dict
    ) -> bool:
        """
        éªŒè¯ä»¤ç‰Œ
        
        Args:
            token: ç¡®è®¤ä»¤ç‰Œ
            tool_name: å·¥å…·åç§°
            params: å‚æ•°
        
        Returns:
            bool: æ˜¯å¦æœ‰æ•ˆ
        """
        if token not in self.tokens:
            logger.warning(f"ä»¤ç‰Œä¸å­˜åœ¨: {token[:8]}...")
            return False
        
        confirm_token = self.tokens[token]
        
        # æ£€æŸ¥è¿‡æœŸ
        if datetime.now() > confirm_token.expires_at:
            logger.warning(f"ä»¤ç‰Œå·²è¿‡æœŸ: {token[:8]}...")
            del self.tokens[token]
            return False
        
        # æ£€æŸ¥å·¥å…·åç§°
        if confirm_token.tool_name != tool_name:
            logger.warning(f"å·¥å…·åç§°ä¸åŒ¹é…: {tool_name} != {confirm_token.tool_name}")
            return False
        
        # æ£€æŸ¥å‚æ•°hash
        params_str = str(sorted(params.items()))
        params_hash = hashlib.sha256(params_str.encode()).hexdigest()
        if confirm_token.params_hash != params_hash:
            logger.warning(f"å‚æ•°hashä¸åŒ¹é…")
            return False
        
        return True
    
    def record_evidence(
        self,
        operation: str,
        operator: str,
        reason: str,
        scope: str,
        rollback: str,
        token: Optional[str] = None
    ):
        """
        è®°å½•è¯æ®
        
        Args:
            operation: æ“ä½œåç§°
            operator: æ“ä½œäºº
            reason: åŸå› 
            scope: å½±å“èŒƒå›´
            rollback: å›æ»šæ–¹æ¡ˆ
            token: ç¡®è®¤ä»¤ç‰Œï¼ˆå¯é€‰ï¼‰
        """
        evidence = {
            'operation': operation,
            'operator': operator,
            'timestamp': datetime.now().isoformat(),
            'reason': reason,
            'scope': scope,
            'rollback': rollback,
            'token': token
        }
        
        if self.evidence_server:
            self<CodeFromFile 
  filePath="code_library/009_Chapter9_Platform_Integration/9.7/code_9_7___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
# core/live_feedback/feedback_loop.py
from typing import Dict, Optional
from datetime import datetime
import logging

from core.live_feedback.data_collector import LiveDataCollector
from core.live_feedback.anomaly_detector import AnomalyDetector
from core.live_feedback.trigger_manager import TriggerManager
from core.live_feedback.optimizer import OnlineOptimizer
from core.live_feedback.safety_gate import SafetyGate

logger = logging.getLogger(__name__)

class FeedbackLoopManager:
    """åé¦ˆé—­ç¯ç®¡ç†å™¨"""
    
    def __init__(
        self,
        data_collector: LiveDataCollector,
        anomaly_detector: AnomalyDetector,
        trigger_manager: TriggerManager,
        optimizer: OnlineOptimizer,
        safety_gate: SafetyGate
    ):
        """
        åˆå§‹åŒ–åé¦ˆé—­ç¯ç®¡ç†å™¨
        
        Args:
            data_collector: æ•°æ®æ”¶é›†å™¨
            anomaly_detector: å¼‚å¸¸æ£€æµ‹å™¨
            trigger_manager: è§¦å‘å™¨ç®¡ç†å™¨
            optimizer: ä¼˜åŒ–å¼•æ“
            safety_gate: å®‰å…¨é—¨ç¦
        """
        self.data_collector = data_collector
        self.anomaly_detector = anomaly_detector
        self.trigger_manager = trigger_manager
        self.optimizer = optimizer
        self.safety_gate = safety_gate
    
    def run_feedback_loop(
        self,
        strategy_id: str,
        date: datetime
    ) -> Dict:
        """
        è¿è¡Œåé¦ˆé—­ç¯
        
        Args:
            strategy_id: ç­–ç•¥ID
            date: æ—¥æœŸ
        
        Returns:
            Dict: åé¦ˆé—­ç¯ç»“æœ
        """
        logger.info(f"è¿è¡Œåé¦ˆé—­ç¯: {strategy_id}, {date}")
        
        # 1. æ”¶é›†å®ç›˜æ•°æ®
        metrics = self.data_collector.collect_performance_metrics(strategy_id, date)
        if not metrics:
            return {'success': False, 'error': 'æ— æ³•æ”¶é›†æ€§èƒ½æŒ‡æ ‡'}
        
        # 2. æ£€æµ‹å¼‚å¸¸
        anomalies = self.anomaly_detector.detect_anomalies(strategy_id, date)
        
        # 3. æ£€æŸ¥è§¦å‘å™¨
        triggered = self.trigger_manager.check_triggers(strategy_id, date)
        
        if not triggered:
            return {
                'success': True,
                'action': 'monitor',
                'metrics': metrics,
                'anomalies': [a.message for a in anomalies]
            }
        
        # 4. è§¦å‘å†ä¼˜åŒ–
        optimization_results = []
        for trigger in triggered:
            # æ ¹æ®è§¦å‘å™¨ç±»å‹é€‰æ‹©ä¼˜åŒ–æ¨¡å¼
            mode = self._determine_optimization_mode(trigger, anomalies)
            
            # æ‰§è¡Œä¼˜åŒ–ï¼ˆdry_runæ¨¡å¼ï¼‰
            result = self.optimizer.optimize_strategy(
                strategy_id,
                trigger,
                mode
            )
            
            optimization_results.append(result)
        
        return {
            'success': True,
            'action': 'optimize',
            'metrics': metrics,
            'anomalies': [a.message for a in anomalies],
            'triggers': [t.trigger_id for t in triggered],
            'optimization_results': [
                {
                    'optimized_strategy_id': r.optimized_strategy_id,
                    'mode': r.mode.value,
                    'recommendation': r.recommendation
                }
                for r in optimization_results
            ]
        }
    
    def deploy_optimized_strategy(
        self,
        strategy_id: str,
        optimized_strategy_id: str,
        confirm_token: str,
        operator: str,
        reason: str
    ) -> bool:
        """
        éƒ¨ç½²ä¼˜åŒ–åçš„ç­–ç•¥
        
        Args:
            strategy_id: åŸç­–ç•¥ID
            optimized_strategy_id: ä¼˜åŒ–åçš„ç­–ç•¥ID
            confirm_token: ç¡®è®¤ä»¤ç‰Œ
            operator: æ“ä½œäºº
            reason: åŸå› 
        
        Returns:
            bool: æ˜¯å¦æˆåŠŸ
        """
        # éªŒè¯ä»¤ç‰Œ
        if not self.safety_gate.validate_token(
            confirm_token,
            'deploy_strategy',
            {'strategy_id': strategy_id, 'optimized_strategy_id': optimized_strategy_id}
        ):
            logger.error("ç¡®è®¤ä»¤ç‰ŒéªŒè¯å¤±è´¥")
            return False
        
        # è®°å½•è¯æ®
        self.safety_gate.record_evidence(
            operation='deploy_strategy',
            operator=operator,
            reason=reason,
            scope=f"ç­–ç•¥ {strategy_id} -> {optimized_strategy_id}",
            rollback=f"å›é€€åˆ°ç­–ç•¥ {strategy_id}",
            token=confirm_token
        )
        
        # æ‰§è¡Œéƒ¨ç½²ï¼ˆå®é™…å®ç°éœ€è¦è°ƒç”¨éƒ¨ç½²ç³»ç»Ÿï¼‰
        logger.info(f"éƒ¨ç½²ä¼˜åŒ–åçš„ç­–ç•¥: {optimized_strategy_id}")
        
        return True
    
    def _determine_optimization_mode(self, trigger, anomalies):
        """æ ¹æ®è§¦å‘å™¨å’Œå¼‚å¸¸ç¡®å®šä¼˜åŒ–æ¨¡å¼"""
        # å¦‚æœæœ‰ä¸¥é‡å¼‚å¸¸ï¼Œä½¿ç”¨ä¸¥é‡æ¨¡å¼
        critical_anomalies = [a for a in anomalies if a.severity == "critical"]
        if critical_anomalies:
            return OptimizationMode.HEAVY
        
        # å¦‚æœè§¦å‘å™¨æ˜¯æ•°æ®è§¦å‘å™¨ï¼Œä½¿ç”¨ä¸­ç­‰æ¨¡å¼
        if trigger.trigger_type == TriggerType.DATA:
            return OptimizationMode.MEDIUM
        
        # é»˜è®¤ä½¿ç”¨è½»é‡çº§æ¨¡å¼
        return OptimizationMode.LIGHT
```
-->afety_gate.record_evidence(
            operation='deploy_strategy',
            operator=operator,
            reason=reason,
            scope=f"ç­–ç•¥ {strategy_id} -> {optimized_strategy_id}",
            rollback=f"å›é€€åˆ°ç­–ç•¥ {strategy_id}",
            token=confirm_token
        )
        
        # æ‰§è¡Œéƒ¨ç½²ï¼ˆå®é™…å®ç°éœ€è¦è°ƒç”¨éƒ¨ç½²ç³»ç»Ÿï¼‰
        logger.info(f"éƒ¨ç½²ä¼˜åŒ–åçš„ç­–ç•¥: {optimized_strategy_id}")
        
        return True
    
    def _determine_optimization_mode(self, trigger, anomalies):
        """æ ¹æ®è§¦å‘å™¨å’Œå¼‚å¸¸ç¡®å®šä¼˜åŒ–æ¨¡å¼"""
        # å¦‚æœæœ‰ä¸¥é‡å¼‚å¸¸ï¼Œä½¿ç”¨ä¸¥é‡æ¨¡å¼
        critical_anomalies = [a for a in anomalies if a.severity == "critical"]
        if critical_anomalies:
            return OptimizationMode.HEAVY
        
        # å¦‚æœè§¦å‘å™¨æ˜¯æ•°æ®è§¦å‘å™¨ï¼Œä½¿ç”¨ä¸­ç­‰æ¨¡å¼
        if trigger.trigger_type == TriggerType.DATA:
            return OptimizationMode.MEDIUM
        
        # é»˜è®¤ä½¿ç”¨è½»é‡çº§æ¨¡å¼
        return OptimizationMode.LIGHT
```

## ğŸ”— ç›¸å…³ç« èŠ‚

- **ç¬¬7ç« ï¼šç­–ç•¥å¼€å‘**ï¼šäº†è§£ç­–ç•¥å¼€å‘å’Œä¼˜åŒ–æµç¨‹
- **ç¬¬8ç« ï¼šå›æµ‹éªŒè¯**ï¼šäº†è§£BulletTradeå›æµ‹å’Œç­–ç•¥éªŒè¯
- **9.6 å®ç›˜äº¤æ˜“ç®¡ç†**ï¼šäº†è§£å®ç›˜äº¤æ˜“ç®¡ç†
- **ç¬¬10ç« ï¼šå¼€å‘æŒ‡å—**ï¼šäº†è§£åé¦ˆé—­ç¯ç³»ç»Ÿçš„å¼€å‘æ–¹æ³•

## ğŸ’¡ å…³é”®è¦ç‚¹

1. **å®ç›˜åé¦ˆ**ï¼šå®Œæ•´çš„å®ç›˜æ•°æ®æ”¶é›†å’Œæ€§èƒ½ç›‘æ§
2. **è§¦å‘å™¨æœºåˆ¶**ï¼šçµæ´»çš„è§¦å‘å™¨é…ç½®å’Œæ¡ä»¶åˆ¤æ–­
3. **åœ¨çº¿ä¼˜åŒ–**ï¼šå¤šå±‚æ¬¡çš„ä¼˜åŒ–ç­–ç•¥å’Œæ¨¡å¼é€‰æ‹©
4. **å®‰å…¨ç­–ç•¥**ï¼šä¸¥æ ¼çš„ä¸Šçº¿é—¨ç¦å’Œè¯æ®è®°å½•
5. **åé¦ˆé—­ç¯**ï¼šå®Œæ•´çš„ä»ç›‘æ§åˆ°ä¼˜åŒ–çš„é—­ç¯æµç¨‹

## ğŸ”® æ€»ç»“ä¸å±•æœ›

<div class="summary-outlook">
  <h3>æœ¬èŠ‚å›é¡¾</h3>
  <p>æœ¬èŠ‚ç³»ç»Ÿä»‹ç»äº†å®ç›˜åé¦ˆä¸åœ¨çº¿å†ä¼˜åŒ–ç³»ç»Ÿï¼ŒåŒ…æ‹¬å®ç›˜åé¦ˆæœºåˆ¶ã€è§¦å‘å™¨æœºåˆ¶ã€åœ¨çº¿å†ä¼˜åŒ–æµç¨‹ã€å®‰å…¨ç­–ç•¥å’Œåé¦ˆé—­ç¯è®¾è®¡ã€‚é€šè¿‡ç†è§£å®ç›˜åé¦ˆçš„å®Œæ•´æœºåˆ¶ï¼Œå¸®åŠ©å¼€å‘è€…æŒæ¡å¦‚ä½•å®ç°ç­–ç•¥çš„æŒç»­ä¼˜åŒ–ï¼Œå½¢æˆç­–ç•¥ç”Ÿæˆâ†’ä¼˜åŒ–â†’å›æµ‹â†’å®ç›˜â†’å†ä¼˜åŒ–çš„å®Œæ•´é—­ç¯ã€‚</p>
  
  <h3>ä¸‹èŠ‚é¢„å‘Š</h3>
  <p>æŒæ¡äº†å¹³å°é›†æˆæ¨¡å—åï¼Œä¸‹ä¸€ç« å°†ä»‹ç»å¼€å‘æŒ‡å—ï¼ŒåŒ…æ‹¬ç¯å¢ƒæ­å»ºã€å¼€å‘åŸåˆ™ã€å¼€å‘å·¥ä½œæµã€å·¥å…·é“¾ä½¿ç”¨å’Œæœ€ä½³å®è·µã€‚é€šè¿‡ç†è§£å¼€å‘æŒ‡å—çš„æ ¸å¿ƒå†…å®¹ï¼Œå¸®åŠ©å¼€å‘è€…æŒæ¡ç³»ç»Ÿå¼€å‘çš„å…·ä½“æ–¹æ³•å’Œå·¥å…·é“¾ä½¿ç”¨ã€‚</p>
  
  <a href="/ashare-book6/010_Chapter10_Development_Guide/010_Chapter10_Development_Guide_CN" class="next-section">
    ç»§ç»­å­¦ä¹ ï¼šç¬¬10ç« ï¼šå¼€å‘æŒ‡å— â†’
  </a>
</div>

> **é€‚ç”¨ç‰ˆæœ¬**: v1.0.0+  
> **æœ€åæ›´æ–°**: 2025-12-12
<!-- Code updated: 2025-12-14T02:17:26.193Z -->
