---
title: "9.6 å®ç›˜äº¤æ˜“ç®¡ç†"
description: "æ·±å…¥è§£æå®ç›˜äº¤æ˜“ç®¡ç†ç³»ç»Ÿï¼ŒåŒ…æ‹¬ç­–ç•¥éƒ¨ç½²ã€äº¤æ˜“æ‰§è¡Œã€é£é™©ç›‘æ§ã€æŒä»“ç®¡ç†ç­‰æ ¸å¿ƒæŠ€æœ¯ï¼Œä¸ºé‡åŒ–æŠ•èµ„ç³»ç»Ÿæä¾›å®Œæ•´çš„å®ç›˜äº¤æ˜“ç®¡ç†èƒ½åŠ›"
lang: "zh-CN"
layout: "/src/layouts/HandbookLayout.astro"
currentBook: "ashare-book6"
updateDate: "2025-12-12"
---

# ğŸ’¼ 9.6 å®ç›˜äº¤æ˜“ç®¡ç†

> **æ ¸å¿ƒæ‘˜è¦ï¼š**
> 
> æœ¬èŠ‚ç³»ç»Ÿä»‹ç»TRQuantç³»ç»Ÿçš„å®ç›˜äº¤æ˜“ç®¡ç†ç³»ç»Ÿï¼ŒåŒ…æ‹¬ç­–ç•¥éƒ¨ç½²ã€äº¤æ˜“æ‰§è¡Œã€é£é™©ç›‘æ§å’ŒæŒä»“ç®¡ç†ã€‚é€šè¿‡ç†è§£å®ç›˜äº¤æ˜“ç®¡ç†å™¨çš„æ ¸å¿ƒå®ç°ï¼Œå¸®åŠ©å¼€å‘è€…æŒæ¡å¦‚ä½•å°†ç»è¿‡BulletTradeå›æµ‹éªŒè¯çš„ç­–ç•¥éƒ¨ç½²åˆ°å®ç›˜ç¯å¢ƒï¼Œå®ç°è‡ªåŠ¨åŒ–äº¤æ˜“æ‰§è¡Œã€å®æ—¶é£é™©ç›‘æ§å’ŒæŒä»“ç®¡ç†ï¼Œä¸ºæ„å»ºä¸“ä¸šçº§çš„å®ç›˜äº¤æ˜“ç³»ç»Ÿå¥ å®šåŸºç¡€ã€‚

å®ç›˜äº¤æ˜“ç®¡ç†æ˜¯å¹³å°é›†æˆçš„æ ¸å¿ƒç¯èŠ‚ï¼Œè´Ÿè´£å°†éªŒè¯é€šè¿‡çš„ç­–ç•¥éƒ¨ç½²åˆ°å®ç›˜ç¯å¢ƒï¼Œå®ç°è‡ªåŠ¨åŒ–äº¤æ˜“æ‰§è¡Œå’Œå®æ—¶ç›‘æ§ã€‚

## ğŸ“‹ ç« èŠ‚æ¦‚è§ˆ

<script>
function scrollToSection(sectionId) {
  const element = document.getElementById(sectionId);
  if (element) {
    const headerOffset = 100;
    const elementPosition = element.getBoundingClientRect().top;
    const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
    window.scrollTo({
      top: offsetPosition,
      behavior: 'smooth'
    });
  }
}
</script>

<div class="section-overview">
  <div class="section-item" onclick="scrollToSection('section-9-6-1')">
    <h4>ğŸš€ 9.6.1 ç­–ç•¥éƒ¨ç½²ç®¡ç†</h4>
    <p>ç­–ç•¥éƒ¨ç½²ã€ç‰ˆæœ¬ç®¡ç†ã€éƒ¨ç½²éªŒè¯ã€å›æ»šæœºåˆ¶</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-9-6-2')">
    <h4>ğŸ’¹ 9.6.2 äº¤æ˜“æ‰§è¡Œç®¡ç†</h4>
    <p>è®¢å•ç”Ÿæˆã€è®¢å•æ‰§è¡Œã€æ‰§è¡Œç›‘æ§ã€å¼‚å¸¸å¤„ç†</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-9-6-3')">
    <h4>ğŸ›¡ï¸ 9.6.3 é£é™©ç›‘æ§ç®¡ç†</h4>
    <p>å®æ—¶é£æ§ã€é£é™©æŒ‡æ ‡ç›‘æ§ã€é£æ§è§„åˆ™æ‰§è¡Œã€å‘Šè­¦æœºåˆ¶</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-9-6-4')">
    <h4>ğŸ“Š 9.6.4 æŒä»“ç®¡ç†</h4>
    <p>æŒä»“æŸ¥è¯¢ã€æŒä»“åŒæ­¥ã€æŒä»“åˆ†æã€æŒä»“è°ƒæ•´</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-9-6-5')">
    <h4>ğŸ”„ 9.6.5 äº¤æ˜“æ•°æ®ç®¡ç†</h4>
    <p>äº¤æ˜“è®°å½•ã€æ•°æ®å­˜å‚¨ã€æ•°æ®åŒæ­¥ã€æ•°æ®æŸ¥è¯¢</p>
  </div>
</div>

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬èŠ‚å­¦ä¹ ï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- **ç®¡ç†ç­–ç•¥éƒ¨ç½²**ï¼šæŒæ¡ç­–ç•¥éƒ¨ç½²ã€ç‰ˆæœ¬ç®¡ç†å’Œå›æ»šæœºåˆ¶
- **æ‰§è¡Œäº¤æ˜“ç®¡ç†**ï¼šç†è§£è®¢å•ç”Ÿæˆã€æ‰§è¡Œç›‘æ§å’Œå¼‚å¸¸å¤„ç†
- **å®ç°é£é™©ç›‘æ§**ï¼šæŒæ¡å®æ—¶é£æ§ã€é£é™©æŒ‡æ ‡ç›‘æ§å’Œå‘Šè­¦æœºåˆ¶
- **ç®¡ç†æŒä»“**ï¼šç†è§£æŒä»“æŸ¥è¯¢ã€åŒæ­¥ã€åˆ†æå’Œè°ƒæ•´
- **ç®¡ç†äº¤æ˜“æ•°æ®**ï¼šæŒæ¡äº¤æ˜“è®°å½•å­˜å‚¨ã€åŒæ­¥å’ŒæŸ¥è¯¢

## ğŸ“š æ ¸å¿ƒæ¦‚å¿µ

### æ¨¡å—å®šä½

- **å·¥ä½œæµä½ç½®**ï¼šæ­¥éª¤8 - ğŸš€ å®ç›˜äº¤æ˜“ï¼ˆå®ç›˜äº¤æ˜“ç®¡ç†ï¼‰
- **æ ¸å¿ƒèŒè´£**ï¼šç­–ç•¥éƒ¨ç½²ã€äº¤æ˜“æ‰§è¡Œã€é£é™©ç›‘æ§ã€æŒä»“ç®¡ç†
- **æœåŠ¡å¯¹è±¡**ï¼šç»è¿‡BulletTradeå›æµ‹éªŒè¯çš„ç­–ç•¥

### æŠ€æœ¯æ ˆ

- **äº¤æ˜“å¹³å°**ï¼šPTrade/QMTï¼ˆå›½é‡‘è¯åˆ¸ï¼‰
- **æ•°æ®å­˜å‚¨**ï¼šPostgreSQLï¼ˆäº¤æ˜“è®°å½•ã€æŒä»“æ•°æ®ï¼‰ã€Redisï¼ˆå®æ—¶çŠ¶æ€ï¼‰
- **ç›‘æ§ç³»ç»Ÿ**ï¼šå®æ—¶ç›‘æ§ã€å‘Šè­¦ç³»ç»Ÿ
- **æ•°æ®åŒæ­¥**ï¼šå®ç›˜æ•°æ®å›æµåˆ°éŸ¬ç¿ç³»ç»Ÿ

### ä¸å‰åç« èŠ‚çš„è¡”æ¥

- **ç¬¬8ç« **ï¼šæ¥æ”¶ç»è¿‡BulletTradeå›æµ‹éªŒè¯çš„ç­–ç•¥
- **9.1/9.2**ï¼šä½¿ç”¨PTrade/QMTå¹³å°è¿›è¡Œç­–ç•¥éƒ¨ç½²å’Œäº¤æ˜“æ‰§è¡Œ
- **9.7**ï¼šå®ç›˜äº¤æ˜“æ•°æ®åé¦ˆç»™ç­–ç•¥ä¼˜åŒ–ç³»ç»Ÿ

<h2 id="section-9-6-1">ğŸš€ 9.6.1 ç­–ç•¥éƒ¨ç½²ç®¡ç†</h2>

ç­–ç•¥éƒ¨ç½²ç®¡ç†è´Ÿè´£å°†ç»è¿‡BulletTradeå›æµ‹éªŒè¯çš„ç­–ç•¥éƒ¨ç½²åˆ°å®ç›˜ç¯å¢ƒï¼ŒåŒ…æ‹¬ç‰ˆæœ¬ç®¡ç†ã€éƒ¨ç½²éªŒè¯å’Œå›æ»šæœºåˆ¶ã€‚

### ç­–ç•¥éƒ¨ç½²å™¨

<CodeFromFile 
  filePath="code_library/009_Chapter9_Platform_Integration/9.6/code_9_6___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
from dataclasses import dataclass
from typing import Dict, Any, List, Optional
from datetime import datetime
from enum import Enum
import json
from pathlib import Path

class DeploymentStatus(Enum):
    """éƒ¨ç½²çŠ¶æ€"""
    PENDING = "pending"          # å¾…éƒ¨ç½²
    DEPLOYING = "deploying"      # éƒ¨ç½²ä¸­
    DEPLOYED = "deployed"        # å·²éƒ¨ç½²
    FAILED = "failed"            # éƒ¨ç½²å¤±è´¥
    ROLLED_BACK = "rolled_back"  # å·²å›æ»š

@dataclass
class StrategyDeployment:
    """ç­–ç•¥éƒ¨ç½²ä¿¡æ¯"""
    strategy_id: str
    strategy_name: str
    version: str
    platform: str  # "ptrade" or "qmt"
    deployment_time: datetime
    status: DeploymentStatus
    config: Dict[str, Any]
    backtest_result: Optional[Dict[str, Any]] = None

class LiveTradingManager:
    """å®ç›˜äº¤æ˜“ç®¡ç†å™¨"""
    
    def __init__(
        self,
        ptrade_integration=None,
        qmt_integration=None,
        db_connection=None
    ):
        """
        åˆå§‹åŒ–å®ç›˜äº¤æ˜“ç®¡ç†å™¨
        
        Args:
            ptrade_integration: PTradeé›†æˆå¯¹è±¡
            qmt_integration: QMTé›†æˆå¯¹è±¡
            db_connection: æ•°æ®åº“è¿æ¥
        """
        self.ptrade = ptrade_integration
        self.qmt = qmt_integration
        self.db = db_connection
        self.deployments: Dict[str, StrategyDeployment] = {}
    
    def deploy_strategy(
        self,
        strategy_id: str,
        strategy_name: str,
        strategy_code: str,
        platform: str,
        backtest_result: Dict[str, Any],
        config: Dict[str, Any]
    ) -> StrategyDeployment:
        """
        éƒ¨ç½²ç­–ç•¥åˆ°å®ç›˜ç¯å¢ƒ
        
        Args:
            strategy_id: ç­–ç•¥ID
            strategy_name: ç­–ç•¥åç§°
            strategy_code: ç­–ç•¥ä»£ç ï¼ˆèšå®½é£æ ¼ï¼‰
            platform: äº¤æ˜“å¹³å°ï¼ˆ"ptrade" or "qmt"ï¼‰
            backtest_result: BulletTradeå›æµ‹ç»“æœ
            config: éƒ¨ç½²é…ç½®
        
        Returns:
            StrategyDeployment: éƒ¨ç½²ä¿¡æ¯
        """
        # 1. éªŒè¯å›æµ‹ç»“æœ
        if not self._validate_backtest_result(backtest_result):
            raise ValueError("å›æµ‹ç»“æœéªŒè¯å¤±è´¥ï¼Œä¸æ»¡è¶³éƒ¨ç½²æ¡ä»¶")
        
        # 2. åˆ›å»ºéƒ¨ç½²è®°å½•
        deployment = StrategyDeployment(
            strategy_id=strategy_id,
            strategy_name=strategy_name,
            version=config.get('version', '1.0.0'),
            platform=platform,
            deployment_time=datetime.now(),
            status=DeploymentStatus.PENDING,
            config=config,
            backtest_result=backtest_result
        )
        
        # 3. æ ¹æ®å¹³å°é€‰æ‹©éƒ¨ç½²å™¨
        if platform == "ptrade":
            deployer = self.ptrade
        elif platform == "qmt":
            deployer = self.qmt
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„å¹³å°: {platform}")
        
        # 4. æ‰§è¡Œéƒ¨ç½²
        try:
            deployment.status = DeploymentStatus.DEPLOYING
            
            # è½¬æ¢ç­–ç•¥ä»£ç ï¼ˆèšå®½é£æ ¼ â†’ å¹³å°æ ¼å¼ï¼‰
            platform_code = deployer.convert_strategy_code(strategy_code)
            
            # ä¸Šä¼ ç­–ç•¥åˆ°å¹³å°
            upload_result = deployer.upload_strategy(
                strategy_name=strategy_name,
                strategy_code=platform_code,
                config=config
            )
            
            if upload_result.get('success'):
                deployment.status = DeploymentStatus.DEPLOYED
                # ä¿å­˜éƒ¨ç½²è®°å½•åˆ°æ•°æ®åº“
                self._save_deployment(deployment)
                self.deployments[strategy_id] = deployment
                return deployment
            else:
                deployment.status = DeploymentStatus.FAILED
                raise Exception(f"ç­–ç•¥éƒ¨ç½²å¤±è´¥: {upload_result.get('error')}")
                
        except Exception as e:
            deployment.status = DeploymentStatus.FAILED
            self._save_deployment(deployment)
            raise
    
    def _validate_backtest_result(
        self,
        backtest_result: Dict[str, Any]
    ) -> bool:
        """
        éªŒè¯å›æµ‹ç»“æœæ˜¯å¦æ»¡è¶³éƒ¨ç½²æ¡ä»¶
        
        Args:
            backtest_result: BulletTradeå›æµ‹ç»“æœ
        
        Returns:
            bool: æ˜¯å¦æ»¡è¶³éƒ¨ç½²æ¡ä»¶
        """
        # æ£€æŸ¥å¿…éœ€æŒ‡æ ‡
        required_metrics = ['sharpe_ratio', 'max_drawdown', 'annual_return']
        for metric in required_metrics:
            if metric not in backtest_result:
                return False
        
        # æ£€æŸ¥æ€§èƒ½é˜ˆå€¼
        sharpe = backtest_result.get('sharpe_ratio', 0)
        max_dd = backtest_result.get('max_drawdown', 1.0)
        annual_return = backtest_result.get('annual_return', 0)
        
        # éƒ¨ç½²æ¡ä»¶ï¼šå¤æ™®æ¯”ç‡ > 1.0ï¼Œæœ€å¤§å›æ’¤ < 20%ï¼Œå¹´åŒ–æ”¶ç›Š > 5%
        if sharpe > 1.0 and max_dd < 0.20 and annual_return > 0.05:
            return True
        
        return False
    
    def rollback_strategy(
        self,
        strategy_id: str
    ) -> bool:
        """
        å›æ»šç­–ç•¥éƒ¨ç½²
        
        Args:
            strategy_id: ç­–ç•¥ID
        
        Returns:
            bool: å›æ»šæ˜¯å¦æˆåŠŸ
        """
        if strategy_id not in self.deployments:
            raise ValueError(f"ç­–ç•¥ {strategy_id} æœªéƒ¨ç½²")
        
        deployment = self.deployments[strategy_id]
        
        try:
            # æ ¹æ®å¹³å°é€‰æ‹©éƒ¨ç½²å™¨
            if deployment.platform == "ptrade":
                deployer = self.ptrade
            elif deployment.platform == "qmt":
                deployer = self.qmt
            else:
                raise ValueError(f"ä¸æ”¯æŒçš„å¹³å°: {deployment.platform}")
            
            # åœæ­¢ç­–ç•¥
            deployer.stop_strategy(deployment.strategy_name)
            
            # æ›´æ–°éƒ¨ç½²çŠ¶æ€
            deployment.status = DeploymentStatus.ROLLED_BACK
            self._save_deployment(deployment)
            
            return True
            
        except Exception as e:
            logger.error(f"ç­–ç•¥å›æ»šå¤±è´¥: {e}")
            return False
    
    def _save_deployment(self, deployment: StrategyDeployment):
        """ä¿å­˜éƒ¨ç½²è®°å½•åˆ°æ•°æ®åº“"""
        # ä¿å­˜åˆ°PostgreSQL
        if self.db:
            self.db.execute(
                """
                INSERT INTO strategy_deployments 
                (strategy_id, strategy_name, version, platform, 
                 deployment_time, status, config, backtest_result)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                ON CONFLICT (strategy_id) 
                DO UPDATE SET 
                    status = EXCLUDED.status,
                    deployment_time = EXCLUDED.deployment_time
                """,
                (
                    deployment.strategy_id,
                    deployment.strategy_name,
                    deployment.version,
                    deployment.platform,
                    deployment.deployment_time,
                    deployment.status.value,
                    json.dumps(deployment.config),
                    json.dumps(deployment.b<CodeFromFile 
  filePath="code_library/009_Chapter9_Platform_Integration/9.6/code_9_6___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
from typing import List, Optional
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Order:
    """è®¢å•ä¿¡æ¯"""
    order_id: str
    strategy_id: str
    symbol: str
    side: str  # "buy" or "sell"
    quantity: int
    price: float
    order_type: str  # "market" or "limit"
    status: str  # "pending", "submitted", "filled", "cancelled", "rejected"
    submit_time: datetime
    fill_time: Optional[datetime] = None
    fill_price: Optional[float] = None
    fill_quantity: Optional[int] = None

class TradeExecutor:
    """äº¤æ˜“æ‰§è¡Œå™¨"""
    
    def __init__(
        self,
        live_trading_manager: LiveTradingManager,
        ptrade_trader=None,
        qmt_trader=None
    ):
        """
        åˆå§‹åŒ–äº¤æ˜“æ‰§è¡Œå™¨
        
        Args:
            live_trading_manager: å®ç›˜äº¤æ˜“ç®¡ç†å™¨
            ptrade_trader: PTradeäº¤æ˜“æ¥å£
            qmt_trader: QMTäº¤æ˜“æ¥å£
        """
        self.manager = live_trading_manager
        self.ptrade_trader = ptrade_trader
        self.qmt_trader = qmt_trader
        self.orders: Dict[str, Order] = {}
    
    def execute_order(
        self,
        strategy_id: str,
        symbol: str,
        side: str,
        quantity: int,
        price: float = None,
        order_type: str = "limit"
    ) -> Order:
        """
        æ‰§è¡Œè®¢å•
        
        Args:
            strategy_id: ç­–ç•¥ID
            symbol: è‚¡ç¥¨ä»£ç 
            side: ä¹°å–æ–¹å‘ï¼ˆ"buy" or "sell"ï¼‰
            quantity: æ•°é‡
            price: ä»·æ ¼ï¼ˆé™ä»·å•å¿…éœ€ï¼‰
            order_type: è®¢å•ç±»å‹ï¼ˆ"market" or "limit"ï¼‰
        
        Returns:
            Order: è®¢å•ä¿¡æ¯
        """
        # 1. è·å–ç­–ç•¥éƒ¨ç½²ä¿¡æ¯
        if strategy_id not in self.manager.deployments:
            raise ValueError(f"ç­–ç•¥ {strategy_id} æœªéƒ¨ç½²")
        
        deployment = self.manager.deployments[strategy_id]
        
        # 2. åˆ›å»ºè®¢å•
        order = Order(
            order_id=f"order_{datetime.now().timestamp()}",
            strategy_id=strategy_id,
            symbol=symbol,
            side=side,
            quantity=quantity,
            price=price or 0.0,
            order_type=order_type,
            status="pending",
            submit_time=datetime.now()
        )
        
        # 3. æ ¹æ®å¹³å°é€‰æ‹©äº¤æ˜“æ¥å£
        if deployment.platform == "ptrade":
            trader = self.ptrade_trader
        elif deployment.platform == "qmt":
            trader = self.qmt_trader
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„å¹³å°: {deployment.platform}")
        
        # 4. æäº¤è®¢å•
        try:
            order.status = "submitted"
            result = trader.submit_order(
                symbol=symbol,
                side=side,
                quantity=quantity,
                price=price,
                order_type=order_type
            )
            
            if result.get('success'):
                order.order_id = result.get('order_id', order.order_id)
                # ä¿å­˜è®¢å•åˆ°æ•°æ®åº“
                self._save_order(order)
                self.orders[order.order_id] = order
                return order
            else:
                order.status = "rejected"
                raise Exception(f"è®¢å•æäº¤å¤±è´¥: {result.get('error')}")
                
        except Exception as e:
            order.status = "rejected"
            self._save_order(order)
            logger.error(f"è®¢å•æ‰§è¡Œå¤±è´¥: {e}")
            raise
    
    def monitor_orders(
        self,
        strategy_id: Optional[str] = None
    ) -> List[Order]:
        """
        ç›‘æ§è®¢å•çŠ¶æ€
        
        Args:
            strategy_id: ç­–ç•¥IDï¼ˆå¯é€‰ï¼Œä¸æä¾›åˆ™ç›‘æ§æ‰€æœ‰è®¢å•ï¼‰
        
        Returns:
            List[Order]: è®¢å•åˆ—è¡¨
        """
        # ä»æ•°æ®åº“æŸ¥è¯¢è®¢å•
        if strategy_id:
            orders = self._query_orders_by_strategy(strategy_id)
        else:
            orders = self._query_all_orders()
        
        # æ›´æ–°è®¢å•çŠ¶æ€
        for order in orders:
            self._update_order_status(order)
        
        return orders
    
    def _update_order_status(self, order: Order):
        """æ›´æ–°è®¢å•çŠ¶æ€"""
        # æ ¹æ®å¹³å°æŸ¥è¯¢è®¢å•çŠ¶æ€
        deployment = self.manager.deployments.get(order.strategy_id)
        if not deployment:
            return
        
        if deployment.platform == "ptrade":
            trader = self.ptrade_trader
        elif deployment.platform == "qmt":
            trader = self.qmt_trader
        else:
            return
        
        # æŸ¥è¯¢è®¢å•çŠ¶æ€
        order_status = trader.query_order(order.order_id)
        
        # æ›´æ–°è®¢å•çŠ¶æ€
        if order_status:
            order.status = order_status.get('status', order.status)
            if order.status == "filled":
                order.fill_time = datetime.now()
                order.fill_price = order_status.get('fill_price')
                order.fill_quantity = order_status.get('fill_quantity')
            
            # ä¿å­˜æ›´æ–°
            self._save_order(order)
    
    def _save_order(self, order: Order):
        """ä¿å­˜è®¢å•åˆ°æ•°æ®åº“"""
        if self.manager.db:
            self.manager.db.execute(
                """
                INSERT INTO orders 
                (order_id, strategy_id, symbol, side, quantity, price, 
                 order_type, status, submit_time, fill_time, fill_price, fill_quantity)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                ON CONFLICT (order_id) 
                DO UPDATE SET 
                    status = EXCLUDED.status,
                    fill_time = EXCLUDED.fill_time,
                    fill_price = EXCLUDED.fill_price,
                    fill_quantity = EXCLUDED.fill_quantity
                """,
                (
                    order.order_id,
                    order.strategy_id,
                    order.symbol,
                    order.side,
                    order.quantity,
                    order.price,
                    order.order_type,
                    order.status,
                    order.submit_time,
                    order.fill_time,
                    order<CodeFromFile 
  filePath="code_library/009_Chapter9_Platform_Integration/9.6/code_9_6___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
from typing import Dict, List, Callable
from dataclasses import dataclass
from datetime import datetime, timedelta

@dataclass
class RiskAlert:
    """é£é™©å‘Šè­¦"""
    alert_id: str
    strategy_id: str
    alert_type: str  # "drawdown", "loss", "position", "liquidity"
    severity: str  # "low", "medium", "high", "critical"
    message: str
    timestamp: datetime
    resolved: bool = False

class RiskMonitor:
    """é£é™©ç›‘æ§å™¨"""
    
    def __init__(
        self,
        live_trading_manager: LiveTradingManager,
        risk_config: Dict[str, Any]
    ):
        """
        åˆå§‹åŒ–é£é™©ç›‘æ§å™¨
        
        Args:
            live_trading_manager: å®ç›˜äº¤æ˜“ç®¡ç†å™¨
            risk_config: é£é™©é…ç½®
        """
        self.manager = live_trading_manager
        self.config = risk_config
        self.alerts: List[RiskAlert] = []
        self.monitoring_interval = 60  # ç›‘æ§é—´éš”ï¼ˆç§’ï¼‰
    
    def monitor_risk(
        self,
        strategy_id: str
    ) -> List[RiskAlert]:
        """
        ç›‘æ§ç­–ç•¥é£é™©
        
        Args:
            strategy_id: ç­–ç•¥ID
        
        Returns:
            List[RiskAlert]: é£é™©å‘Šè­¦åˆ—è¡¨
        """
        alerts = []
        
        # 1. æ£€æŸ¥å›æ’¤é£é™©
        drawdown_alerts = self._check_drawdown_risk(strategy_id)
        alerts.extend(drawdown_alerts)
        
        # 2. æ£€æŸ¥äºæŸé£é™©
        loss_alerts = self._check_loss_risk(strategy_id)
        alerts.extend(loss_alerts)
        
        # 3. æ£€æŸ¥ä»“ä½é£é™©
        position_alerts = self._check_position_risk(strategy_id)
        alerts.extend(position_alerts)
        
        # 4. æ£€æŸ¥æµåŠ¨æ€§é£é™©
        liquidity_alerts = self._check_liquidity_risk(strategy_id)
        alerts.extend(liquidity_alerts)
        
        # ä¿å­˜å‘Šè­¦
        for alert in alerts:
            self._save_alert(alert)
            self.alerts.append(alert)
        
        return alerts
    
    def _check_drawdown_risk(
        self,
        strategy_id: str
    ) -> List[RiskAlert]:
        """æ£€æŸ¥å›æ’¤é£é™©"""
        alerts = []
        
        # è·å–ç­–ç•¥å®æ—¶è¡¨ç°
        performance = self._get_strategy_performance(strategy_id)
        if not performance:
            return alerts
        
        current_drawdown = performance.get('current_drawdown', 0)
        max_drawdown_limit = self.config.get('max_drawdown_limit', 0.15)
        
        if current_drawdown > max_drawdown_limit:
            severity = "critical" if current_drawdown > max_drawdown_limit * 1.5 else "high"
            alert = RiskAlert(
                alert_id=f"alert_{datetime.now().timestamp()}",
                strategy_id=strategy_id,
                alert_type="drawdown",
                severity=severity,
                message=f"ç­–ç•¥å›æ’¤è¶…è¿‡é™åˆ¶: {current_drawdown:.2%} > {max_drawdown_limit:.2%}",
                timestamp=datetime.now()
            )
            alerts.append(alert)
        
        return alerts
    
    def _check_loss_risk(
        self,
        strategy_id: str
    ) -> List[RiskAlert]:
        """æ£€æŸ¥äºæŸé£é™©"""
        alerts = []
        
        # è·å–ç­–ç•¥å®æ—¶è¡¨ç°
        performance = self._get_strategy_performance(strategy_id)
        if not performance:
            return alerts
        
        daily_loss = performance.get('daily_return', 0)
        daily_loss_limit = self.config.get('daily_loss_limit', -0.05)
        
        if daily_loss < daily_loss_limit:
            severity = "critical" if daily_loss < daily_loss_limit * 2 else "high"
            alert = RiskAlert(
                alert_id=f"alert_{datetime.now().timestamp()}",
                strategy_id=strategy_id,
                alert_type="loss",
                severity=severity,
                message=f"ç­–ç•¥å•æ—¥äºæŸè¶…è¿‡é™åˆ¶: {daily_loss:.2%} < {daily_loss_limit:.2%}",
                timestamp=datetime.now()
            )
            alerts.append(alert)
        
        return alerts
    
    def _check_position_risk(
        self,
        strategy_id: str
    ) -> List[RiskAlert]:
        """æ£€æŸ¥ä»“ä½é£é™©"""
        alerts = []
        
        # è·å–æŒä»“ä¿¡æ¯
        positions = self._get_strategy_positions(strategy_id)
        if not positions:
            return alerts
        
        # æ£€æŸ¥å•ç¥¨ä»“ä½
        max_position_ratio = self.config.get('max_position_ratio', 0.1)
        for position in positions:
            position_ratio = position.get('position_ratio', 0)
            if position_ratio > max_position_ratio:
                alert = RiskAlert(
                    alert_id=f"alert_{datetime.now().timestamp()}",
                    strategy_id=strategy_id,
                    alert_type="position",
                    severity="medium",
                    message=f"å•ç¥¨ä»“ä½è¶…è¿‡é™åˆ¶: {position['symbol']} {position_ratio:.2%} > {max_position_ratio:.2%}",
                    timestamp=datetime.now()
                )
                alerts.append(alert)
        
        return alerts
    
    def _check_liquidity_risk(
        self,
        strategy_id: str
    ) -> List[RiskAlert]:
        """æ£€æŸ¥æµåŠ¨æ€§é£é™©"""
        alerts = []
        
        # è·å–æŒä»“ä¿¡æ¯
        positions = self._get_strategy_positions(strategy_id)
        if not positions:
            return alerts
        
        # æ£€æŸ¥æŒä»“æµåŠ¨æ€§
        for position in positions:
            symbol = position.get('symbol')
            volume = position.get('volume', 0)
            avg_volume = position.get('avg_volume', 0)
            
            # å¦‚æœæŒä»“é‡è¶…è¿‡å¹³å‡æˆäº¤é‡çš„50%ï¼Œå¯èƒ½å­˜åœ¨æµåŠ¨æ€§é£é™©
            if avg_volume > 0 and volume > avg_volume * 0.5:
                alert = RiskAlert(
                    alert_id=f"alert_{datetime.now().timestamp()}",
                    strategy_id=strategy_id,
                    alert_type="liquidity",
                    severity="low",
                    message=f"æŒä»“å¯èƒ½å­˜åœ¨æµåŠ¨æ€§é£é™©: {symbol} æŒä»“é‡ {volume} > å¹³å‡æˆäº¤é‡ {avg_volume} çš„50%",
                    timestamp=datetime.now()
                )
                alerts.append(alert)
        
        return alerts
    
    def _get_strategy_performance(
        self,
        strategy_id: str
    ) -> Dict[str, Any]:
        """è·å–ç­–ç•¥å®æ—¶è¡¨ç°"""
        # ä»æ•°æ®åº“æˆ–å®æ—¶æ•°æ®æºè·å–
        # è¿™é‡Œç®€åŒ–å®ç°
        return {}
    
    def _get_strategy_positions(
        self,
        strategy_id: str
    ) -> List[Dict[str, Any]]:
        """è·å–ç­–ç•¥æŒä»“"""
        # ä»æ•°æ®åº“æˆ–äº¤æ˜“å¹³å°è·å–
        # è¿™é‡Œç®€åŒ–å®ç°
        return []
    
    def _save_alert(self, alert: RiskAlert):
        """ä¿å­˜å‘Šè­¦åˆ°æ•°æ®åº“"""
        if self.manager.db:
            self.manager.db.execute(
                """
                INSERT INTO risk_alerts 
                (alert_id, strategy_id, alert_type, severity, message, timestamp, resolved)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
                """,
                (
                    alert.alert_id,
                    alert.strategy_id,
                    alert.alert_type,
                    alert.severity,
                    alert.message,
           <CodeFromFile 
  filePath="code_library/009_Chapter9_Platform_Integration/9.6/code_9_6___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
from typing import List, Dict, Optional
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Position:
    """æŒä»“ä¿¡æ¯"""
    strategy_id: str
    symbol: str
    quantity: int
    avg_cost: float
    current_price: float
    market_value: float
    profit_loss: float
    profit_loss_ratio: float
    update_time: datetime

class PositionManager:
    """æŒä»“ç®¡ç†å™¨"""
    
    def __init__(
        self,
        live_trading_manager: LiveTradingManager,
        ptrade_data_provider=None,
        qmt_data_provider=None
    ):
        """
        åˆå§‹åŒ–æŒä»“ç®¡ç†å™¨
        
        Args:
            live_trading_manager: å®ç›˜äº¤æ˜“ç®¡ç†å™¨
            ptrade_data_provider: PTradeæ•°æ®æä¾›è€…
            qmt_data_provider: QMTæ•°æ®æä¾›è€…
        """
        self.manager = live_trading_manager
        self.ptrade_data = ptrade_data_provider
        self.qmt_data = qmt_data_provider
        self.positions: Dict[str, List[Position]] = {}
    
    def get_positions(
        self,
        strategy_id: str
    ) -> List[Position]:
        """
        è·å–ç­–ç•¥æŒä»“
        
        Args:
            strategy_id: ç­–ç•¥ID
        
        Returns:
            List[Position]: æŒä»“åˆ—è¡¨
        """
        # 1. è·å–ç­–ç•¥éƒ¨ç½²ä¿¡æ¯
        if strategy_id not in self.manager.deployments:
            raise ValueError(f"ç­–ç•¥ {strategy_id} æœªéƒ¨ç½²")
        
        deployment = self.manager.deployments[strategy_id]
        
        # 2. æ ¹æ®å¹³å°è·å–æŒä»“
        if deployment.platform == "ptrade":
            positions_data = self.ptrade_data.get_positions()
        elif deployment.platform == "qmt":
            positions_data = self.qmt_data.get_positions()
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„å¹³å°: {deployment.platform}")
        
        # 3. è½¬æ¢ä¸ºPositionå¯¹è±¡
        positions = []
        for pos_data in positions_data:
            position = Position(
                strategy_id=strategy_id,
                symbol=pos_data.get('symbol'),
                quantity=pos_data.get('quantity', 0),
                avg_cost=pos_data.get('avg_cost', 0),
                current_price=pos_data.get('current_price', 0),
                market_value=pos_data.get('market_value', 0),
                profit_loss=pos_data.get('profit_loss', 0),
                profit_loss_ratio=pos_data.get('profit_loss_ratio', 0),
                update_time=datetime.now()
            )
            positions.append(position)
        
        # 4. ä¿å­˜æŒä»“åˆ°æ•°æ®åº“
        self._save_positions(strategy_id, positions)
        self.positions[strategy_id] = positions
        
        return positions
    
    def sync_positions(
        self,
        strategy_id: str
    ) -> bool:
        """
        åŒæ­¥æŒä»“ï¼ˆä»äº¤æ˜“å¹³å°åŒæ­¥åˆ°ç³»ç»Ÿï¼‰
        
        Args:
            strategy_id: ç­–ç•¥ID
        
        Returns:
            bool: åŒæ­¥æ˜¯å¦æˆåŠŸ
        """
        try:
            positions = self.get_positions(strategy_id)
            # åŒæ­¥æˆåŠŸ
            return True
        except Exception as e:
            logger.error(f"æŒä»“åŒæ­¥å¤±è´¥: {e}")
            return False
    
    def analyze_positions(
        self,
        strategy_id: str
    ) -> Dict[str, Any]:
        """
        åˆ†ææŒä»“
        
        Args:
            strategy_id: ç­–ç•¥ID
        
        Returns:
            Dict: æŒä»“åˆ†æç»“æœ
        """
        positions = self.get_positions(strategy_id)
        
        if not positions:
            return {
                'total_positions': 0,
                'total_market_value': 0,
                'total_profit_loss': 0,
                'total_profit_loss_ratio': 0
            }
        
        total_market_value = sum(p.market_value for p in positions)
        total_profit_loss = sum(p.profit_loss for p in positions)
        total_cost = sum(p.avg_cost * p.quantity for p in positions)
        total_profit_loss_ratio = total_profit_loss / total_cost if total_cost > 0 else 0
        
        return {
            'total_positions': len(positions),
            'total_market_value': total_market_value,
            'total_profit_loss': total_profit_loss,
            'total_profit_loss_ratio': total_profit_loss_ratio,
            'positions_detail': [
                {
                    'symbol': p.symbol,
                    'quantity': p.quantity,
                    'market_value': p.market_value,
                    'profit_loss': p.profit_loss,
                    'profit_loss_ratio': p.profit_loss_ratio
                }
                for p in positions
            ]
        }
    
    def _save_positions(
        self,
        strategy_id: str,
        positions: List[Position]
    ):
        """ä¿å­˜æŒä»“åˆ°æ•°æ®åº“"""
        if self.manager.db:
            # åˆ é™¤æ—§æŒä»“
            self.manager.db.execute(
                "DELETE FROM positions WHERE strategy_id = %s",
                (strategy_id,)
            )
            
            # æ’å…¥æ–°æŒä»“
            for position in positions:
                self.manager.db.execute(
                    """
                    INSERT INTO positions 
                    (strategy_id, symbol, quantity, avg_cost, current_price, 
                     market_value, profit_loss, profit_loss_ratio, update_time)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                    """,
                    (
                        position.strategy_id,
                        position.symbol,
                        position.quantity,
                        position.avg_cost,
                        position.current_price,
                        position.market_value,
                        position.profit_loss,
                        position.profit_loss_rati<CodeFromFile 
  filePath="code_library/009_Chapter9_Platform_Integration/9.6/code_9_6___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
from typing import List, Dict, Optional
from datetime import datetime, timedelta

class TradingDataManager:
    """äº¤æ˜“æ•°æ®ç®¡ç†å™¨"""
    
    def __init__(
        self,
        live_trading_manager: LiveTradingManager,
        db_connection=None
    ):
        """
        åˆå§‹åŒ–äº¤æ˜“æ•°æ®ç®¡ç†å™¨
        
        Args:
            live_trading_manager: å®ç›˜äº¤æ˜“ç®¡ç†å™¨
            db_connection: æ•°æ®åº“è¿æ¥
        """
        self.manager = live_trading_manager
        self.db = db_connection
    
    def save_trade_record(
        self,
        order: Order,
        fill_data: Dict[str, Any]
    ):
        """
        ä¿å­˜äº¤æ˜“è®°å½•
        
        Args:
            order: è®¢å•ä¿¡æ¯
            fill_data: æˆäº¤æ•°æ®
        """
        if self.db:
            self.db.execute(
                """
                INSERT INTO trade_records 
                (order_id, strategy_id, symbol, side, quantity, price, 
                 fill_price, fill_quantity, fill_time, commission, stamp_tax)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """,
                (
                    order.order_id,
                    order.strategy_id,
                    order.symbol,
                    order.side,
                    order.quantity,
                    order.price,
                    fill_data.get('fill_price'),
                    fill_data.get('fill_quantity'),
                    fill_data.get('fill_time'),
                    fill_data.get('commission', 0),
                    fill_data.get('stamp_tax', 0)
                )
            )
    
    def query_trade_records(
        self,
        strategy_id: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> List[Dict[str, Any]]:
        """
        æŸ¥è¯¢äº¤æ˜“è®°å½•
        
        Args:
            strategy_id: ç­–ç•¥IDï¼ˆå¯é€‰ï¼‰
            start_date: å¼€å§‹æ—¥æœŸï¼ˆå¯é€‰ï¼‰
            end_date: ç»“æŸæ—¥æœŸï¼ˆå¯é€‰ï¼‰
        
        Returns:
            List[Dict]: äº¤æ˜“è®°å½•åˆ—è¡¨
        """
        query = "SELECT * FROM trade_records WHERE 1=1"
        params = []
        
        if strategy_id:
            query += " AND strategy_id = %s"
            params.append(strategy_id)
        
        if start_date:
            query += " AND fill_time >= %s"
            params.append(start_date)
        
        if end_date:
            query += " AND fill_time <= %s"
            params.append(end_date)
        
        query += " ORDER BY fill_time DESC"
        
        if self.db:
            return self.db.fetch_all(query, params)
        
        return []
    
    def sync_trading_data(
        self,
        strategy_id: str
    ) -> bool:
        """
        åŒæ­¥äº¤æ˜“æ•°æ®ï¼ˆä»äº¤æ˜“å¹³å°åŒæ­¥åˆ°ç³»ç»Ÿï¼‰
        
        Args:
            strategy_id: ç­–ç•¥ID
        
        Returns:
            bool: åŒæ­¥æ˜¯å¦æˆåŠŸ
        """
        try:
            # è·å–ç­–ç•¥éƒ¨ç½²ä¿¡æ¯
            deployment = self.manager.deployments.get(strategy_id)
            if not deployment:
                return False
            
            # æ ¹æ®å¹³å°åŒæ­¥æ•°æ®
            if deployment.platform == "ptrade":
                # ä»PTradeåŒæ­¥äº¤æ˜“æ•°æ®
                pass
            elif deployment.platform == "qmt":
                # ä»QMTåŒæ­¥äº¤æ˜“æ•°æ®
                pass
            
            return True
        except Exception as e:
            logger.error(f"äº¤æ˜“æ•°æ®åŒæ­¥å¤±è´¥: {e}")
            return False
```
-->r
    ) -> bool:
        """
        åŒæ­¥äº¤æ˜“æ•°æ®ï¼ˆä»äº¤æ˜“å¹³å°åŒæ­¥åˆ°ç³»ç»Ÿï¼‰
        
        Args:
            strategy_id: ç­–ç•¥ID
        
        Returns:
            bool: åŒæ­¥æ˜¯å¦æˆåŠŸ
        """
        try:
            # è·å–ç­–ç•¥éƒ¨ç½²ä¿¡æ¯
            deployment = self.manager.deployments.get(strategy_id)
            if not deployment:
                return False
            
            # æ ¹æ®å¹³å°åŒæ­¥æ•°æ®
            if deployment.platform == "ptrade":
                # ä»PTradeåŒæ­¥äº¤æ˜“æ•°æ®
                pass
            elif deployment.platform == "qmt":
                # ä»QMTåŒæ­¥äº¤æ˜“æ•°æ®
                pass
            
            return True
        except Exception as e:
            logger.error(f"äº¤æ˜“æ•°æ®åŒæ­¥å¤±è´¥: {e}")
            return False
```

## ğŸ”— ç›¸å…³ç« èŠ‚

- **ç¬¬7ç« ï¼šç­–ç•¥å¼€å‘**ï¼šäº†è§£ç­–ç•¥å¼€å‘å’Œæµ‹è¯•æµç¨‹
- **ç¬¬8ç« ï¼šå›æµ‹éªŒè¯**ï¼šäº†è§£BulletTradeå›æµ‹å’Œç­–ç•¥éªŒè¯
- **9.1 PTradeé›†æˆ**ï¼šäº†è§£PTradeå¹³å°é›†æˆ
- **9.2 QMTé›†æˆ**ï¼šäº†è§£QMTå¹³å°é›†æˆ
- **9.7 å®ç›˜åé¦ˆä¸åœ¨çº¿å†ä¼˜åŒ–**ï¼šäº†è§£å®ç›˜åé¦ˆæœºåˆ¶

## ğŸ’¡ å…³é”®è¦ç‚¹

1. **ç­–ç•¥éƒ¨ç½²**ï¼šç¡®ä¿ç­–ç•¥ç»è¿‡BulletTradeå›æµ‹éªŒè¯åå†éƒ¨ç½²
2. **äº¤æ˜“æ‰§è¡Œ**ï¼šå®ç°è‡ªåŠ¨åŒ–äº¤æ˜“æ‰§è¡Œå’Œå®æ—¶ç›‘æ§
3. **é£é™©ç›‘æ§**ï¼šå®æ—¶ç›‘æ§é£é™©ï¼ŒåŠæ—¶è§¦å‘å‘Šè­¦
4. **æŒä»“ç®¡ç†**ï¼šå®šæœŸåŒæ­¥æŒä»“ï¼Œåˆ†ææŒä»“æƒ…å†µ
5. **æ•°æ®ç®¡ç†**ï¼šå®Œæ•´è®°å½•äº¤æ˜“æ•°æ®ï¼Œæ”¯æŒæ•°æ®æŸ¥è¯¢å’Œåˆ†æ

## ğŸ”® æ€»ç»“ä¸å±•æœ›

<div class="summary-outlook">
  <h3>æœ¬èŠ‚å›é¡¾</h3>
  <p>æœ¬èŠ‚ç³»ç»Ÿä»‹ç»äº†å®ç›˜äº¤æ˜“ç®¡ç†ç³»ç»Ÿï¼ŒåŒ…æ‹¬ç­–ç•¥éƒ¨ç½²ç®¡ç†ã€äº¤æ˜“æ‰§è¡Œç®¡ç†ã€é£é™©ç›‘æ§ç®¡ç†ã€æŒä»“ç®¡ç†å’Œäº¤æ˜“æ•°æ®ç®¡ç†ã€‚é€šè¿‡ç†è§£å®ç›˜äº¤æ˜“ç®¡ç†å™¨çš„æ ¸å¿ƒå®ç°ï¼Œå¸®åŠ©å¼€å‘è€…æŒæ¡å¦‚ä½•å°†ç»è¿‡BulletTradeå›æµ‹éªŒè¯çš„ç­–ç•¥éƒ¨ç½²åˆ°å®ç›˜ç¯å¢ƒï¼Œå®ç°è‡ªåŠ¨åŒ–äº¤æ˜“æ‰§è¡Œã€å®æ—¶é£é™©ç›‘æ§å’ŒæŒä»“ç®¡ç†ã€‚</p>
  
  <h3>ä¸‹èŠ‚é¢„å‘Š</h3>
  <p>æŒæ¡äº†å®ç›˜äº¤æ˜“ç®¡ç†åï¼Œä¸‹ä¸€èŠ‚å°†ä»‹ç»å®ç›˜åé¦ˆä¸åœ¨çº¿å†ä¼˜åŒ–ï¼ŒåŒ…æ‹¬å®ç›˜åé¦ˆæœºåˆ¶ã€åœ¨çº¿å†ä¼˜åŒ–æµç¨‹å’Œåé¦ˆé—­ç¯è®¾è®¡ã€‚é€šè¿‡ç†è§£å®ç›˜åé¦ˆçš„å®Œæ•´æœºåˆ¶ï¼Œå¸®åŠ©å¼€å‘è€…æŒæ¡å¦‚ä½•å®ç°ç­–ç•¥çš„æŒç»­ä¼˜åŒ–ã€‚</p>
  
  <a href="/ashare-book6/009_Chapter9_Platform_Integration/9.7_Online_Feedback_Loop_CN" class="next-section">
    ç»§ç»­å­¦ä¹ ï¼š9.7 å®ç›˜åé¦ˆä¸åœ¨çº¿å†ä¼˜åŒ– â†’
  </a>
</div>

> **é€‚ç”¨ç‰ˆæœ¬**: v1.0.0+  
> **æœ€åæ›´æ–°**: 2025-12-12

