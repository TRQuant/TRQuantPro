# TRQuant 代码规范化规则
# 基于 Compound Engineering 理念 + AI Agent 协作框架
# 让每次代码生成都更规范、更易维护

## 🎯 核心原则

### Compound Engineering 理念
- **每次代码生成都应该让后续代码更容易写**
- **代码应该自文档化，减少维护成本**
- **遵循现有模式，建立可复用的组件**
- **质量优先：第一次就写对，而不是后续修复**

### AI Agent 协作框架
- **架构设计 Agent**：分析需求、设计架构、分解任务
- **代码生成 Agent**：生成高质量代码、自检质量
- **规范检查 Agent**：检查代码规范、运行工具链验证
- **多 Agent 协作**：通过工作流确保代码质量

---

## 📐 Python 代码规范

### 代码风格
- **PEP 8 严格遵循**：使用 `black` 格式化，`ruff` 检查
- **类型提示必须**：所有函数必须有类型注解
- **文档字符串**：所有公共函数、类必须有 docstring（Google 风格）
- **行长度**：最大 100 字符（而非 80）
- **导入顺序**：标准库 → 第三方 → 本地，每组之间空行

### 命名规范
```python
# 变量和函数：snake_case
def calculate_momentum_factor(data: pd.DataFrame) -> pd.Series:
    """计算动量因子"""
    pass

# 类名：PascalCase
class FactorCalculator:
    """因子计算器"""
    pass

# 常量：UPPER_SNAKE_CASE
MAX_POSITION_SIZE = 0.1
STOP_LOSS_THRESHOLD = 0.08

# 私有方法/属性：单下划线前缀
def _internal_helper(self):
    pass
```

### 代码组织
- **单一职责**：每个函数只做一件事
- **函数长度**：不超过 50 行，复杂逻辑拆分为小函数
- **类设计**：优先组合而非继承
- **错误处理**：使用具体异常类型，提供有意义的错误信息

### 示例模板
```python
from typing import Optional, List, Dict
import pandas as pd
import numpy as np

class FactorCalculator:
    """因子计算器基类
    
    Attributes:
        data: 输入数据
        config: 配置参数
    """
    
    def __init__(self, data: pd.DataFrame, config: Optional[Dict] = None) -> None:
        """初始化因子计算器
        
        Args:
            data: 股票数据DataFrame
            config: 可选配置字典
        """
        self.data = data
        self.config = config or {}
    
    def calculate(self) -> pd.Series:
        """计算因子值
        
        Returns:
            因子值Series，索引为股票代码
            
        Raises:
            ValueError: 当数据格式不正确时
        """
        if self.data.empty:
            raise ValueError("输入数据不能为空")
        # 实现逻辑
        return pd.Series()
```

---

## 📐 TypeScript/JavaScript 代码规范

### 代码风格
- **TypeScript 严格模式**：`strict: true`
- **ESLint + Prettier**：自动格式化和检查
- **2 空格缩进**：与现有代码保持一致
- **分号**：使用分号
- **引号**：单引号优先

### 类型系统
- **避免 `any`**：使用具体类型或 `unknown`
- **接口优先**：使用 `interface` 而非 `type`（除非需要联合类型）
- **泛型约束**：合理使用泛型提高代码复用性

### 命名规范
```typescript
// 变量和函数：camelCase
const calculateFactor = (data: DataFrame): Series => {
  // ...
};

// 类名：PascalCase
class FactorCalculator {
  // ...
}

// 常量：UPPER_SNAKE_CASE
const MAX_POSITION_SIZE = 0.1;

// 私有成员：下划线前缀
private _internalMethod(): void {
  // ...
}
```

### 异步处理
- **优先 async/await**：避免 Promise.then 链
- **错误处理**：所有 async 函数必须有 try-catch
- **类型安全**：Promise 返回值必须有类型注解

### 示例模板
```typescript
import { ExtensionContext, window } from 'vscode';

interface FactorConfig {
  period: number;
  method: 'sma' | 'ema';
}

class FactorCalculator {
  private data: DataFrame;
  private config: FactorConfig;
  
  constructor(data: DataFrame, config: FactorConfig) {
    this.data = data;
    this.config = config;
  }
  
  /**
   * 计算因子值
   * @returns 因子值Series
   * @throws {Error} 当数据格式不正确时
   */
  async calculate(): Promise<Series> {
    try {
      if (this.data.isEmpty()) {
        throw new Error('输入数据不能为空');
      }
      // 实现逻辑
      return new Series();
    } catch (error) {
      window.showErrorMessage(`计算因子失败: ${error.message}`);
      throw error;
    }
  }
}
```

---

## 🏗️ 架构规范

### 文件组织
```
core/
  ├── factors/          # 因子模块
  │   ├── __init__.py
  │   ├── base_factor.py
  │   └── momentum_factors.py
  ├── data_provider.py  # 数据提供者
  └── strategy.py       # 策略基类

extension/src/
  ├── commands/         # 命令
  ├── services/         # 服务
  ├── views/            # 视图
  └── utils/            # 工具函数
```

### 依赖管理
- **最小依赖**：只引入必要的库
- **版本锁定**：使用 `requirements.txt` 和 `package-lock.json`
- **避免循环依赖**：使用依赖注入或事件系统

### 错误处理模式
```python
# Python: 使用具体异常
class DataSourceError(Exception):
    """数据源错误"""
    pass

def fetch_data():
    try:
        # ...
    except ConnectionError as e:
        raise DataSourceError(f"连接失败: {e}") from e
```

```typescript
// TypeScript: 使用错误类
class DataSourceError extends Error {
  constructor(message: string, public code: string) {
    super(message);
    this.name = 'DataSourceError';
  }
}

async function fetchData(): Promise<Data> {
  try {
    // ...
  } catch (error) {
    throw new DataSourceError('连接失败', 'CONNECTION_ERROR');
  }
}
```

---

## 🧪 测试规范

### Python 测试
- **pytest**：使用 pytest 框架
- **测试文件命名**：`test_*.py`
- **覆盖率目标**：核心模块 > 80%
- **测试组织**：每个测试函数测试一个场景

```python
import pytest
from core.factors.momentum_factors import MomentumFactor

def test_momentum_factor_calculation():
    """测试动量因子计算"""
    data = create_test_data()
    factor = MomentumFactor(data)
    result = factor.calculate()
    assert not result.empty
    assert len(result) == len(data)
```

### TypeScript 测试
- **Jest**：使用 Jest 测试框架
- **测试文件命名**：`*.test.ts` 或 `*.spec.ts`
- **Mock 外部依赖**：使用 Jest mocks

```typescript
import { FactorCalculator } from './factorCalculator';

describe('FactorCalculator', () => {
  it('should calculate factor correctly', async () => {
    const data = createTestData();
    const calculator = new FactorCalculator(data);
    const result = await calculator.calculate();
    expect(result).toBeDefined();
    expect(result.length).toBe(data.length);
  });
});
```

---

## 📝 文档规范

### 代码注释
- **为什么而非是什么**：注释解释原因，代码本身应该清晰
- **TODO 标记**：`# TODO: 原因` 或 `// TODO: 原因`
- **复杂逻辑**：必须注释解释算法或业务逻辑

### 文档字符串
```python
def calculate_sharpe_ratio(returns: pd.Series, risk_free_rate: float = 0.03) -> float:
    """计算夏普比率
    
    使用年化收益率和波动率计算风险调整后的收益指标。
    
    Args:
        returns: 收益率序列（日度）
        risk_free_rate: 无风险利率，默认 3%
        
    Returns:
        夏普比率值
        
    Raises:
        ValueError: 当收益率序列为空时
        
    Example:
        >>> returns = pd.Series([0.01, 0.02, -0.01])
        >>> sharpe = calculate_sharpe_ratio(returns)
        >>> print(f"Sharpe Ratio: {sharpe:.2f}")
    """
    if returns.empty:
        raise ValueError("收益率序列不能为空")
    # 实现...
```

---

## 🔄 AI Agent 工作流

### 开发新功能时的 Agent 协作流程

#### 阶段一：架构设计（Architect Agent）

当用户提出新功能需求时，请遵循以下流程：

1. **分析需求**
   - 理解功能目标
   - 分析现有代码结构（查看 `core/`, `extension/` 等目录）
   - 识别可复用的模块和模式

2. **设计架构**
   - 设计模块结构（目录树）
   - 定义核心类和接口
   - 确定依赖关系
   - 参考现有架构模式

3. **任务分解**
   - 将功能分解为多个任务
   - 确定任务优先级
   - 识别任务依赖关系

4. **输出架构设计**
   - 模块结构图
   - 接口定义（类型注解）
   - 开发计划（按优先级）

**输出格式示例**：
```
## 架构设计

### 模块结构
```
core/
├── new_module/
│   ├── __init__.py
│   ├── core.py
│   └── utils.py
```

### 核心接口
```python
class NewModule:
    def process(self, data: pd.DataFrame) -> Dict[str, Any]:
        """处理数据"""
        pass
```

### 开发计划
1. [高优先级] 实现核心功能
2. [中优先级] 添加工具函数
3. [低优先级] 完善文档
```

#### 阶段二：代码生成（Code Generator Agent）

根据架构设计生成代码时，请遵循以下规范：

1. **生成接口定义**
   - 类型定义（使用 `typing` 模块）
   - 接口声明
   - 数据结构（使用 `dataclass` 或 `TypedDict`）

2. **生成实现代码**
   - 严格遵循代码规范（见下文）
   - 所有函数必须有类型注解
   - 所有公共函数必须有 docstring（Google 风格）
   - 完整的错误处理（使用具体异常类型）
   - 函数长度不超过 50 行

3. **生成测试代码**
   - 为每个公共函数生成单元测试
   - 使用 `pytest` 框架
   - 包含边界条件测试
   - 包含异常情况测试

4. **自检代码质量**
   - 检查类型注解完整性
   - 检查文档字符串完整性
   - 检查代码风格（行长度、命名等）
   - 检查逻辑正确性

**自检清单**：
- [ ] 所有函数都有类型注解
- [ ] 所有公共函数都有 docstring
- [ ] 代码风格符合 PEP 8
- [ ] 函数长度不超过 50 行
- [ ] 错误处理完整
- [ ] 生成了对应的单元测试

#### 阶段三：规范检查（Quality Checker Agent）

代码生成后，请执行以下检查：

1. **语法检查**
   - 确保代码可以解析（Python: `python -m py_compile`）
   - 确保代码可以编译（TypeScript: `npm run compile`）

2. **风格检查**
   - Python: 运行 `ruff check .`
   - TypeScript: 运行 `npm run lint`

3. **类型检查**
   - Python: 运行 `mypy .`（如果已配置）
   - TypeScript: 运行 `npm run type-check`

4. **安全检查**
   - 检查危险函数（`eval`, `exec`, `__import__`, `pickle.loads` 等）
   - 检查安全漏洞（SQL注入、路径遍历等）

5. **性能检查**
   - 检查明显的性能问题（嵌套循环、大列表推导式等）
   - 检查资源释放（文件、连接等）

**检查清单**：
- [ ] 语法正确（可以编译/解析）
- [ ] 风格检查通过（ruff/lint）
- [ ] 类型检查通过（mypy/type-check）
- [ ] 无安全风险
- [ ] 性能合理
- [ ] 所有测试通过

### 多 Agent 协作流程

```
用户需求
  ↓
[Architect Agent] 分析需求 → 架构设计 → 任务分解
  ↓
[Code Generator Agent] 生成代码 → 自检质量
  ↓
[Quality Checker Agent] 规范检查 → 修复问题
  ↓
高质量代码
```

### 生成新功能时的检查清单

1. **分析现有模式**（Architect Agent）
   - 查找类似功能的实现
   - 遵循现有的架构模式
   - 复用已有的工具函数

2. **设计接口**（Architect Agent）
   - 定义清晰的输入输出
   - 考虑错误情况
   - 设计可测试的接口

3. **实现代码**（Code Generator Agent）
   - 遵循命名规范
   - 添加类型注解
   - 编写文档字符串
   - 处理错误情况

4. **质量检查**（Quality Checker Agent）
   - 运行格式化工具（black/ruff/prettier）
   - 检查类型错误
   - 运行测试
   - 检查代码覆盖率

5. **文档更新**（Code Generator Agent）
   - 更新相关文档
   - 添加使用示例
   - 记录设计决策

---

## 🛠️ 工具配置

### Python 工具
```bash
# 格式化
black . --line-length 100

# 检查
ruff check .

# 类型检查
mypy .
```

### TypeScript 工具
```bash
# 格式化
npm run format

# 检查
npm run lint

# 类型检查
npm run type-check
```

---

## ⚠️ 禁止事项

- ❌ 使用 `any` 类型（TypeScript）
- ❌ 忽略错误（必须处理所有异常）
- ❌ 魔法数字（使用命名常量）
- ❌ 深层嵌套（超过 3 层需要重构）
- ❌ 过长的函数（超过 50 行需要拆分）
- ❌ 硬编码配置（使用配置文件）
- ❌ 注释掉的代码（删除而非注释）

---

## 💡 最佳实践

1. **DRY 原则**：但不要过度抽象，简单重复优于复杂抽象
2. **KISS 原则**：保持简单，避免过度设计
3. **YAGNI 原则**：不要实现当前不需要的功能
4. **单一职责**：每个函数/类只做一件事
5. **开闭原则**：对扩展开放，对修改关闭

---

**最后更新**: 2025-12-06  
**适用项目**: TRQuant 量化投资系统  
**参考**: Compound Engineering Philosophy





