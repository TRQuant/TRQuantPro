

=== 第 1 页 ===

BulletTrade策略回测验证与实盘交易部署整合方案
策略回测验证：基于 BulletTrade 的实现
BulletTrade 回测环境搭建与策略导入：BulletTrade 是一个兼容聚宽 (JoinQuant) API 的本地量化框架 1 。这意
味着第六步生成的聚宽策略代码几乎无需修改即可直接导入 BulletTrade 运行 2 3 。开发者可将策略源码保存为
独立的 Python 脚本（如 my_strategy.py ），并确保开头使用 from jqdata import * 等聚宽风格的引
入。BulletTrade 提供与聚宽相同的函数接口（如 initialize(context) ,
handle_data(context,data) , before_trading_start , order , order_value , get_price ,
run_daily 等），因此策略逻辑和API调用保持不变即可运行在本地 2 3 。例如，若策略在聚宽中定义了初
始函数、调度函数和下单逻辑，那么在 BulletTrade 中可直接复用这些代码，真正实现策略无缝迁移 4 。同时，可
通过在策略的 initialize 中调用 set_benchmark('指数代码') 来设定回测基准，如设定沪深300作为基准
5 。
回测参数与环境配置：在运行 BulletTrade 回测前，需要配置回测环境的参数，例如数据源、滑点、手续费等。
BulletTrade 支持多种行情数据源，默认可通过配置文件（如项目根目录下的 .env ）指定数据供应商 6 。例
如，将 DEFAULT_DATA_PROVIDER 设置为 jqdata （需聚宽数据账号）、 miniqmt （券商QMT免费行
情）、 tushare （免费数据，需要Token）或模拟数据等，以切换所用的历史行情来源 7 。对于滑点和手续
费，BulletTrade 致力于真实回测，默认采用实际市场价格撮合交易（如买卖按开盘价/收盘价成交，而非理想信号
价） 8 。这意味着滑点影响在真实撮合中自然体现（如用下一根K线开盘价成交信号）。手续费方面，
BulletTrade兼容聚宽的成本设定接口，如果策略中使用 set_commission 或 set_slippage 等API，
BulletTrade 会应用相应的费率模型（默认A股手续费印花税等和聚宽标准一致）。若需要自定义滑点模型，可在策
略代码中调用对应函数或在BulletTrade引擎初始化时设定。目前 BulletTrade 专注A股交易，默认手续费可按千分
之几设置；若框架尚未提供便捷接口，开发者也可在每笔交易执行后手动调整收益（例如扣除万分之2.5的佣金
等）。总体而言，通过聚宽 API 进行参数配置能够直接在 BulletTrade 回测中生效，确保回测条件（基准、费率、
滑点等）与原有设定一致。
回测执行与报告生成：完成配置后，可以使用 BulletTrade 提供的一键回测命令行工具来运行历史回测。示例命令
如下 9 ：
bullet-trade backtest my_strategy.py --start 2020-01-01 --end 2023-12-31 --
frequency day
上述命令将从2020年初回测策略到2023年底，频率为日线（可通过 --frequency minute 切换为分钟级回测)
10 。BulletTrade 的回测引擎具有真实交易模拟、自动处理分红送股等特性，使得结果更加贴近真实情况 8 。回
测完成后，BulletTrade 自动生成HTML格式的回测报告 8 。该报告包含策略的关键绩效指标（累计收益率、年化
收益、夏普比率、最大回撤等）、策略与基准的净值曲线对比、回撤曲线，以及详细的交易记录和持仓表现等信息
8 。报告通常以交互图表和表格呈现，便于研究和分享。例如，BulletTrade回测结束后生成的HTML报告如下图
所示。报告中展示了策略净值随时间的变化曲线，并附有回撤阴影图、指标统计等，使策略表现一目了然。我们可
1


=== 第 2 页 ===

以将该HTML报告嵌入到韬睿系统的文档模块中直接查看，也可以根据需要转换为Markdown格式，提取其中的图
表和数据供进一步分析。
BulletTrade 回测报告示例：HTML报告涵盖了收益曲线、回撤及各项绩效指标，可用于评估策略历史表现。
在生成HTML报告的同时，建议将回测产生的原始数据结构化保存。例如，利用 BulletTrade 回测引擎返回的结果对
象，提取每日组合净值序列、每笔交易记录、持仓变化等数据，将它们输出为CSV文件或保存到SQLite/Parquet数
据库中。具体实现上，可在回测执行脚本中添加保存逻辑：例如调用BulletTrade的回测结果对象的属性（如净值列
表、订单列表）并使用 pandas.DataFrame 保存为 result_equity.csv 、 trades.csv 等。这样一来，每
次回测的关键数据都有据可查，方便后续对比分析和版本管理。若 BulletTrade 并未直接暴露结果对象，也可通过
解析HTML报告或日志获取数据，例如解析净值曲线、统计指标和交易清单，然后结构化存储。通过将回测数据保
存到标准化文件，韬睿系统可以将这些结果纳入版本控制仓库，确保历史回测结果可追溯、可比对。
LLM绩效分析与自然语言解读：回测数据保存后，系统可以借助大语言模型（LLM）自动对策略绩效进行分析，总
结生成可读的回测解读文档。这一步通过编写一个报告生成模块（如下文的 report_generator.py ）实现：它
读取回测的关键统计数据（如年化收益、最大回撤、胜率、Sharpe比率、Beta等）和交易特征（如交易次数、平均
持仓周期等），将这些信息整理成提示（Prompt），交由AI模型生成分析报告 11 。LLM在此扮演“量化分析师”的
角色，对策略在回测期间的表现进行多维度评估，自动生成结构化的“绩效分析简报” 11 。这份自然语言报告通常
包括：策略总体收益表现对比基准如何、收益波动和回撤情况、策略在不同市场阶段的表现差异，主要盈利来源和
亏损原因分析、策略优缺点，以及可能的改进建议等。例如，LLM可能总结：“策略在回测期内取得了年化15%的收
益率，跑赢基准沪深300约5个百分点。最大回撤为8%，风险控制较为良好。但在震荡市中策略收益下降明显，说
明策略对趋势行情较依赖。建议关注回撤期间的持仓调整，可考虑加入止损机制。” 这些由AI生成的洞见可以帮助团
队深入理解策略行为。生成的回测解读报告将以Markdown格式保存到韬睿量化系统中，对应每次回测版本。这
样，团队成员无需手动撰写分析，即可在文档模块中查看由AI提供的回测报告解读，提高研究效率 11 。总之，通
过 “回测执行→数据保存→AI解读” 的流水线，我们将策略回测验证过程全面自动化，每一次策略优化迭代都有详尽
的数据和文字记录，为实盘部署决策提供依据。
策略实盘交易部署：基于 BulletTrade 的执行
部署方式与券商接口接入：在将策略从回测推进到实盘时，BulletTrade 提供灵活的部署方案，可在本地或服务器环
境运行策略，并连接实际券商交易接口。对于常见的 A 股券商交易，BulletTrade已内置对 QMT (券商量化交易终
端) 的支持 12 。如果使用Windows环境且已安装支持QMT的券商客户端（如国金证券、华鑫证券等），只需一条
命令即可启动实盘策略： 13
bullet-trade live my_strategy.py --broker qmt
上述命令将启动本地实盘实例，BulletTrade会自动连接本地的 QMT 交易终端，订阅实时行情并根据策略信号下
单，订单通过券商通道直接报送市场 13 。对于在Linux服务器或无法直接运行券商客户端的场景，BulletTrade提
供了远程 QMT 方案：在一台Windows机器上运行 QMT Server，然后在Linux服务器上以 --broker qmt-
remote 模式运行策略。BulletTrade会通过网络将下单指令发送到远程Windows主机上的QMT，实现异地实盘交
易 14 。例如，在Windows端启动服务：
bullet-trade server --listen 0.0.0.0 --port 58620 --token <your_token>
2


=== 第 3 页 ===

在服务器上运行策略：
bullet-trade live my_strategy.py --broker qmt-remote
这样，策略逻辑仍在本地/服务器执行，但交易指令经由网络转发到Windows上的券商客户端下单 14 。这一模式允
许非Windows系统也能参与实盘，并且策略代码无需托管到第三方平台，保证了代码和账户的私密性 15 。对于恒
生交易接口和掘金量化平台等其它券商/平台的接入，BulletTrade当前尚未内置直接支持，但可以通过扩展实现：
恒生电子的 PTrade 是一款支持Python编程的专业量化交易终端，提供统一的API接口，可对接股票、期货、外汇
等多市场交易 16 17 。要将BulletTrade策略部署到恒生接口，方案之一是在BulletTrade框架中实现一个自定义
Broker适配模块，通过恒生提供的Python API执行下单和查询。具体做法是仿照BulletTrade现有QMT Broker的实
现，开发一个 HengshengBroker 类，封装登录券商、发单撤单、查询资产等功能，然后在 bullet-trade
live 时指定使用该Broker。由于PTrade具备策略回测和实时交易功能，也可以选择直接在PTrade环境中运行策略
代码；BulletTrade的聚宽兼容代码也能在PTrade中稍作改动后执行，因为两者同为Python策略接口（可能需要调
整API调用以匹配恒生接口）。类似地，“掘金量化”平台（MyQuant）提供了云端实盘接口和本地API，可通过
REST/WebSocket等方式下单。BulletTrade可以扩展对掘金API的支持，方法是在框架中新增一个
JuejinBroker 适配层，将BulletTrade生成的交易信号翻译为掘金的交易指令接口调用，实现策略代码与掘金实
盘环境的对接。简言之，对于 QMT 以外的券商或交易平台，我们可以通过插件化的券商接口模块将 BulletTrade 策
略部署到相应环境：以 统一的策略逻辑 驱动，不同的Broker适配器执行具体下单，保证策略在各平台的一致运行。
实时行情与交易数据流接入：实盘过程中，需要确保策略获取实时市场行情数据，并及时执行交易。BulletTrade 支
持日线和分钟线级别的数据订阅，且提供对Tick级行情的支持，可满足高频或秒级策略需要 10 18 。在使用 QMT
数据源时，BulletTrade 利用 QMT自带的 xtdata 实时推送，实现 毫秒级延迟 的行情更新 19 。策略代码中可以使
用 subscribe([股票列表], frequency) 订阅实时行情，例如订阅一组股票的Tick数据，BulletTrade会在每个
Tick到来时触发 handle_tick(context, tick) 回调，以便策略实时处理订单簿变动 20 。对于一般日内策
略，使用分钟线即可：BulletTrade会定时调用 handle_data(context, data) 并提供最新分钟Bar行情数据。
若接入恒生或掘金等外部平台，也需获取其实时行情流：可能通过恒生PTrade自带的行情订阅接口，或掘金量化提
供的实时数据API。行情接口的抽象在BulletTrade中已部分实现（通过DEFAULT_DATA_PROVIDER配置数据源
21 ），因此扩展新的行情源时，只需按照BulletTrade的数据提供器规范，实现诸如 get_price 、 history 、
subscribe 等方法，即可将行情数据无缝接入策略。在实盘部署时，韬睿系统会运行BulletTrade或其扩展模块来
持续接收行情，并推动策略逻辑执行交易，从而形成实时数据→策略决策→交易执行的循环。
日志监控与风险控制：实盘交易过程中，持续的日志记录与监控报警是保障系统稳定的重要环节。BulletTrade 在运
行策略时会输出日志，包括每笔交易指令、成交反馈、资金变动以及错误警告等。我们可以将这些日志重定向保存
到韬睿系统的文件系统（如按日期记录在 logs/ 目录）。运维人员或监控进程可以实时跟踪日志，若发现异常
（如网络断连、下单失败等）及时告警通知。除了被动监控外，还可主动加入风控机制：例如在策略层面，可以在
代码中预设每日最大亏损或单笔交易止损，一旦触发条件就执行 order_target_value(持仓, 0) 等指令清仓止
损。我们也可以在BulletTrade交易引擎外围增加风险控制模块，对账户净值和持仓进行独立监控。当监测到策略净
值回撤超出阈值或某只股票下跌超限时，这个风控模块可以调用 BulletTrade 的交易接口（或券商API）平掉仓位，
并暂停策略运行，以防止更大损失。这相当于一个安全网，即使策略本身未考虑极端情况，外部风控也能干预。
BulletTrade当前版本未自带复杂风控管理，但我们可在 trading_engine.py 等模块中实现该功能：例如定时检
查 context.portfolio 的浮动盈亏，或通过交易记录计算当日盈亏，当超过止损或达到止盈目标时，通过调用
系统命令停止策略进程或执行对冲指令锁定收益。结合券商层面的风控（如恒生PTrade支持设置止损止盈参数 17
22 ），多层防护将保证实盘交易更稳健可控。
3


=== 第 4 页 ===

数据记录与持仓快照：为了方便事后分析和对账，每日交易结束后，系统应自动保存交易流水和持仓快照。交易流
水包括当日所有成交记录（时间、证券、买卖方向、成交价、数量、手续费等），这些数据BulletTrade本身会通过
日志或内部记录持有。我们可以在收盘后调用 BulletTrade 提供的接口获取当日 context.portfolio 信息和订
单清单，将其保存为CSV或者写入数据库。例如，将当天的交易列表保存为 trades_YYYYMMDD.csv ，账户持仓
情况保存为 positions_YYYYMMDD.csv 。持仓快照应记录每只股票的持仓数量、成本价、浮动盈亏，以及账户
总资产、市值、可用资金等关键信息。通过每日快照的序列，可跟踪策略实盘资产曲线演变，并与回测时期的模拟
曲线进行对比分析。如果使用了聚宽模拟盘+远程实盘的混合方案，聚宽端也会记录模拟成交，我们更需要以真实账
户为准，将真实成交和持仓记录下來 23 24 。这些数据文件会被纳入韬睿系统的文件库，以日期组织，方便查询历
史某日的交易明细和仓位分布。同时，在版本控制下，如果策略版本有更新，也可比较更新前后的持仓变化和收益
变化。
AI实盘日报与运维报告：利用LLM不仅可以分析回测，同样可以应用于每日实盘结果的总结，形成智能化的交易日
报。我们可以设定在每日收盘后，由系统调取当日交易数据和账户绩效，然后触发LLM生成实盘报告。报告内容包
括：当日策略盈亏和收益率，与基准指数的对比（如跑赢/跑输幅度），当日主要盈利或亏损的交易（列举盈利最大
的几笔交易和亏损最大的几笔交易），持仓市值变化，仓位分布，及风险指标（如当日最大回撤、波动率）等。同
时，让AI根据这些数据进行偏差分析，即对比策略当天的表现与历史均值或回测预期：如果出现显著偏差，分析可
能原因（例如行情异常波动、策略未能及时止损等）。LLM还能提供策略建议，例如：“今天策略在医药板块的仓位
拖累收益，考虑降低该板块权重” 或 “近期市场波动加大，建议缩短均线周期”。这些建议不一定直接用于修改策略，
但可供量化团队参考。每日实盘报告将以Markdown形式记录，在韬睿系统中形成一系列按日期的实盘日志文档。
运维人员可以查阅这些AI报告，快速了解策略运行状况和潜在问题，而不必手动分析大量交易数据 11 。此外，AI
生成的报告还能结合多日趋势生成周报或月报：例如总结本周策略收益、与月初计划偏差、当前累计收益以及对下
周期的展望等，真正实现智能化的量化交易运维。通过让LLM参与日常监控，我们相当于为团队引入了一位 tireless
的“智能顾问”，持续审视策略表现并提出改进想法。这种AI辅助不仅减轻了人工分析负担，也为策略优化提供了新
的灵感来源，有助于策略在实盘阶段不断演进提高。
输出集成与策略研发闭环
文件系统嵌入与文档展示：无论是策略代码、回测报告还是实盘日志，所有输出结果都会被妥善保存到韬睿量化系
统的文件系统中，并通过文档展示模块以 Markdown 等形式呈现给用户。具体而言，我们规划将项目组织成清晰的
目录结构（详见下节），确保策略开发→回测→实盘各环节产出的文件都有各自存储位置，并能在Web界面或内部
文档工具中查看版本历史。Markdown 文档能够很好地展示文字说明、表格和插入的图表，同时便于版本对比和协
作编辑。BulletTrade 生成的HTML报告可直接存储并在需要时通过IFrame或浏览器插件打开，但为了统一管理，我
们倾向于将报告转化为Markdown摘录或者将关键图表导出为图片后插入Markdown 8 。例如，每次回测后系统
会在 reports/backtests/ 目录下生成一个Markdown文件，内容包括回测参数摘要、主要绩效指标表格、策略
净值曲线图（通过BulletTrade报告截图或matplotlib重新绘制）等，以及LLM自动生成的分析解读段落。对于每日
实盘，同样在 reports/live/ 下按日期保存Markdown日志，其中嵌入当日收益曲线截图、交易统计表，并附上
AI写的点评。韬睿系统的文档展示模块支持渲染Markdown和图片，因此团队成员可以方便地在前端查看策略的各
种报告。更重要的是，这些文档都受版本控制管理（例如基于Git仓库或内部的版本管理机制）：每当策略代码更
新、或新的报告生成，它们都会提交形成一个新版本记录。这样可以追溯任意时刻策略文件的状态和业绩表现，实
现“一切皆文档、皆可追溯”。
4


=== 第 5 页 ===

策略开发-回测-实盘闭环流程：通过上述集成，我们建立了一个闭环的量化策略研发与运维流程：策略从想法产生、
编码实现，到历史验证，再到实盘交易，每个阶段的数据和结论都反馈影响下阶段，从而形成持续改进循环：
1. 策略开发 – 量化研究员或AI助手提出新的策略想法或改进方案。借助韬睿系统的AI编程工具，可用自然语言
描述策略思路并让大模型生成初步的策略代码雏形；开发者再在IDE或JupyterLab中完善代码（BulletTrade
提供 bullet-trade lab 命令可启动Jupyter环境 25 ）。每个重要的策略版本（v1, v2, …）都保存于
strategies/ 目录并提交版本库。
2. 回测验证 – 使用 BulletTrade 对新策略版本进行回测测试。回测过程及结果文件自动记录于 backtests/策
略名/版本号/ 目录，包括运行所用参数配置、生成的HTML/Markdown报告、CSV结果数据等。完成回测
后，系统触发AI分析，将回测绩效要点和图表输入LLM，生成该版本策略的回测解读报告Markdown，存档
于同一目录下（例如 report_v2.md ）。团队可以通过文档界面查看此次回测报告和AI点评，对策略效果
有直观了解。
3. 性能评审 – 策略开发者和团队根据回测报告评审策略。如果AI分析和人工判断都认为策略表现理想（收益高
且稳健），则进入实盘部署阶段；若发现问题（例如过拟合或重大缺陷），则返回开发阶段修改策略逻辑或
参数，然后再次回测验证。这个循环可能多次迭代，在AI辅助下显著加快（AI可自动调参回测或生成新思
路）。BulletTrade还支持参数优化功能，可并行回测不同参数组合，输出最优解供参考 26 。
4. 实盘部署 – 策略通过BulletTrade的实盘引擎上线运行（连接真实券商账户），进入实时交易阶段。部署信
息（如使用账户、启动时间、版本号）记录在 live_runs/ 目录。每日收盘后，系统汇总实盘交易数据，
与过去回测结果进行比较分析，并由LLM生成当日策略运行报告（偏差分析、调优建议等），存储为当天的
Markdown日志。运维人员定期查看AI报告，关注策略是否偏离预期。如出现异常，可能临时调整策略或触
发紧急止损，并标记问题以供研发人员后续改进。
5. 策略优化迭代 – 实盘过程中，AI日报所提供的建议和观察（例如“近期市场进入震荡，策略收益下降”）会反
馈给研究团队。研究员据此评估是否需要优化策略参数或增加新因子。如果决定优化，则进入下一轮开发→
回测→部署循环，新版本策略经过模拟验证后替换旧版本实盘运行。整个过程中的每一次变更都有据可查：
代码版本控制保存了修改内容，回测与实盘报告记录了性能变化。这样团队可以量化每次优化的效果，确保
策略朝着正向方向演化。
通过上述闭环，韬睿量化团队将策略的生命周期各阶段紧密衔接，实现从研究创意到实盘盈利的全流程自动化管
理。BulletTrade在其中充当了统一的策略执行内核，而AI则成为智能助手，帮助策略更快更好地迭代升级。团队在
系统中可以方便地检索任意策略历程：例如查看某策略在6个月前第3版回测时的报告，或对比当前实盘与当初回测
的收益曲线差异。这种全周期档案为策略评价和改进提供了宝贵依据，也方便新人接手时迅速了解策略演变史。总
之，韬睿量化系统借助BulletTrade和AI，实现了策略开发→回测验证→实盘交易→绩效反馈的闭环，形成自我进
化的策略研发部署流水线，这正是我们追求的目标。
项目结构与核心模块设计
项目结构示意：按照上述功能需求，我们规划清晰的项目目录以管理代码、配置和输出结果。下面是项目目录结构
及主要内容示意：
TaoRuiQuantProject/
├── strategies/ # 策略代码目录
│ ├── my_strategy_v1.py # 策略版本1代码
│ ├── my_strategy_v2.py # 策略版本2代码
│ └── ...
├── backtests/ # 策略回测结果存档
5


=== 第 6 页 ===

│ └── my_strategy/ # 按策略分组
│ ├── v1/ # 策略v1回测
│ │ ├── config.yaml # 回测参数配置(时间段、频率等)
│ │ ├── equity_curve.csv # 净值曲线数据
│ │ ├── trades.csv # 交易记录数据
│ │ ├── report_v1.html # BulletTrade生成的HTML报告
│ │ └── report_v1.md # LLM生成的回测分析Markdown
│ └── v2/
│ └── ... (类似结构，存放策略v2回测结果)
├── live_trading/ # 实盘运行数据
│ ├── logs/ # 日志文件
│ │ ├── live_2025-12-05.log # 2025-12-05当天实盘日志
│ │ └── ...
│ ├── snapshots/ # 每日持仓快照
│ │ ├── positions_2025-12-05.csv
│ │ └── ...
│ └── reports/ # 实盘日报/报告
│ ├── 2025-12-05.md # 当日实盘AI报告
│ ├── 2025-12-06.md # 次日实盘AI报告
│ └── ...
├── modules/ # 系统模块代码
│ ├── bt_run.py # 回测执行模块
│ ├── report_generator.py # 报告生成与AI分析模块
│ ├── trading_engine.py # 实盘交易引擎模块
│ ├── broker_qmt.py # QMT券商接口适配器
│ ├── broker_hs.py # 恒生券商接口适配器 (扩展实现)
│ ├── broker_juejin.py # 掘金券商接口适配器 (扩展实现)
│ └── ...
├── .env # 全局配置文件（数据源选择、API密钥等）
└── README.md # 项目说明文档
图： 项目结构将代码、回测、实盘等内容分门别类，支持版本控制与协同开发。 在此设计下，策略从开发到部署的
各阶段产出都保存在相应文件夹中。例如，策略代码在 strategies/ 维护，不同版本可以通过文件名或内部版本
号区分；每次回测结果放在 backtests/策略名/版本/ 目录下，包含原始数据和报告；实盘日志和报告则按日期
存放，方便查找特定日期的运行情况。这样的结构也利于对接版本控制系统：代码和报告文档都可纳入Git仓库，不
同版本diff清晰明了。
核心流程与命令行操作: 量化团队可以通过命令行工具链或脚本来驱动整个流程。下面给出核心流程的命令行示例：
# 1. 安装 BulletTrade 及环境配置
pip install bullet-trade # 安装BulletTrade框架 1
# 编辑 .env 配置数据源和API密钥（如选择MiniQMT或TuShare等） 6
# 2. 编写/更新策略代码
6


=== 第 7 页 ===

vim strategies/my_strategy_v3.py # 编辑策略第3版代码，保存版本
# 3. 运行回测验证策略
bullet-trade backtest strategies/my_strategy_v3.py \
--start 2020-01-01 --end 2023-12-31 --frequency day \
--output backtests/my_strategy/v3/report_v3.html
# 假设BulletTrade支持--output参数，将报告保存指定路径，否则报告默认生成在BulletTrade输出目
录，可手动复制。
# (BulletTrade自动生成HTML报告，包含收益曲线、指标等 8 )
# 4. 转换报告并生成AI分析
python modules/report_generator.py \
--html backtests/my_strategy/v3/report_v3.html \
--out backtests/my_strategy/v3/report_v3.md
# report_generator.py 将解析HTML提取数据，并调用LLM接口生成Markdown分析报告。
# 5. 部署策略实盘运行 (连接QMT本地客户端)
bullet-trade live strategies/my_strategy_v3.py --broker qmt \
> live_trading/logs/live_$(date +%F).log 2>&1 &
# 以上命令在后台启动实盘策略，日志重定向保存。当策略需要停止时，可杀掉进程或使用BulletTrade提
供的停止命令。
上述步骤说明：首先安装并配置BulletTrade，然后开发者编写或更新策略代码并保存版本。接着使用 BulletTrade
CLI 的 backtest 命令运行回测 9 （可通过命令行参数指定回测区间、频率等）。BulletTrade运行结束后，会在
标准输出或指定文件生成回测报告（这里假设添加了 --output 参数直接保存报告文件）。接下来调用我们自定义
的 report_generator.py 模块，将BulletTrade生成的报告进行加工：它可以读取HTML文件，提取关键图表并
保存为图片，同时统计指标，再通过调用OpenAI API或本地大模型生成带分析说明的Markdown报告文件。然后在
决定部署实盘时，使用 bullet-trade live 命令启动策略连接真实券商环境。例如上述命令将策略以后台进程
方式连接本地QMT；如果需要远程Windows券商，则使用 --broker qmt-remote 并确保提前运行了 bullet-
trade server 服务 14 。整个流程也可包装成一键脚本或由CI/CD工具触发，例如每当推送新的策略代码时自动
运行回测和报告生成，这样量化团队可以快速看到最新策略效果。
关键模块功能说明：
• bt_run.py – 回测执行模块: 该模块封装了BulletTrade的回测调用流程，方便在Python脚本或CI流程中
调用。它可以解析输入的策略脚本路径和回测参数（起止日期、频率、基准等），构造命令行或直接调用
BulletTrade内部API执行回测。功能上相当于对 bullet-trade backtest 的再封装，但增加了灵活
性。例如，可通过函数调用 run_backtest(strategy_path, config) 启动回测，并监听回测进程的
输出。当回测完成后， bt_run.py 还可以自动将生成的报告文件和数据移动到预定目录（如
backtests/... ），并调用 report_generator.py 产生分析报告，实现回测到报告的一站式执行。
调用示例: 在终端执行 python modules/bt_run.py --strategy strategies/
7


=== 第 8 页 ===

my_strategy_v3.py --start 2020-01-01 --end 2023-12-31 , 该模块会调用BulletTrade运行回
测并输出结果文件至指定位置，然后结束。
• report_generator.py – 报告生成与AI分析模块: 该模块负责将回测或实盘结果转化为Markdown文
档，融合数据分析和LLM描述。它包括两个主要功能：一是 数据提取，支持从BulletTrade输出的HTML报告
或CSV数据中提取必要的信息与图表；二是 AI生成，将提取的信息作为Prompt发给大语言模型并获取分析
文字。模块实现上，可使用Python的HTML解析库（如BeautifulSoup）读取HTML报告，定位净值曲线
<div>或<img>元素，将图表截图保存（如果HTML已包含图像可直接导出） 8 ；或者通过重新绘制净值曲
线（基于保存的净值CSV）生成图像文件。然后收集诸如累计收益、年化、回撤等指标数值，构造一段提示
语，例如：“策略在回测期间取得XX%的年化收益率，最大回撤YY%，Sharpe比率ZZ。请分析该策略的表现
并给出评价。” 将此提示发送给LLM API（如调用OpenAI的接口或本地LLM服务），获取模型返回的分析段
落。最后，将文字分析与图表嵌入Markdown模板，生成完整报告文档。功能示例: 可以通过 python
modules/report_generator.py --html backtests/my_strategy/v3/report_v3.html --
out backtests/my_strategy/v3/report_v3.md 来运行，脚本将输出生成的Markdown文件路径。
对于每日实盘，亦可传入当日交易数据文件，生成日分析报告。该模块极大减少了人工撰写报告的工作量，
确保每次回测和每日实盘都有规范的报告输出。
• trading_engine.py – 实盘交易引擎模块: 此模块封装策略实盘运行的启动、监控和停止逻辑，提供比
直接调用BulletTrade更高层的管理功能。通过 trading_engine.py ，我们可以编程式地部署多个策略
实例，并对其运行状态进行监控。其主要职责包括：加载指定策略代码和配置，初始化BulletTrade实时运
行环境，设置所需的券商接口（如选择本地QMT或调用相应broker适配器），以及启动行情订阅和交易循
环。同时，挂接我们自定义的风控监控：例如在每个Bar结束后检查账户净值变化，或在每笔交易后调用风
控函数评估风险。如遇异常情况（如订单被拒、连续亏损达到阈值等）， trading_engine.py 可以触发
预定的处理逻辑（报警、平仓或重启策略）。实现上， trading_engine.py 可能通过启动一个子进程运
行 bullet-trade live 命令并捕获其输出日志，或者如果BulletTrade提供Python接口，则直接在一个
线程中调用其 LiveTrading 对象的方法。为了与我们的系统集成， trading_engine.py 也会周期性
输出Heartbeat信号和状态报告，使外部监控知道策略仍在健康运行。使用示例: 开发者可以通过 python
modules/trading_engine.py --strategy my_strategy_v3 --broker qmt --
risk_profile conservative 来启动策略v3的实盘进程，其中参数 --broker 指明券商接口， --
risk_profile 可选择不同风控方案。停止时，可以运行 python modules/trading_engine.py --
stop my_strategy_v3 来平滑关闭对应进程。通过这样统一的引擎模块，我们可以方便地管理多策略实
盘部署，例如实现多个策略并行跑以及分布式部署等。
• 券商适配模块 ( broker_qmt.py , broker_hs.py , broker_juejin.py 等) – 这些模块实现与不同
交易柜台API的对接。BulletTrade自身内置了QMT的接口，但在我们系统中，为了支持扩展，我们将其封装
到 broker_qmt.py 中。这个模块对上提供统一的方法，如 connect() , place_order(order) ,
cancel_order(order_id) , get_positions() 等，由 trading_engine.py 调用；对下则通过
调用具体券商的SDK或API实现实际功能。例如， broker_qmt.py 内部利用BulletTrade框架已实现的同
券商通信机制来派发订单。而 broker_hs.py 则可能使用恒生PTrade提供的Python API接口（假设其API
类似于： hs.open_account(...) , hs.order(stock, price, volume) 等）来实现这些方法
16 。 broker_juejin.py 类似地对接掘金量化的HTTP/WebSocket API，转换BulletTrade发来的交易
请求为掘金的REST调用。通过这种适配层设计， trading_engine.py 无需关心底层券商差异，只需根据
配置加载不同的broker模块即可。例如，当配置使用恒生交易时， trading_engine.py 会 import
broker_hs as broker ，然后调用 broker.connect() 建立连接。新增一个券商支持也很方便：只需
8


=== 第 9 页 ===

新建一个同样接口的模块，并将其集成到配置管理中。值得一提的是，这种设计类似于vn.py框架的多接口
网关思想 27 ，但我们保留了聚宽策略范式，使用户不必重写策略代码就能切换交易后端。
• BulletTrade聚宽兼容机制: BulletTrade 之所以能够让聚宽策略直接迁移运行，核心在于其内部构建了与聚
宽平台一致的API环境和数据结构 28 3 。例如，BulletTrade定义了 context 对象，包含 portfolio
(与聚宽相同的持仓/账户信息结构)、 g 全局变量空间等，以容纳策略状态；实现了聚宽常用的函数如
get_price （历史数据获取）、 attribute_history 、 get_current_data 、 order /
order_value / order_target 等交易函数，以及调度函数如 run_daily 、 schedule_function
等。当策略代码通过 from jqdata import * 引入时 29 ，BulletTrade提供了一个假的 jqdata 模块
或采用与聚宽相同的命名，确保策略代码不报错。同时，对于聚宽特有的一些上下文，如证券代码格式
（000001.XSHE等）、时间处理、停牌信息，BulletTrade也尽可能做了兼容转换。因此，当用户将聚宽上
的策略代码复制到本地，“在聚宽怎么写，在 BulletTrade 就怎么写” 3 基本成立。仅有极少部分聚宽独有
功能（例如策略在研究环境中的画图函数）在BulletTrade中可能未实现或实现方式稍有区别，但常见交易
策略逻辑层面的API已大部分支持 30 。这种高度兼容性使得代码无需改动即可从回测切换到实盘 4 ，显著
降低了用户从聚宽迁移到本地量化系统的门槛。对于韬睿量化团队而言，这意味着先前在聚宽研究环境中开
发的众多策略都可以平滑过渡进BulletTrade驱动的新系统，保护了已有的研发成果。
功能扩展设计与社区实现参考
虽然 BulletTrade 已经提供了从回测到实盘的大部分关键功能，但要构建一个完善的全生命周期策略管理系统，我
们可能还需针对某些BulletTrade暂未覆盖的功能进行扩展设计。以下列出若干扩展方向和可借鉴的社区方案：
• 多券商/跨平台交易支持： 当前BulletTrade主要聚焦于A股及QMT通道，对于其他市场（如期货、期权、外
汇）或其他券商接口（如恒生UFT、IB、CTP等）需要手动扩展适配。设计上，我们可以引入插件式交易桥
接框架：抽象出统一的交易接口（connect, order, cancel, query等），通过配置加载不同市场的网关插
件。这类似于vn.py框架的网关机制，多市场多券商并行支持 27 。社区中，vn.py 已实现了CTP（期货）、
IB（盈透）、XTP（沪深高速柜台）等众多接口的封装，展示了良好的模块化设计。我们可以参考vn.py的接
口规范，将其作为BulletTrade的一个补充模块，使策略代码调用统一的下单函数，而背后路由到相应市场
网关。例如，为期货交易设计一个 broker_ctp.py ，接入CTP接口库；为美股设计一个
broker_ib.py ，使用IB Python API等等。对于恒生PTrade，正如前文所述，其本身就是多市场交易终
端 17 且支持Python接口，我们可以考虑双管齐下：短期内通过BulletTrade扩展适配恒生API，长期来看关
注恒生官方的开放方案。如果恒生未来开放类似REST的接口，则可直接对接。总之，通过模块化的Broker
架构，我们的系统能够扩展支持更多券商和市场，满足团队跨市场量化的需求。
• 行情接口与数据源扩展： BulletTrade目前支持的行情数据源包括TuShare、JQData、MiniQMT等 12 ，主
要覆盖A股及通用金融数据。如果策略需要使用境外市场数据或特殊数据（比如期权Greeks、链上加密货币
行情等），我们需要扩展数据提供模块。BulletTrade的设计已经考虑了多数据源，通过配置快速切换 21 。
我们可以照葫芦画瓢，新建数据源类如 MyDataProvider ，实现获取历史数据和实时订阅的方法，然后将
其集成到BulletTrade的数据源注册表中。这样一来，策略代码仍然调用 get_price 等接口，BulletTrade
内部会调用我们实现的数据源获取相应数据。例如，要接入某外汇行情API，可实现
ForexDataProvider 类，并在.env里设 DEFAULT_DATA_PROVIDER=forex ，策略无需改动直接获取
外汇价格。同理，接入加密货币行情WebSocket也可通过类似方式实现。社区项目方面，可以借鉴
QuantConnect Lean开源框架的数据Feed模块，或者国内Ricequant米筐等平台在多市场数据方面的处理
思路。总之，我们通过制定统一的数据接口规范，让不同来源的数据都能为策略所用，增强系统的数据适应
性。BulletTrade官方也计划支持更多数据源 31 ，我们可以参与社区共建，加快该功能落地。
9


=== 第 10 页 ===

• AI分析与智能决策接口：目前我们利用LLM主要做了报告自动生成的工作，但AI在量化系统中的作用可以进
一步扩大。例如，构建一个AI分析接口，让策略可以在运行中实时咨询AI决策：如在盘中根据新闻或公告摘
要调用LLM判断事件影响，或在策略触发信号时让AI评估当前市场情绪提供辅助判断。这需要将LLM调用封
装成一个可控的服务接口，可在策略代码或引擎模块中调用。设计上，可在 modules/ai_analysis.py
中实现一个通用函数，如 analyze_performance(context) 或 summarize_news(text) 等，内部
调用大模型完成指定任务。策略逻辑便可尝试融合AI的信息，例如当传统量化信号临界时，引入AI对宏观新
闻的判断来过滤交易信号，形成简易的多模态策略。这方面的尝试在业界已有所探索，如中金公司提出的大
模型动态策略配置框架，将LLM用于组合管理决策 11 。他们的报告描述了一个“三层架构”，其中分析层自
动化绩效分析并生成报告，决策层引入LLM基于报告输出调整策略权重 32 。这实际上证明了LLM可以深入
参与量化策略的分析和优化流程。我们在韬睿系统中可以逐步试验：先由AI产出分析建议，再由人来审阅；
待成熟后，可考虑半自动地让AI调整部分参数甚至直接生成新策略版本代码（在沙盒回测验证后才部署）。
技术实现上，需要解决调用效率和安全问题——或许引入本地部署的开源大模型（如ChatGLM、Llama2
等）来保证隐私和降低成本。此外，社区也出现了一些结合Agent思路的项目，例如利用GPT自行迭代寻找
Alpha策略 33 或自治执行交易的Agent Trader 34 。这些案例显示了AI深度参与量化交易的可能性。我们
的系统在设计上保留AI接口的可扩展性，使得未来可以无缝挂接这类创新功能。
• 可视化监控和GUI前端：一个完善的量化系统通常还包括直观的监控界面，如策略运行状态仪表盘、持仓盈
亏实时曲线、交易告警推送等。BulletTrade官方 roadmap 中也提到了Web UI监控面板的计划 31 。在该
功能推出前，我们可以自行搭建简单的Dashboard。例如使用Python的Flask/Django构建一个网页前端，
读取 live_trading/ 日志和持仓文件，实时显示策略业绩曲线和持仓变化。同时集成报警模块：当风险
指标超限时，通过邮件、短信或企业微信通知管理员。目前社区有一些开源项目如 QuantWeb 或券商提供
的监控终端，可供参考。我们也可以将BulletTrade运行时的一些关键事件通过socket广播，前端订阅显示
以达到实时监控效果。虽然这部分不直接影响策略逻辑，但对运维体验至关重要。随着团队策略规模扩大，
多策略多账户同时运行时，一个集中的可视化监控平台能够大大提高效率。我们建议优先利用BulletTrade
未来的官方Web UI，如果等待期间需要，可以采用轻量方式先实现主要监控需求，后续再平滑过渡。
综上所述，通过模块化的扩展设计，我们确保BulletTrade框架可以适应更广泛的交易场景和功能需求。例如，如果
团队未来需要支持美股期权策略，我们只需添加相应的数据源和交易接口模块，而无需推翻整个系统重来。借鉴社
区成熟项目的经验（如vn.py的多接口架构、恒生PTrade的AI功能 16 17 、中金LLM策略配置 11 等），可以少走
弯路，加速实现我们的目标。
最终目标展望：通过本方案的实施，韬睿量化团队将拥有一个BulletTrade驱动的全生命周期策略研发/部署系统。
它集策略开发、回测验证、实盘交易、绩效分析于一体，实现了从模型创意到实盘收益的闭环管理。所有策略产出
（代码、数据、报告）都被文档化且版本管理，团队可以长期积累知识财富。在AI的辅助下，策略优化和运维进入
半自动化时代：机器高效完成数据分析和报告撰写，人类专注决策和创造。每当市场变化，系统记录的丰富历史和
AI建议将帮助团队迅速迭代应对。可以预见，随着更多功能（如跨市场交易、智能决策代理）的引入，系统将不断
进化，保持我们在量化交易领域的竞争力。这一方案奠定了基础架构，我们将据此逐步实现韬睿量化团队的长期演
化与高效管理，迈向智能量化的新阶段。
参考文献：
1. BigBenCat, “聚宽策略想实盘？这个开源项目让你一行代码不改直接跑,” 博客园, 2025 1 2 3 8 13
14 . (介绍了BulletTrade框架的定位、功能和使用方法，包含聚宽代码兼容、一键回测生成报告、本地/远
程实盘接入等关键信息)
10


=== 第 11 页 ===

2. 恒生电子, “PTrade量化交易系统介绍,” 山西证券官网, 2025 16 17 . (阐述了恒生PTrade终端的功能特点，包
括多交易接口支持、自动化交易、回测和风险控制等，为我们扩展恒生接口提供了参考)
3. 中金公司研究部, “大模型系列（4）：LLM动态模型配置,” 新浪财经, 2025 11 . (提出了将大模型用于策略绩
效分析和组合决策的框架，其中自动化绩效分析和LLM决策层的概念对我们的AI报告生成和智能决策模块很
有启发)
4. BigBenCat, BulletTrade GitHub 项目README, 2025 30 31 . (BulletTrade开源项目说明了已支持功能和未
来规划，包括多数据源、CLI工具链、Web监控等，我们据此制定了系统的扩展方向)
5. CSDN博客, “2025年免费量化交易软件——PTrade（含开通攻略）,” 2025 35 22 . (进一步介绍了PTrade的
特性，如支持股票期货多品种、一键下单和止盈止损功能、实时风险监控和量化社区等，为我们的系统引入
这些功能提供了思路)
1 2 3 4 5 6 7 8 9 10 12 13 14 15 18 19 20 21 23 24 25 26 27 28 29 30 31 聚宽策略想
实盘？这个开源项目让你一行代码不改直接跑 - bigbencat - 博客园
https://www.cnblogs.com/bullettrade/p/19308512
11 32 中金 | 大模型系列（4）：LLM动态模型配置|中金_新浪财经_新浪网
https://finance.sina.com.cn/stock/stockzmt/2025-09-23/doc-infrmtus0762794.shtml
16 17 22 35 2025年免费量化交易软件——PTrade（含开通攻略）-CSDN博客
https://blog.csdn.net/XD1996CD/article/details/145262152
33 利用LLMs自动寻找量化投资策略_llm 量化交易 - CSDN博客
https://blog.csdn.net/qq_39970492/article/details/142675750
34 LLM Agent Trader: 當ChatGPT遇上股票交易，我打造了一個會思考的 ...
https://wenwender.wordpress.com/2025/08/12/%F0%9F%A4%96-llm-agent-trader-
%E7%95%B6chatgpt%E9%81%87%E4%B8%8A%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%EF%BC%8C%E6%88%91%E6%89%93%E9%80%A0%E4%BA%86%E4%B8%80%E5%80%8B%E6%9C%83%E6%80%9D%E8%80%83%E7%9A%84/
11