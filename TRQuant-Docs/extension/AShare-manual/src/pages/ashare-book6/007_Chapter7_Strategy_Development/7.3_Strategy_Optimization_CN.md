---
title: "7.3 ç­–ç•¥ä¼˜åŒ–"
description: "æ·±å…¥è§£æç­–ç•¥ä¼˜åŒ–ç³»ç»Ÿï¼ŒåŒ…æ‹¬å‚æ•°è°ƒä¼˜ã€å› å­æƒé‡ä¼˜åŒ–ã€é£æ§å‚æ•°ä¼˜åŒ–ã€ç­–ç•¥é€»è¾‘ä¼˜åŒ–ç­‰æ ¸å¿ƒæŠ€æœ¯"
lang: "zh-CN"
layout: "/src/layouts/HandbookLayout.astro"
currentBook: "ashare-book6"
updateDate: "2025-12-12"
---

# âš¡ 7.3 ç­–ç•¥ä¼˜åŒ–

> **æ ¸å¿ƒæ‘˜è¦ï¼š**
> 
> æœ¬èŠ‚ç³»ç»Ÿä»‹ç»TRQuantç³»ç»Ÿçš„ç­–ç•¥ä¼˜åŒ–ç³»ç»Ÿï¼Œä½œä¸ºå¹¿ä¹‰ç­–ç•¥ç”Ÿæˆçš„å…³é”®ç»„ä»¶ï¼Œè´Ÿè´£æ¥æ”¶å‰åºæ­¥éª¤ä¿¡æ¯å’Œå›æµ‹ç»“æœï¼Œå¯¹ç­–ç•¥è¿›è¡Œè¿­ä»£ä¼˜åŒ–ã€‚é€šè¿‡ç†è§£å‚æ•°è°ƒä¼˜ã€å› å­æƒé‡ä¼˜åŒ–ã€é£æ§å‚æ•°ä¼˜åŒ–ã€ç­–ç•¥é€»è¾‘ä¼˜åŒ–å’Œæ™ºèƒ½ä¼˜åŒ–ç®—æ³•ï¼Œå¸®åŠ©å¼€å‘è€…æŒæ¡å¦‚ä½•å¯¹ç”Ÿæˆçš„ç­–ç•¥è¿›è¡Œä¼˜åŒ–ï¼Œæé«˜ç­–ç•¥æ€§èƒ½å’Œç¨³å¥æ€§ã€‚

ç­–ç•¥ä¼˜åŒ–æ˜¯å¹¿ä¹‰ç­–ç•¥ç”Ÿæˆçš„å…³é”®ç»„ä»¶ï¼Œä½äºç­–ç•¥ç”Ÿæˆä¹‹åã€å›æµ‹éªŒè¯ä¹‹å‰ï¼Œæ¥æ”¶å‰åºæ­¥éª¤ä¿¡æ¯å’Œå›æµ‹ç»“æœè¿›è¡Œè¿­ä»£ä¼˜åŒ–ã€‚

## ğŸ“‹ ç« èŠ‚æ¦‚è§ˆ

<script>
function scrollToSection(sectionId) {
  const element = document.getElementById(sectionId);
  if (element) {
    const headerOffset = 100;
    const elementPosition = element.getBoundingClientRect().top;
    const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
    window.scrollTo({
      top: offsetPosition,
      behavior: 'smooth'
    });
  }
}
</script>

<div class="section-overview">
  <div class="section-item" onclick="scrollToSection('section-7-3-1')">
    <h4>ğŸ¯ 7.3.1 ä¼˜åŒ–å®šä½ä¸æµç¨‹</h4>
    <p>ç­–ç•¥ä¼˜åŒ–åœ¨å·¥ä½œæµä¸­çš„å®šä½ã€é¦–æ¬¡ä¼˜åŒ–æµç¨‹ã€è¿­ä»£ä¼˜åŒ–æµç¨‹</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-7-3-2')">
    <h4>ğŸ“Š 7.3.2 å‚æ•°è°ƒä¼˜</h4>
    <p>å› å­æƒé‡ä¼˜åŒ–ã€é£æ§å‚æ•°ä¼˜åŒ–ã€è°ƒä»“é¢‘ç‡ä¼˜åŒ–ã€é€‰è‚¡æ•°é‡ä¼˜åŒ–</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-7-3-3')">
    <h4>ğŸ§  7.3.3 æ™ºèƒ½ä¼˜åŒ–ç®—æ³•</h4>
    <p>ç½‘æ ¼æœç´¢ã€éšæœºæœç´¢ã€è´å¶æ–¯ä¼˜åŒ–ã€é—ä¼ ç®—æ³•ã€å¼ºåŒ–å­¦ä¹ </p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-7-3-4')">
    <h4>ğŸ”„ 7.3.4 ç­–ç•¥é€»è¾‘ä¼˜åŒ–</h4>
    <p>é€‰è‚¡é€»è¾‘ä¼˜åŒ–ã€æ‹©æ—¶é€»è¾‘ä¼˜åŒ–ã€é£æ§é€»è¾‘ä¼˜åŒ–ã€æ‰§è¡Œé€»è¾‘ä¼˜åŒ–</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-7-3-5')">
    <h4>ğŸ“ˆ 7.3.5 Walk-Forwardåˆ†æ</h4>
    <p>æ—¶é—´åºåˆ—åˆ†å‰²ã€è®­ç»ƒé›†ä¼˜åŒ–ã€æµ‹è¯•é›†éªŒè¯ã€ç¨³å¥æ€§è¯„ä¼°</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-7-3-6')">
    <h4>ğŸ¤– 7.3.6 è‡ªåŠ¨åŒ–ä¸æ™ºèƒ½åŒ–</h4>
    <p>è‡ªåŠ¨è§¦å‘ä¼˜åŒ–ã€è‡ªåŠ¨è¿­ä»£ä¼˜åŒ–ã€AIè¾…åŠ©ä¼˜åŒ–ã€å·¥ä½œæµé›†æˆ</p>
  </div>
</div>

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬èŠ‚å­¦ä¹ ï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- **ç†è§£ä¼˜åŒ–å®šä½**ï¼šæŒæ¡ç­–ç•¥ä¼˜åŒ–åœ¨å·¥ä½œæµä¸­çš„å®šä½å’Œä½œç”¨
- **å®ç°å‚æ•°è°ƒä¼˜**ï¼šç†è§£å› å­æƒé‡ä¼˜åŒ–ã€é£æ§å‚æ•°ä¼˜åŒ–ç­‰æ–¹æ³•
- **åº”ç”¨ä¼˜åŒ–ç®—æ³•**ï¼šæŒæ¡ç½‘æ ¼æœç´¢ã€è´å¶æ–¯ä¼˜åŒ–ç­‰æ™ºèƒ½ä¼˜åŒ–ç®—æ³•
- **ä¼˜åŒ–ç­–ç•¥é€»è¾‘**ï¼šç†è§£é€‰è‚¡é€»è¾‘ã€æ‹©æ—¶é€»è¾‘ç­‰ç­–ç•¥é€»è¾‘ä¼˜åŒ–
- **è¿›è¡ŒWalk-Forwardåˆ†æ**ï¼šæŒæ¡æ—¶é—´åºåˆ—åˆ†å‰²å’Œç¨³å¥æ€§è¯„ä¼°æ–¹æ³•

## ğŸ“š æ ¸å¿ƒæ¦‚å¿µ

### æ¨¡å—å®šä½

- **å·¥ä½œæµä½ç½®**ï¼šæ­¥éª¤6.5 - âš¡ ç­–ç•¥ä¼˜åŒ–ï¼ˆå¹¿ä¹‰ç­–ç•¥ç”Ÿæˆçš„å…³é”®ç»„ä»¶ï¼‰
- **æ ¸å¿ƒèŒè´£**ï¼šå‚æ•°è°ƒä¼˜ã€å› å­æƒé‡ä¼˜åŒ–ã€ç­–ç•¥é€»è¾‘ä¼˜åŒ–ã€è¿­ä»£æ”¹è¿›
- **æœåŠ¡å¯¹è±¡**ï¼šç­–ç•¥ç”Ÿæˆï¼ˆæ­¥éª¤6ï¼‰ã€å›æµ‹éªŒè¯ï¼ˆæ­¥éª¤7ï¼‰

### è®¾è®¡ç†å¿µ

ç­–ç•¥ä¼˜åŒ–ç³»ç»Ÿéµå¾ªä»¥ä¸‹è®¾è®¡ç†å¿µï¼š

1. **è¿­ä»£æ”¹è¿›**ï¼šé€šè¿‡å¤šè½®ä¼˜åŒ–è¿­ä»£ï¼Œé€æ­¥æå‡ç­–ç•¥æ€§èƒ½
2. **çŸ¥è¯†é©±åŠ¨**ï¼šåŸºäºå‰åºæ­¥éª¤ä¿¡æ¯å’Œå›æµ‹ç»“æœè¿›è¡Œä¼˜åŒ–
3. **ç¨³å¥æ€§ä¼˜å…ˆ**ï¼šé¿å…è¿‡æ‹Ÿåˆï¼Œç¡®ä¿ç­–ç•¥åœ¨ä¸åŒå¸‚åœºç¯å¢ƒä¸‹çš„ç¨³å¥æ€§
4. **è‡ªåŠ¨åŒ–**ï¼šæ”¯æŒè‡ªåŠ¨è§¦å‘å’Œè‡ªåŠ¨è¿­ä»£ä¼˜åŒ–
5. **æ™ºèƒ½åŒ–**ï¼šä½¿ç”¨AIç®—æ³•æ™ºèƒ½æ¢ç´¢å‚æ•°ç©ºé—´

<h2 id="section-7-3-1">ğŸ¯ 7.3.1 ä¼˜åŒ–å®šä½ä¸æµç¨‹</h2>

ç­–ç•¥ä¼˜åŒ–æ˜¯å¹¿ä¹‰ç­–ç•¥ç”Ÿæˆçš„å…³é”®ç»„ä»¶ï¼Œä¸ç­–ç•¥ç”Ÿæˆå…±åŒæ„æˆå®Œæ•´çš„ç­–ç•¥å¼€å‘æµç¨‹ã€‚

### ä¼˜åŒ–å®šä½

ç­–ç•¥ä¼˜åŒ–ä¸æ˜¯ç‹¬ç«‹çš„æ­¥éª¤ï¼Œè€Œæ˜¯**å¹¿ä¹‰ç­–ç•¥ç”Ÿæˆçš„å…³é”®ç»„ä»¶**ï¼š

```
ç­–ç•¥ç”Ÿæˆï¼ˆæ­¥éª¤6ï¼‰
    â†“
æ¥æ”¶å‰åºä¿¡æ¯ï¼š
  - å¸‚åœºçŠ¶æ€ï¼ˆæ­¥éª¤2ï¼‰
  - æŠ•èµ„ä¸»çº¿ï¼ˆæ­¥éª¤3ï¼‰
  - å€™é€‰æ± ï¼ˆæ­¥éª¤4ï¼‰
  - å› å­æ¨èï¼ˆæ­¥éª¤5ï¼‰
    â†“
ç­–ç•¥ä¼˜åŒ–ï¼ˆæ­¥éª¤6.5ï¼‰â† å…³é”®ç»„ä»¶
  - å‚æ•°è°ƒä¼˜
  - å› å­æƒé‡ä¼˜åŒ–
  - é£æ§å‚æ•°ä¼˜åŒ–
  - ç­–ç•¥é€»è¾‘ä¼˜åŒ–
    â†“
è¾“å‡ºä¼˜åŒ–åçš„ç­–ç•¥
    â†“
å›æµ‹éªŒè¯ï¼ˆæ­¥éª¤7ï¼‰
    â†“
å›æµ‹ç»“æœåé¦ˆ
    â†“
å†ä¼˜åŒ–ï¼ˆè¿­ä»£ï¼‰
    â†“
æœ€ç»ˆä¼˜åŒ–ç­–ç•¥
```

### é¦–æ¬¡ä¼˜åŒ–æµç¨‹

<CodeFromFile 
  filePath="code_library/007_Chapter7_Strategy_Development/7.3/code_7_3_first_optimization.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
from core.strategy_optimizer import StrategyOptimizer
from core.factor_weight_optimizer import FactorWeightOptimizer

def first_optimization(
    strategy: Dict[str, Any],
    market_context: Dict[str, Any],
    mainlines: List[Dict],
    candidate_pool: List[str],
    factor_recommendations: List[Dict]
) -> Dict[str, Any]:
    """
    é¦–æ¬¡ç­–ç•¥ä¼˜åŒ–
    
    Args:
        strategy: åˆå§‹ç­–ç•¥ï¼ˆæ¥è‡ªæ­¥éª¤6ï¼‰
        market_context: å¸‚åœºçŠ¶æ€ï¼ˆæ¥è‡ªæ­¥éª¤2ï¼‰
        mainlines: æŠ•èµ„ä¸»çº¿ï¼ˆæ¥è‡ªæ­¥éª¤3ï¼‰
        candidate_pool: å€™é€‰æ± ï¼ˆæ¥è‡ªæ­¥éª¤4ï¼‰
        factor_recommendations: å› å­æ¨èï¼ˆæ¥è‡ªæ­¥éª¤5ï¼‰
    
    Returns:
        Dict: ä¼˜åŒ–ç»“æœ
    """
    optimizer = StrategyOptimizer()
    
    # 1. åˆ†æå‰åºä¿¡æ¯
    market_regime = market_context.get('regime', 'neutral')
    mainline_names = [m.get('name', '') for m in mainlines]
    factors = [f.get('name', '') for f in factor_recommendations]
    
    # 2. é…ç½®ä¼˜åŒ–ç›®æ ‡
    optimization_config = {
        'target_metric': 'sharpe_ratio',
        'direction': 'maximize',
        'min_sharpe': 1.5,
        'max_drawdown_limit': 0.15,
        'algorithm': 'grid_search'
    }
    
    # 3. æ‰§è¡Œä¼˜åŒ–
    result = optimizer.optimize(
        strategy=strategy,
        market_context=market_context,
        mainlines=m<CodeFromFile 
  filePath="code_library/007_Chapter7_Strategy_Development/7.3/code_7_3_iterative_optimization.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
def iterative_optimization(
    strategy: Dict[str, Any],
    backtest_result: Dict[str, Any],
    market_context: Dict[str, Any],
    max_iterations: int = 5
) -> Dict[str, Any]:
    """
    è¿­ä»£ä¼˜åŒ–æµç¨‹
    
    Args:
        strategy: å½“å‰ç­–ç•¥
        backtest_result: å›æµ‹ç»“æœ
        market_context: å¸‚åœºçŠ¶æ€
        max_iterations: æœ€å¤§è¿­ä»£æ¬¡æ•°
    
    Returns:
        Dict: æœ€ç»ˆä¼˜åŒ–ç»“æœ
    """
    optimizer = StrategyOptimizer()
    current_strategy = strategy
    iteration = 0
    
    while iteration < max_iterations:
        # æ£€æŸ¥æ˜¯å¦æ»¡è¶³è¦æ±‚
        sharpe_ratio = backtest_result.get('sharpe_ratio', 0)
        max_drawdown = backtest_result.get('max_drawdown', 1.0)
        
        if sharpe_ratio >= 1.5 and max_drawdown <= 0.15:
            logger.info(f"âœ… ç­–ç•¥å·²æ»¡è¶³è¦æ±‚ï¼Œåœæ­¢ä¼˜åŒ–")
            break
        
        # åˆ†æå›æµ‹ç»“æœï¼Œè¯†åˆ«ä¼˜åŒ–ç‚¹
        optimization_points = optimizer.analyze_backtest_result(backtest_result)
        
        # æ‰§è¡Œä¼˜åŒ–
        optimization_result = optimizer.optimize(
            strategy=current_strategy,
            backtest_result=backtest_result,
            market_context=market_context,
            optimization_points=optimization_points
        )
        
        # æ›´æ–°ç­–ç•¥
        current_strategy = optimization_result['optimized_strategy']
        
        # å†æ¬¡å›æµ‹ï¼ˆè¿™é‡Œéœ€è¦è°ƒç”¨å›æµ‹æ¨¡å—ï¼‰
        # backtest_result = run_backtest(current_strategy)
        
        iteration += 1
        logger.info(f"è¿­ä»£ {iteration}/{max_iterations} å®Œæˆ")
    
    return {
        'optimized_strategy': current_stra<CodeFromFile 
  filePath="code_library/007_Chapter7_Strategy_Development/7.3/code_7_3___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
from core.factor_weight_optimizer import FactorWeightOptimizer, MarketScenario

class FactorWeightOptimizer:
    """å› å­æƒé‡ä¼˜åŒ–å™¨"""
    
    def __init__(self):
        self.scenario_library = SCENARIO_WEIGHT_LIBRARY
    
    def optimize_by_scenario(
        self,
        factors: List[str],
        market_scenario: MarketScenario
    ) -> Dict[str, float]:
        """
        æ ¹æ®å¸‚åœºæƒ…æ™¯ä¼˜åŒ–å› å­æƒé‡
        
        **è®¾è®¡åŸç†**ï¼š
        - **æƒ…æ™¯åº“é©±åŠ¨**ï¼šåŸºäºé¢„è®¾çš„å¸‚åœºæƒ…æ™¯åº“ï¼Œä¸ºä¸åŒå¸‚åœºç¯å¢ƒé…ç½®æœ€ä¼˜å› å­æƒé‡
        - **ç±»å‹æ˜ å°„**ï¼šå°†å…·ä½“å› å­æ˜ å°„åˆ°å› å­ç±»å‹ï¼Œä½¿ç”¨ç±»å‹çº§åˆ«çš„æƒé‡é…ç½®
        - **æƒé‡å½’ä¸€åŒ–**ï¼šç¡®ä¿æ‰€æœ‰æƒé‡ä¹‹å’Œä¸º1ï¼Œä¿è¯æƒé‡åˆ†é…çš„åˆç†æ€§
        
        **ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡**ï¼š
        1. **é€‚åº”æ€§**ï¼šä¸åŒå¸‚åœºç¯å¢ƒï¼ˆç‰›å¸‚ã€ç†Šå¸‚ã€éœ‡è¡å¸‚ï¼‰éœ€è¦ä¸åŒçš„å› å­æƒé‡
        2. **å¯ç»´æŠ¤æ€§**ï¼šæƒ…æ™¯åº“é›†ä¸­ç®¡ç†ï¼Œä¾¿äºè°ƒæ•´å’Œæ‰©å±•
        3. **çµæ´»æ€§**ï¼šæ”¯æŒå› å­ç±»å‹æ˜ å°„ï¼Œé€‚åº”ä¸åŒå› å­ç»„åˆ
        
        **ä½¿ç”¨åœºæ™¯**ï¼š
        - æ ¹æ®å½“å‰å¸‚åœºçŠ¶æ€ï¼ˆrisk_on/risk_off/neutralï¼‰è°ƒæ•´å› å­æƒé‡
        - ä¸åŒå¸‚åœºé˜¶æ®µï¼ˆç‰›å¸‚ã€ç†Šå¸‚ã€éœ‡è¡å¸‚ï¼‰ä½¿ç”¨ä¸åŒæƒé‡é…ç½®
        - ç­–ç•¥ä¼˜åŒ–æ—¶ï¼Œæ ¹æ®å¸‚åœºæƒ…æ™¯é€‰æ‹©æœ€ä¼˜æƒé‡
        
        **æ³¨æ„äº‹é¡¹**ï¼š
        - æƒ…æ™¯åº“éœ€è¦å®šæœŸæ›´æ–°ï¼Œåæ˜ å¸‚åœºå˜åŒ–
        - å› å­ç±»å‹æ˜ å°„éœ€è¦å‡†ç¡®ï¼Œå¦åˆ™æƒé‡åˆ†é…å¯èƒ½ä¸åˆç†
        - é»˜è®¤ç­‰æƒä½œä¸ºé™çº§æ–¹æ¡ˆï¼Œä¿è¯ç³»ç»Ÿå¯ç”¨æ€§
        
        Args:
            factors: å› å­åˆ—è¡¨
            scenario: å¸‚åœºæƒ…æ™¯
        
        Returns:
            Dict: ä¼˜åŒ–åçš„å› å­æƒé‡ï¼ˆå·²å½’ä¸€åŒ–ï¼‰
        """
        # è®¾è®¡åŸç†ï¼šä»æƒ…æ™¯åº“è·å–é…ç½®
        # åŸå› ï¼šä¸åŒå¸‚åœºæƒ…æ™¯éœ€è¦ä¸åŒçš„å› å­æƒé‡é…ç½®
        scenario_config = self.scenario_library.get(market_scenario)
        if not scenario_config:
            # è®¾è®¡åŸç†ï¼šé»˜è®¤ç­‰æƒä½œä¸ºé™çº§æ–¹æ¡ˆ
            # åŸå› ï¼šæƒ…æ™¯åº“æœªé…ç½®æ—¶ï¼Œä½¿ç”¨ç­‰æƒä¿è¯ç³»ç»Ÿå¯ç”¨æ€§
            return {factor: 1.0 / len(factors) for factor in factors}
        
        base_weights = scenario_config['weights']
        
        # è®¾è®¡åŸç†ï¼šå› å­ç±»å‹æ˜ å°„
        # åŸå› ï¼šæƒ…æ™¯åº“é…ç½®çš„æ˜¯å› å­ç±»å‹æƒé‡ï¼Œéœ€è¦æ˜ å°„åˆ°å…·ä½“å› å­
        # å®ç°æ–¹å¼ï¼šæ ¹æ®å› å­ç±»å‹åŒ¹é…æƒé‡ï¼ŒæœªåŒ¹é…çš„ä½¿ç”¨é»˜è®¤æƒé‡
        optimized_weights = {}
        for factor in factors:
            # æ ¹æ®å› å­ç±»å‹åŒ¹é…æƒé‡
            factor_type = self._get_factor_type(factor)
            weight = base_weights.get(factor_type, 1.0 / len(factors))
            optimized_weights[factor] = weight
        
        # è®¾è®¡åŸç†ï¼šæƒé‡å½’ä¸€åŒ–
        # åŸå› ï¼šç¡®ä¿æ‰€æœ‰æƒé‡ä¹‹å’Œä¸º1ï¼Œä¿è¯æƒé‡åˆ†é…çš„åˆç†æ€§
        # å®ç°æ–¹å¼ï¼šè®¡ç®—æ€»å’Œï¼ŒæŒ‰æ¯”ä¾‹ç¼©æ”¾
        total = sum(optimized_weights.values())
        if total > 0:
            optimized_weights = {
                k: v / total for k, v in optimized_weights.items()
            }
        
        return optimized_weights
    
    def grid_search_optimize(
        self,
        factors: List[str],
        eval_func: Callable[[Dict[str, float]], float],
        weight_range: Tuple[float, float] = (0.0, 0.5),
        step: float = 0.1
    ) -> OptimizationResult:
        """
        ç½‘æ ¼æœç´¢ä¼˜åŒ–å› å­æƒé‡
        
        **è®¾è®¡åŸç†**ï¼š
        - **ç©·ä¸¾æœç´¢**ï¼šéå†æ‰€æœ‰æƒé‡ç»„åˆï¼Œæ‰¾åˆ°å…¨å±€æœ€ä¼˜è§£
        - **æƒé‡å½’ä¸€åŒ–**ï¼šæ¯ä¸ªç»„åˆéƒ½å½’ä¸€åŒ–ï¼Œç¡®ä¿æƒé‡ä¹‹å’Œä¸º1
        - **ç»“æœæ’åº**ï¼šä¿ç•™æ‰€æœ‰ç»“æœå¹¶æ’åºï¼Œä¾¿äºåˆ†æ
        
        **ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡**ï¼š
        1. **å…¨å±€æœ€ä¼˜**ï¼šç©·ä¸¾æœç´¢ä¿è¯æ‰¾åˆ°å…¨å±€æœ€ä¼˜è§£ï¼ˆåœ¨æœç´¢ç©ºé—´å†…ï¼‰
        2. **å¯è§£é‡Šæ€§**ï¼šä¿ç•™æ‰€æœ‰ç»“æœï¼Œä¾¿äºåˆ†ææƒé‡å¯¹æ€§èƒ½çš„å½±å“
        3. **é²æ£’æ€§**ï¼šè¯„ä¼°å¤±è´¥æ—¶ç»§ç»­æœç´¢ï¼Œä¸ä¸­æ–­ä¼˜åŒ–è¿‡ç¨‹
        
        **ä½¿ç”¨åœºæ™¯**ï¼š
        - å› å­æ•°é‡è¾ƒå°‘ï¼ˆ<5ï¼‰æ—¶ï¼Œè®¡ç®—é‡å¯æ¥å—
        - éœ€è¦æ‰¾åˆ°å…¨å±€æœ€ä¼˜è§£æ—¶
        - éœ€è¦åˆ†ææƒé‡å¯¹æ€§èƒ½çš„å½±å“æ—¶
        
        **æ³¨æ„äº‹é¡¹**ï¼š
        - **è®¡ç®—å¤æ‚åº¦**ï¼šO(n^m)ï¼Œnä¸ºå€™é€‰æƒé‡æ•°ï¼Œmä¸ºå› å­æ•°
        - **æ­¥é•¿é€‰æ‹©**ï¼šæ­¥é•¿è¶Šå°ï¼Œæœç´¢è¶Šç²¾ç»†ï¼Œä½†è®¡ç®—é‡è¶Šå¤§
        - **æƒé‡èŒƒå›´**ï¼šé»˜è®¤0.0-0.5ï¼Œé¿å…å•ä¸ªå› å­æƒé‡è¿‡å¤§
        
        **æ›¿ä»£æ–¹æ¡ˆå¯¹æ¯”**ï¼š
        - **æ–¹æ¡ˆAï¼šéšæœºæœç´¢**
          - ä¼˜ç‚¹ï¼šè®¡ç®—é‡å°
          - ç¼ºç‚¹ï¼šå¯èƒ½é”™è¿‡æœ€ä¼˜è§£
        - **æ–¹æ¡ˆBï¼šè´å¶æ–¯ä¼˜åŒ–**
          - ä¼˜ç‚¹ï¼šæ™ºèƒ½æœç´¢ï¼Œæ•ˆç‡é«˜
          - ç¼ºç‚¹ï¼šå®ç°å¤æ‚ï¼Œéœ€è¦è°ƒå‚
        - **å½“å‰æ–¹æ¡ˆï¼šç½‘æ ¼æœç´¢**
          - ä¼˜ç‚¹ï¼šå…¨å±€æœ€ä¼˜ï¼Œç»“æœå¯è§£é‡Š
          - ç¼ºç‚¹ï¼šè®¡ç®—é‡å¤§ï¼Œä»…é€‚ç”¨äºå°‘é‡å› å­
        
        Args:
            factors: å› å­åˆ—è¡¨
            eval_func: è¯„ä¼°å‡½æ•°ï¼ˆè¾“å…¥æƒé‡å­—å…¸ï¼Œè¿”å›æ€§èƒ½åˆ†æ•°ï¼‰
            weight_range: æƒé‡èŒƒå›´ï¼ˆé»˜è®¤0.0-0.5ï¼‰
            step: æ­¥é•¿ï¼ˆé»˜è®¤0.1ï¼Œå³0.0, 0.1, 0.2, ..., 0.5ï¼‰
        
        Returns:
            OptimizationResult: ä¼˜åŒ–ç»“æœï¼ŒåŒ…å«æœ€ä¼˜æƒé‡ã€æœ€ä½³æ€§èƒ½ã€æ‰€æœ‰ç»“æœç­‰
        """
        from itertools import product
        import numpy as np
        
        # è®¾è®¡åŸç†ï¼šç”Ÿæˆå€™é€‰æƒé‡åºåˆ—
        # åŸå› ï¼šç½‘æ ¼æœç´¢éœ€è¦éå†æ‰€æœ‰å¯èƒ½çš„æƒé‡ç»„åˆ
        min_w, max_w = weight_range
        weight_candidates = np.arange(min_w, max_w + step, step)
        
        best_weights = None
        best_score = float("-inf")
        all_results = []
        iterations = 0
        
        # è®¾è®¡åŸç†ï¼šä½¿ç”¨productç”Ÿæˆæ‰€æœ‰æƒé‡ç»„åˆ
        # åŸå› ï¼šç©·ä¸¾æœç´¢éœ€è¦éå†æ‰€æœ‰å¯èƒ½çš„æƒé‡ç»„åˆ
        # å¤æ‚åº¦ï¼šO(n^m)ï¼Œnä¸ºå€™é€‰æƒé‡æ•°ï¼Œmä¸ºå› å­æ•°
        for weights_tuple in product(weight_candidates, repeat=len(factors)):
            weights = list(weights_tuple)
            
            # è®¾è®¡åŸç†ï¼šæƒé‡å½’ä¸€åŒ–
            # åŸå› ï¼šç¡®ä¿æƒé‡ä¹‹å’Œä¸º1ï¼Œä¿è¯æƒé‡åˆ†é…çš„åˆç†æ€§
            total = sum(weights)
            if total == 0:
                continue
            weights = [w / total for w in weights]
            
            # æ„å»ºæƒé‡å­—å…¸
            weight_dict = dict(zip(factors, weights))
            
            # è®¾è®¡åŸç†ï¼šè¯„ä¼°æ¯ä¸ªæƒé‡ç»„åˆ
            # åŸå› ï¼šæ‰¾åˆ°æ€§èƒ½æœ€ä¼˜çš„æƒé‡ç»„åˆ
            # å®¹é”™æ€§ï¼šè¯„ä¼°å¤±è´¥æ—¶ç»§ç»­æœç´¢ï¼Œä¸ä¸­æ–­ä¼˜åŒ–è¿‡ç¨‹
            try:
                score = eval_func(weight_dict)
                iterations += 1
                
                # è®¾è®¡åŸç†ï¼šä¿ç•™æ‰€æœ‰ç»“æœ
                # åŸå› ï¼šä¾¿äºåˆ†ææƒé‡å¯¹æ€§èƒ½çš„å½±å“
                all_results.append((weight_dict.copy(), score))
                
                if score > best_score:
                    best_score = score
                    best_weights = weight_dict.copy()
            except Exception as e:
                logger.warning(f"è¯„ä¼°å¤±è´¥: {e}")
                continue
        
        return OptimizationResult(
            best_weights=best_weights or {},
            best_performance=best_score,
            all_results=sorted(all_results, key=lambda x: x[1], reverse=True)[:20],
            optimization_method="grid_search",
            iterations=iterations
        )
    
    def ic_weighted_optimize(
        self,
        factor_ic_dict: Dict[str, float],
        min_weight: float = 0.05,
        max_weight: float = 0.40
    ) -> Dict[str, float]:
        """
        ICåŠ æƒä¼˜åŒ–
        
        Args:
            factor_ic_dict: å› å­ICå€¼å­—å…¸
            min_weight: æœ€å°æƒé‡
            max_weight: æœ€å¤§æƒé‡
        
        Returns:
            Dict: ä¼˜åŒ–åçš„å› å­æƒé‡
        """
        if not factor_ic_dict:
            return {}
        
        # è®¡ç®—ICç»å¯¹å€¼
        ic_abs = {k: abs(v) for k, v in factor_ic_dict.items()}
        total_ic = sum(ic_abs.values())
        
        if total_ic == 0:
            # ç­‰æƒ
            return {k: 1.0 / len(factor_ic_dict) for k in factor_ic_dict.keys()}
        
        # ICåŠ æƒ
        weights = {k: v / total_ic for k, v in ic_abs.items()}
        
        # åº”ç”¨æƒé‡é™åˆ¶
        weights = {
            k: max(min_weight, min(max_weight, v))
            for k, v in weights.items()
        }
        
        # é‡æ–°å½’ä¸€åŒ–
 <CodeFromFile 
  filePath="code_library/007_Chapter7_Strategy_Development/7.3/code_7_3_optimize_stop_loss.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
class RiskParameterOptimizer:
    """é£æ§å‚æ•°ä¼˜åŒ–å™¨"""
    
    def optimize_stop_loss(
        self,
        strategy: Dict[str, Any],
        backtest_results: List[Dict[str, Any]],
        stop_loss_range: Tuple[float, float] = (0.05, 0.15),
        step: float = 0.01
    ) -> float:
        """
        ä¼˜åŒ–æ­¢æŸçº¿
        
        Args:
            strategy: ç­–ç•¥é…ç½®
            backtest_results: å†å²å›æµ‹ç»“æœ
            stop_loss_range: æ­¢æŸçº¿èŒƒå›´
            step: æ­¥é•¿
        
        Returns:
            float: æœ€ä¼˜æ­¢æŸçº¿
        """
        best_stop_loss = stop_loss_range[0]
        best_sharpe = -float('inf')
        
        min_sl, max_sl = stop_loss_range
        for stop_loss in np.arange(min_sl, max_sl + step, step):
            # æ¨¡æ‹Ÿä¸åŒæ­¢æŸçº¿çš„å½±å“
            sharpe = self._evaluate_stop_loss(
                strategy, backtest_results, stop_loss
            )
            
            if sharpe > best_sharpe:
                best_sharpe = sharpe
                best_stop_loss = stop_loss
        
        return best_stop_loss
    
    def optimize_position_sizing(
        self,
        strategy: Dict[str, Any],
        backtest_results: List[Dict[str, Any]],
        max_position_range: Tuple[float, float] = (0.05, 0.20),
        step: float = 0.01
    ) -> float:
        """
        ä¼˜åŒ–å•ç¥¨æœ€å¤§ä»“ä½
        
        Args:
            strategy: ç­–ç•¥é…ç½®
            backtest_results: å†å²å›æµ‹ç»“æœ
            max_position_range: æœ€å¤§ä»“ä½èŒƒå›´
            step: æ­¥é•¿
        
        Returns:
            float: æœ€ä¼˜æœ€å¤§ä»“ä½
        """
        best_max_position = max_position_range[0]
        best_sharpe = -float('inf')
        
        min_pos, max_pos = max_position_range
        for max_position in np.arange(min_pos, max_pos + step, step):
            # æ¨¡æ‹Ÿä¸åŒä»“ä½çš„å½±å“
            sharpe = self._evaluate_position_sizing(
                strategy, backtest_results, max_position
            )
            
            if sharpe > best_sharpe:
                best_sharpe = sharpe<CodeFromFile 
  filePath="code_library/007_Chapter7_Strategy_Development/7.3/code_7_3_optimize.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
class GridSearchOptimizer:
    """ç½‘æ ¼æœç´¢ä¼˜åŒ–å™¨"""
    
    def optimize(
        self,
        parameter_ranges: Dict[str, Tuple[float, float, float]],
        eval_func: Callable[[Dict[str, float]], float],
        max_iterations: int = None
    ) -> OptimizationResult:
        """
        ç½‘æ ¼æœç´¢ä¼˜åŒ–
        
        Args:
            parameter_ranges: å‚æ•°èŒƒå›´å­—å…¸ {param_name: (min, max, step)}
            eval_func: è¯„ä¼°å‡½æ•°
            max_iterations: æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼ˆå¯é€‰ï¼‰
        
        Returns:
            OptimizationResult: ä¼˜åŒ–ç»“æœ
        """
        from itertools import product
        
        # ç”Ÿæˆå‚æ•°ç½‘æ ¼
        param_names = list(parameter_ranges.keys())
        param_values = [
            np.arange(min_val, max_val + step, step)
            for min_val, max_val, step in parameter_ranges.values()
        ]
        
        # ç”Ÿæˆæ‰€æœ‰ç»„åˆ
        combinations = list(product(*param_values))
        
        if max_iterations:
            combinations = combinations[:max_iterations]
        
        best_params = None
        best_score = -float('inf')
        all_results = []
        
        for combo in combinations:
            params = dict(zip(param_names, combo))
            
            try:
                score = eval_func(params)
                all_results.append((params.copy(), score))
                
                if score > best_score:
                    best_score = score
                    best_params = params.copy()
            except Exception as e:
                logger.warning(f"è¯„ä¼°å¤±è´¥: {e}")
                continue
        
        return OptimizationResult(
            best_weights=best_params or {},
            best_performance=best_score,
            all_results=s<CodeFromFile 
  filePath="code_library/007_Chapter7_Strategy_Development/7.3/code_7_3_optimize.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
from skopt import gp_minimize
from skopt.space import Real

class BayesianOptimizer:
    """è´å¶æ–¯ä¼˜åŒ–å™¨"""
    
    def optimize(
        self,
        parameter_ranges: Dict[str, Tuple[float, float]],
        eval_func: Callable[[Dict[str, float]], float],
        n_calls: int = 50
    ) -> OptimizationResult:
        """
        è´å¶æ–¯ä¼˜åŒ–
        
        Args:
            parameter_ranges: å‚æ•°èŒƒå›´å­—å…¸ {param_name: (min, max)}
            eval_func: è¯„ä¼°å‡½æ•°ï¼ˆæ³¨æ„ï¼šéœ€è¦è¿”å›è´Ÿå€¼ç”¨äºæœ€å°åŒ–ï¼‰
            n_calls: è¯„ä¼°æ¬¡æ•°
        
        Returns:
            OptimizationResult: ä¼˜åŒ–ç»“æœ
        """
        # å®šä¹‰æœç´¢ç©ºé—´
        dimensions = [
            Real(low=min_val, high=max_val, name=name)
            for name, (min_val, max_val) in parameter_ranges.items()
        ]
        
        # åŒ…è£…è¯„ä¼°å‡½æ•°ï¼ˆè½¬æ¢ä¸ºæœ€å°åŒ–é—®é¢˜ï¼‰
        def objective(params):
            param_dict = dict(zip(parameter_ranges.keys(), params))
            score = eval_func(param_dict)
            return -score  # è½¬æ¢ä¸ºæœ€å°åŒ–
        
        # æ‰§è¡Œä¼˜åŒ–
        result = gp_minimize(
            func=objective,
            dimensions=dimensions,
            n_calls=n_calls,
            random_state=42
        )
        
        # æå–æœ€ä¼˜å‚æ•°
        best_params = dict(zip(parameter_ranges.keys(), result.x))
        best_score = -result.fun  # è½¬æ¢å›æœ€å¤§åŒ–é—®é¢˜çš„åˆ†æ•°
        
        return OptimizationResult(
            best_weights=best_params,
            best_perf<CodeFromFile 
  filePath="code_library/007_Chapter7_Strategy_Development/7.3/code_7_3_optimize.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
from deap import base, creator, tools
import random

class GeneticAlgorithmOptimizer:
    """é—ä¼ ç®—æ³•ä¼˜åŒ–å™¨"""
    
    def optimize(
        self,
        parameter_ranges: Dict[str, Tuple[float, float]],
        eval_func: Callable[[Dict[str, float]], float],
        population_size: int = 50,
        generations: int = 50
    ) -> OptimizationResult:
        """
        é—ä¼ ç®—æ³•ä¼˜åŒ–
        
        Args:
            parameter_ranges: å‚æ•°èŒƒå›´å­—å…¸
            eval_func: è¯„ä¼°å‡½æ•°
            population_size: ç§ç¾¤å¤§å°
            generations: è¿›åŒ–ä»£æ•°
        
        Returns:
            OptimizationResult: ä¼˜åŒ–ç»“æœ
        """
        # åˆ›å»ºç±»å‹
        creator.create("FitnessMax", base.Fitness, weights=(1.0,))
        creator.create("Individual", list, fitness=creator.FitnessMax)
        
        # åˆå§‹åŒ–å·¥å…·ç®±
        toolbox = base.Toolbox()
        
        # å®šä¹‰å‚æ•°ç”Ÿæˆå‡½æ•°
        param_names = list(parameter_ranges.keys())
        for i, (name, (min_val, max_val)) in enumerate(parameter_ranges.items()):
            toolbox.register(
                f"attr_{i}",
                random.uniform,
                min_val,
                max_val
            )
        
        # åˆ›å»ºä¸ªä½“å’Œç§ç¾¤
        toolbox.register(
            "individual",
            tools.initCycle,
            creator.Individual,
            [getattr(toolbox, f"attr_{i}") for i in range(len(param_names))],
            n=1
        )
        toolbox.register(
            "population",
            tools.initRepeat,
            list,
            toolbox.individual
        )
        
        # å®šä¹‰è¯„ä¼°å‡½æ•°
        def evaluate(individual):
            params = dict(zip(param_names, individual))
            return (eval_func(params),)
        
        toolbox.register("evaluate", evaluate)
        toolbox.register("mate", tools.cxBlend, alpha=0.5)
        toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=0.1, indpb=0.2)
        toolbox.register("select", tools.selTournament, tournsize=3)
        
        # åˆ›å»ºåˆå§‹ç§ç¾¤
        population = toolbox.population(n=population_size)
        
        # è¯„ä¼°åˆå§‹ç§ç¾¤
        fitnesses = list(map(toolbox.evaluate, population))
        for ind, fit in zip(population, fitnesses):
            ind.fitness.values = fit
        
        # è¿›åŒ–
        for generation in range(generations):
            # é€‰æ‹©
            offspring = toolbox.select(population, len(population))
            offspring = list(map(toolbox.clone, offspring))
            
            # äº¤å‰
            for child1, child2 in zip(offspring[::2], offspring[1::2]):
                if random.random() < 0.5:
                    toolbox.mate(child1, child2)
                    del child1.fitness.values
                    del child2.fitness.values
            
            # å˜å¼‚
            for mutant in offspring:
                if random.random() < 0.2:
                    toolbox.mutate(mutant)
                    del mutant.fitness.values
            
            # è¯„ä¼°æ–°ä¸ªä½“
            invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
            fitnesses = map(toolbox.evaluate, invalid_ind)
            for ind, fit in zip(invalid_ind, fitnesses):
                ind.fitness.values = fit
            
            # æ›´æ–°ç§ç¾¤
            population[:] = offspring
        
        # æå–æœ€ä¼˜ä¸ªä½“
        best_ind = tools.selBest(population, 1)[0]
        best_params = dict(zip(param_names, best_ind))
        best_score = best_ind.fitness.values[0]
        
        return OptimizationResult(
            best_weights=best_params,
            best_performance=best_score,
            all_results=[(best_params, best_score)],
            optimizati<CodeFromFile 
  filePath="code_library/007_Chapter7_Strategy_Development/7.3/code_7_3_optimize_selection_criteria.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
class StockSelectionOptimizer:
    """é€‰è‚¡é€»è¾‘ä¼˜åŒ–å™¨"""
    
    def optimize_selection_criteria(
        self,
        strategy: Dict[str, Any],
        backtest_result: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        ä¼˜åŒ–é€‰è‚¡æ ‡å‡†
        
        Args:
            strategy: å½“å‰ç­–ç•¥
            backtest_result: å›æµ‹ç»“æœ
        
        Returns:
            Dict: ä¼˜åŒ–åçš„é€‰è‚¡æ ‡å‡†
        """
        # åˆ†æå›æµ‹ç»“æœ
        win_rate = backtest_result.get('win_rate', 0)
        avg_return = backtest_result.get('avg_return', 0)
        
        current_criteria = strategy.get('selection_criteria', {})
        
        # æ ¹æ®èƒœç‡å’Œå¹³å‡æ”¶ç›Šè°ƒæ•´é€‰è‚¡æ ‡å‡†
        if win_rate < 0.5:
            # èƒœç‡ä½ï¼Œæé«˜é€‰è‚¡æ ‡å‡†
            current_criteria['min_score'] = current_criteria.get('min_score', 0) + 0.1
            current_criteria['top_n'] = max(5, current_criteria.get('top_n', 10) - 2)
        elif avg_return < 0:
            # å¹³å‡æ”¶ç›Šä¸ºè´Ÿï¼Œæé«˜é€‰è‚¡æ ‡å‡†
            current_criteria['min_score'] = current_crit<CodeFromFile 
  filePath="code_library/007_Chapter7_Strategy_Development/7.3/code_7_3_split_time_series.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
class WalkForwardAnalyzer:
    """Walk-Forwardåˆ†æå™¨"""
    
    def split_time_series(
        self,
        start_date: str,
        end_date: str,
        train_period: int = 252,  # è®­ç»ƒæœŸï¼ˆäº¤æ˜“æ—¥ï¼‰
        test_period: int = 63,     # æµ‹è¯•æœŸï¼ˆäº¤æ˜“æ—¥ï¼‰
        step: int = 21             # æ­¥é•¿ï¼ˆäº¤æ˜“æ—¥ï¼‰
    ) -> List[Tuple[str, str, str, str]]:
        """
        æ—¶é—´åºåˆ—åˆ†å‰²
        
        Args:
            start_date: å¼€å§‹æ—¥æœŸ
            end_date: ç»“æŸæ—¥æœŸ
            train_period: è®­ç»ƒæœŸé•¿åº¦
            test_period: æµ‹è¯•æœŸé•¿åº¦
            step: æ­¥é•¿
        
        Returns:
            List[Tuple]: (train_start, train_end, test_start, test_end)åˆ—è¡¨
        """
        from datetime import datetime, timedelta
        
        start = datetime.strptime(start_date, '%Y-%m-%d')
        end = datetime.strptime(end_date, '%Y-%m-%d')
        
        splits = []
        current = start
        
        while current + timedelta(days=train_period + test_period) <= end:
            train_start = current
            train_end = current + timedelta(days=train_period)
            test_start = train_end
            test_end = test_start + timedelta(days=test_period)
            
            splits.append((
                train_start.strftime('%Y-%m-%d'),
                train_end.strftime('%Y-%m-%d'),
                test_start.strftime('%Y-%m-%d'),
                test_end.strftime('%Y-%m-%d')
           <CodeFromFile 
  filePath="code_library/007_Chapter7_Strategy_Development/7.3/code_7_3_should_trigger_optimization.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- åŸå§‹ä»£ç ï¼ˆä¿ç•™ä½œä¸ºå¤‡ä»½ï¼‰ï¼š
```python
class AutoOptimizationTrigger:
    """è‡ªåŠ¨ä¼˜åŒ–è§¦å‘å™¨"""
    
    def should_trigger_optimization(
        self,
        strategy: Dict[str, Any],
        backtest_result: Dict[str, Any] = None
    ) -> bool:
        """
        åˆ¤æ–­æ˜¯å¦åº”è¯¥è§¦å‘ä¼˜åŒ–
        
        Args:
            strategy: ç­–ç•¥é…ç½®
            backtest_result: å›æµ‹ç»“æœï¼ˆå¯é€‰ï¼‰
        
        Returns:
            bool: æ˜¯å¦è§¦å‘ä¼˜åŒ–
        """
        # ç­–ç•¥ç”Ÿæˆåè‡ªåŠ¨è§¦å‘é¦–æ¬¡ä¼˜åŒ–
        if backtest_result is None:
            return True
        
        # å›æµ‹ç»“æœä¸æ»¡è¶³è¦æ±‚æ—¶è§¦å‘ä¼˜åŒ–
        sharpe_ratio = backtest_result.get('sharpe_ratio', 0)
        max_drawdown = backtest_result.get('max_drawdown', 1.0)
        
        if sharpe_ratio < 1.5 or max_drawdown > 0.15:
            return True
        
        return False
```
-->etime, timedelta
        
        start = datetime.strptime(start_date, '%Y-%m-%d')
        end = datetime.strptime(end_date, '%Y-%m-%d')
        
        splits = []
        current = start
        
        while current + timedelta(days=train_period + test_period) <= end:
            train_start = current
            train_end = current + timedelta(days=train_period)
            test_start = train_end
            test_end = test_start + timedelta(days=test_period)
            
            splits.append((
                train_start.strftime('%Y-%m-%d'),
                train_end.strftime('%Y-%m-%d'),
                test_start.strftime('%Y-%m-%d'),
                test_end.strftime('%Y-%m-%d')
            ))
            
            current += timedelta(days=step)
        
        return splits
```

<h2 id="section-7-3-6">ğŸ¤– 7.3.6 è‡ªåŠ¨åŒ–ä¸æ™ºèƒ½åŒ–</h2>

è‡ªåŠ¨åŒ–ä¸æ™ºèƒ½åŒ–å®ç°ç­–ç•¥ä¼˜åŒ–çš„è‡ªåŠ¨è§¦å‘å’ŒAIè¾…åŠ©ä¼˜åŒ–ã€‚

### è‡ªåŠ¨è§¦å‘ä¼˜åŒ–

```python
class AutoOptimizationTrigger:
    """è‡ªåŠ¨ä¼˜åŒ–è§¦å‘å™¨"""
    
    def should_trigger_optimization(
        self,
        strategy: Dict[str, Any],
        backtest_result: Dict[str, Any] = None
    ) -> bool:
        """
        åˆ¤æ–­æ˜¯å¦åº”è¯¥è§¦å‘ä¼˜åŒ–
        
        Args:
            strategy: ç­–ç•¥é…ç½®
            backtest_result: å›æµ‹ç»“æœï¼ˆå¯é€‰ï¼‰
        
        Returns:
            bool: æ˜¯å¦è§¦å‘ä¼˜åŒ–
        """
        # ç­–ç•¥ç”Ÿæˆåè‡ªåŠ¨è§¦å‘é¦–æ¬¡ä¼˜åŒ–
        if backtest_result is None:
            return True
        
        # å›æµ‹ç»“æœä¸æ»¡è¶³è¦æ±‚æ—¶è§¦å‘ä¼˜åŒ–
        sharpe_ratio = backtest_result.get('sharpe_ratio', 0)
        max_drawdown = backtest_result.get('max_drawdown', 1.0)
        
        if sharpe_ratio < 1.5 or max_drawdown > 0.15:
            return True
        
        return False
```

## ğŸ”— ç›¸å…³ç« èŠ‚

- **7.1 ç­–ç•¥æ¨¡æ¿**ï¼šäº†è§£ç­–ç•¥æ¨¡æ¿ï¼Œä¸ºç­–ç•¥ä¼˜åŒ–æä¾›åŸºç¡€
- **7.2 ç­–ç•¥ç”Ÿæˆ**ï¼šäº†è§£ç­–ç•¥ç”Ÿæˆï¼Œç­–ç•¥ä¼˜åŒ–åŸºäºç”Ÿæˆçš„ç­–ç•¥è¿›è¡Œä¼˜åŒ–
- **ç¬¬8ç« ï¼šå›æµ‹éªŒè¯**ï¼šäº†è§£å›æµ‹éªŒè¯ï¼Œç­–ç•¥ä¼˜åŒ–éœ€è¦å›æµ‹ç»“æœåé¦ˆ
- **ç¬¬6ç« ï¼šå› å­åº“**ï¼šäº†è§£å› å­åº“ï¼Œå› å­æƒé‡ä¼˜åŒ–éœ€è¦å› å­æ•°æ®

## ğŸ’¡ å…³é”®è¦ç‚¹

1. **è¿­ä»£æ”¹è¿›**ï¼šé€šè¿‡å¤šè½®ä¼˜åŒ–è¿­ä»£ï¼Œé€æ­¥æå‡ç­–ç•¥æ€§èƒ½
2. **çŸ¥è¯†é©±åŠ¨**ï¼šåŸºäºå‰åºæ­¥éª¤ä¿¡æ¯å’Œå›æµ‹ç»“æœè¿›è¡Œä¼˜åŒ–
3. **ç¨³å¥æ€§ä¼˜å…ˆ**ï¼šé¿å…è¿‡æ‹Ÿåˆï¼Œç¡®ä¿ç­–ç•¥åœ¨ä¸åŒå¸‚åœºç¯å¢ƒä¸‹çš„ç¨³å¥æ€§
4. **è‡ªåŠ¨åŒ–**ï¼šæ”¯æŒè‡ªåŠ¨è§¦å‘å’Œè‡ªåŠ¨è¿­ä»£ä¼˜åŒ–
5. **æ™ºèƒ½åŒ–**ï¼šä½¿ç”¨AIç®—æ³•æ™ºèƒ½æ¢ç´¢å‚æ•°ç©ºé—´

## ğŸ”® æ€»ç»“ä¸å±•æœ›

<div class="summary-outlook">
  <h3>æœ¬èŠ‚å›é¡¾</h3>
  <p>æœ¬èŠ‚ç³»ç»Ÿä»‹ç»äº†TRQuantç³»ç»Ÿçš„ç­–ç•¥ä¼˜åŒ–ç³»ç»Ÿï¼Œä½œä¸ºå¹¿ä¹‰ç­–ç•¥ç”Ÿæˆçš„å…³é”®ç»„ä»¶ï¼Œè´Ÿè´£æ¥æ”¶å‰åºæ­¥éª¤ä¿¡æ¯å’Œå›æµ‹ç»“æœï¼Œå¯¹ç­–ç•¥è¿›è¡Œè¿­ä»£ä¼˜åŒ–ã€‚é€šè¿‡ç†è§£å‚æ•°è°ƒä¼˜ã€å› å­æƒé‡ä¼˜åŒ–ã€é£æ§å‚æ•°ä¼˜åŒ–ã€ç­–ç•¥é€»è¾‘ä¼˜åŒ–å’Œæ™ºèƒ½ä¼˜åŒ–ç®—æ³•ï¼Œå¸®åŠ©å¼€å‘è€…æŒæ¡å¦‚ä½•å¯¹ç”Ÿæˆçš„ç­–ç•¥è¿›è¡Œä¼˜åŒ–ï¼Œæé«˜ç­–ç•¥æ€§èƒ½å’Œç¨³å¥æ€§ã€‚</p>
  
  <h3>ä¸‹èŠ‚é¢„å‘Š</h3>
  <p>æŒæ¡äº†ç­–ç•¥ä¼˜åŒ–åï¼Œä¸‹ä¸€èŠ‚å°†ä»‹ç»ç­–ç•¥è§„èŒƒåŒ–ï¼ŒåŒ…æ‹¬ä»£ç è§„èŒƒåŒ–ã€å‚æ•°è§„èŒƒåŒ–å’Œæ¥å£è§„èŒƒåŒ–æ–¹æ³•ã€‚é€šè¿‡ç†è§£ç­–ç•¥è§„èŒƒåŒ–çš„å®Œæ•´æµç¨‹ï¼Œå¸®åŠ©å¼€å‘è€…æŒæ¡å¦‚ä½•ç¡®ä¿ç”Ÿæˆçš„ç­–ç•¥ä»£ç ç¬¦åˆè§„èŒƒã€‚</p>
  
  <a href="/ashare-book6/007_Chapter7_Strategy_Development/7.4_Strategy_Standardization_CN" class="next-section">
    ç»§ç»­å­¦ä¹ ï¼š7.4 ç­–ç•¥è§„èŒƒåŒ– â†’
  </a>
</div>

> **é€‚ç”¨ç‰ˆæœ¬**: v1.0.0+  
> **æœ€åæ›´æ–°**: 2025-12-12

