---
title: "12.1 模块API"
description: "深入解析TRQuant核心模块API接口，包括数据源管理、市场分析、主线识别、候选池、因子库、策略开发、回测验证等模块的API定义和使用方法"
lang: "zh-CN"
layout: "/src/layouts/HandbookLayout.astro"
currentBook: "ashare-book6"
updateDate: "2025-12-12"
---

# 📊 12.1 模块API

> **核心摘要：**
> 
> 本节系统介绍TRQuant核心模块的API接口，包括数据源管理、市场分析、主线识别、候选池、因子库、策略开发、回测验证等模块的API定义和使用方法。通过理解各模块的API接口，帮助开发者掌握系统API的使用方法，为系统集成和扩展奠定基础。

TRQuant系统采用模块化设计，每个核心模块都提供统一的API接口。本节详细说明各核心模块的API定义、参数说明、返回值格式等。

## 📋 章节概览

<script>
function scrollToSection(sectionId) {
  const element = document.getElementById(sectionId);
  if (element) {
    const headerOffset = 100;
    const elementPosition = element.getBoundingClientRect().top;
    const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
    window.scrollTo({
      top: offsetPosition,
      behavior: 'smooth'
    });
  }
}
</script>

<div class="section-overview">
  <div class="section-item" onclick="scrollToSection('section-12-1-1')">
    <h4>📡 12.1.1 数据源管理API</h4>
    <p>DataSourceManager、数据源初始化、数据获取、数据源状态</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-12-1-2')">
    <h4>📈 12.1.2 市场分析API</h4>
    <p>TrendAnalyzer、市场趋势分析、市场状态判断</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-12-1-3')">
    <h4>🔥 12.1.3 主线识别API</h4>
    <p>MainlineEngine、主线识别、主线评分、主线筛选</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-12-1-4')">
    <h4>📦 12.1.4 候选池API</h4>
    <p>CandidatePoolBuilder、候选池构建、股票筛选、股票评分</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-12-1-5')">
    <h4>📊 12.1.5 因子库API</h4>
    <p>FactorManager、因子计算、因子管理、因子优化</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-12-1-6')">
    <h4>🛠️ 12.1.6 策略开发API</h4>
    <p>StrategyGenerator、策略生成、策略编辑、策略测试</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-12-1-7')">
    <h4>🔄 12.1.7 回测验证API</h4>
    <p>BacktestEngine、回测执行、回测分析、回测报告</p>
  </div>
  <div class="section-item" onclick="scrollToSection('section-12-1-8')">
    <h4>🔄 12.1.8 工作流编排API</h4>
    <p>WorkflowOrchestrator、工作流执行、步骤管理、结果获取</p>
  </div>
</div>

## 🎯 学习目标

通过本节学习，您将能够：

- **理解模块API**：掌握各核心模块的API接口定义
- **使用API接口**：掌握API接口的调用方法和参数说明
- **处理返回值**：理解API返回值的格式和处理方法
- **集成系统**：掌握如何通过API集成系统功能

## 📚 核心概念

### API设计原则

- **统一接口**：所有模块遵循统一的API接口规范
- **类型安全**：使用类型注解和参数验证
- **文档完整**：完整的API文档和使用示例
- **版本管理**：API版本标注和变更记录

### 返回值格式

- **成功**：返回结果对象或字典
- **失败**：抛出异常或返回错误信息
- **异步**：部分API支持异步调用

<h2 id="section-12-1-1">📡 12.1.1 数据源管理API</h2>

数据源管理模块提供统一的数据源管理接口。

### DataSourceManager

<CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
from core.data_source_manager import DataSourceManager

class DataSourceManager:
    """数据源统一管理器"""
    
    def __init__(self):
        """
        初始化数据源管理器
        
        **设计原理**：
        - **延迟初始化**：不在构造函数中连接数据源，避免启动时阻塞
        - **状态管理**：维护每个数据源的状态（可用性、账户类型、日期范围等）
        - **优先级管理**：定义数据源优先级，自动选择最优数据源
        
        **为什么这样设计**：
        1. **启动速度**：延迟初始化避免启动时等待所有数据源连接
        2. **错误隔离**：某个数据源初始化失败不影响其他数据源
        3. **灵活配置**：支持动态添加/移除数据源，无需重启系统
        """
        pass
    
    def initialize(self) -> bool:
        """
        初始化所有数据源
        
        **设计原理**：
        - **并行初始化**：可以并行初始化多个数据源，提高效率
        - **错误容忍**：部分数据源失败不影响整体初始化
        - **状态记录**：记录每个数据源的初始化状态，便于后续使用
        
        **使用场景**：
        - 系统启动时调用，初始化所有可用数据源
        - 数据源配置变更后调用，重新初始化
        
        Returns:
            bool: 初始化是否成功（至少一个数据源可用即返回True）
        """
        pass
    
    def get_price(
        self,
        security: str,
        start_date: str,
        end_date: str,
        frequency: str = "daily",
        fields: Optional[List[str]] = None
    ) -> pd.DataFrame:
        """
        获取价格数据
        
        **设计原理**：
        - **统一接口**：所有数据源使用相同的接口，简化调用
        - **自动降级**：按优先级尝试数据源，失败时自动切换到备用数据源
        - **数据格式统一**：返回统一格式的DataFrame，隐藏数据源差异
        
        **为什么这样设计**：
        1. **提高可用性**：单个数据源故障不影响数据获取
        2. **优化数据质量**：优先使用高质量数据源
        3. **简化调用**：调用者无需关心数据源选择
        
        **使用场景**：
        - 获取单只股票的历史价格数据
        - 需要自动处理数据源故障的情况
        - 需要统一数据格式的场景
        
        **注意事项**：
        - 不同数据源支持的数据频率不同（JQData支持所有频率，AKShare仅支持日线）
        - 数据源失败时会自动降级，但可能影响数据质量
        - 建议在生产环境中监控数据源状态
        
        Args:
            security: 股票代码（如 "000001.XSHE"）
            start_date: 开始日期（格式: "YYYY-MM-DD"）
            end_date: 结束日期（格式: "YYYY-MM-DD"）
            frequency: 数据频率（"daily", "1m", "5m"等）
            fields: 字段列表（如 ["open", "close", "high", "low", "volume"]）
        
        Returns:
            pd.DataFrame: 价格数据，列名为字段名，索引为日期
        """
        pass
    
    def get_fundamentals(
        self,
        security: str,
        date: Optional[str] = None
    ) -> Dict:
        """
        获取基本面数据
        
        Args:
            security: 股票代码
            date: 日期（格式: "YYYY-MM-DD"），None表示最新
        
        Returns:
            Dict: 基本面数据字典
        """
        pass
    
 <CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1_usage_example.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
from core.data_source_manager import DataSourceManager

# 初始化数据源管理器
ds_manager = DataSourceManager()
ds_manager.initialize()

# 获取价格数据
price_data = ds_manager.get_price(
    security="000001.XSHE",
    start_date="2024-01-01",
    end_date="2024-12-31",
    frequency="daily",
    fields=["open", "close", "high", "low", "volume"]
)

# 获取基本面数据
fundamentals = ds_manager.get_fundamentals(
    security="000001.XSHE",
    date="2024-12-01"
)

# 查看数据源状态
sources = ds_manager.list_sources()
for so<CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
from core.trend_analyzer import TrendAnalyzer, MarketTrendResult

class TrendAnalyzer:
    """市场趋势分析器"""
    
    def __init__(self, jq_client=None):
        """
        初始化趋势分析器
        
        **设计原理**：
        - **可选依赖**：jq_client为可选参数，支持无JQData环境运行
        - **降级策略**：无JQData时使用AKShare等免费数据源
        
        **为什么这样设计**：
        1. **灵活性**：支持有/无JQData账号的环境
        2. **容错性**：数据源不可用时仍能运行（功能可能受限）
        3. **渐进增强**：有JQData时使用更高质量数据，无JQData时使用免费数据源
        
        Args:
            jq_client: JQData客户端（可选）
        """
        pass
    
    def analyze_market(
        self,
        index_code: str = "000001.XSHG",
        lookback_weeks: int = 48
    ) -> MarketTrendResult:
        """
        分析市场趋势
        
        **设计原理**：
        - **多周期分析**：同时分析短/中/长期趋势，提供全面的市场视角
        - **综合评分**：将多个技术指标融合为综合评分，简化判断
        - **市场阶段识别**：基于趋势分析识别市场阶段（牛市/熊市/震荡/复苏）
        
        **为什么这样设计**：
        1. **全面性**：单一周期可能误导，多周期分析更准确
        2. **可操作性**：综合评分便于决策，市场阶段便于策略选择
        3. **标准化**：统一的趋势分析框架，便于后续策略使用
        
        **使用场景**：
        - 每日市场分析，判断当前市场状态
        - 策略生成前，了解市场环境
        - 风险控制，根据市场状态调整仓位
        
        **注意事项**：
        - 默认使用上证指数（000001.XSHG），可根据需要切换
        - 48周回看周期适合中长期分析，短期分析可减少周数
        - 分析结果会缓存，避免重复计算
        
        Args:
            index_code: 指数代码（默认: "000001.XSHG<CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1_class.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
@dataclass
class MarketTrendResult:
    """市场趋势分析结果"""
    
    short_term: TrendSignal  # 短期趋势（1-8周）
    medium_term: TrendSignal  # 中期趋势（9-24周）
    long_term: TrendSignal  # 长期趋势（25-48周）
  <CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1_usage_example.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
from core.trend_analyzer import TrendAnalyzer

# 初始化趋势分析器
analyzer = TrendAnalyzer(jq_client=jq_client)

# 分析市场趋势
result = analyzer.analyze_market(
    index_code="000001.XSHG",
    lookback_weeks=48
)

# 查看结果
print(f"市场阶段: {result.market_phase}")
print(f"综合评分: {result.composite_score:.2f}")
print(f"短期趋势: {result.short_term.direction.value} ({result.short_term.score:.2f})")
print(f"中期趋势: {result.medium_term.direction.value} ({result.medium_term.score:.2f})")
print(f"长期趋<CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
from core.mainline_engine import MainlineEngine

class MainlineEngine:
    """投资主线识别引擎"""
    
    def __init__(self, jq_client=None):
        """
        初始化主线识别引擎
        
        Args:
            jq_client: JQData客户端（可选）
        """
        pass
    
    def identify_mainlines(
        self,
        time_horizon: str = "short",
        top_n: int = 10
    ) -> List[Dict]:
        """
        识别投资主线
        
        Args:
            time_horizon: 投资周期（"short"/"medium"/"long"）
            top_n: 返回前N条主线
        
        Returns:
            List[Dict]: 主线列表，每个字典包<CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1_usage_example.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
from core.mainline_engine import MainlineEngine

# 初始化主线识别引擎
engine = MainlineEngine(jq_client=jq_client)

# 识别投资主线
mainlines = engine.identify_mainlines(
    time_horizon="short",
    top_n=10
)

# 查看结果
for mainline in mainlines:
    print(f"主线: {mainline['name']}")
    print(f"评分: {mainline['score']:.2f}")
    print(f"相关行业: {', '.join(mainline['indus<CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
from core.candidate_pool import CandidatePoolBuilder

class CandidatePoolBuilder:
    """候选池构建器"""
    
    def __init__(self, jq_client=None):
        """
        初始化候选池构建器
        
        Args:
            jq_client: JQData客户端（可选）
        """
        pass
    
    def build_pool(
        self,
        mainlines: Optional[List[Dict]] = None,
        filters: Optional[Dict] = None,
        max_size: int = 200
    ) -> pd.DataFrame:
        """
        构建候选股票池
        
        Args:
            mainlines: 投资主线列表（可选）
   <CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1_usage_example.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
from core.candidate_pool import CandidatePoolBuilder

# 初始化候选池构建器
builder = CandidatePoolBuilder(jq_client=jq_client)

# 构建候选池
pool = builder.build_pool(
    mainlines=mainlines,
    filters={
        "market_cap_min": 100,  # 最小市值（亿元）
        "pe_max": 50,  # 最大PE
        "pb_max": 5,  # 最大PB
    },
    max_<CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
from core.factors.factor_manager import FactorManager

class FactorManager:
    """因子管理器"""
    
    def __init__(self, jq_client=None):
        """
        初始化因子管理器
        
        Args:
            jq_client: JQData客户端（可选）
        """
        pass
    
    def calculate_factor(
        self,
        factor_name: str,
        stocks: List[str],
        date: str
    ) -> pd.Series:
        """
        计算因子值
        
        Args:
            factor_name: 因子名称
            stocks: 股票列表
            date: 计算日期（格式: "YYYY-MM-DD"）
        
        Returns:
            pd.Series: 因子值，索引为股票代码
        """
        pass
    
    def list_<CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1_usage_example.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
from core.factors.factor_manager import FactorManager

# 初始化因子管理器
factor_manager = FactorManager(jq_client=jq_client)

# 列出所有因子
factors = factor_manager.list_factors()
for factor in factors:
    print(f"{factor['name']}: {factor['category']} - {factor['description']}")

# 计算因子值
factor_values = factor_manager.calculate_factor(
    factor_name="PE",
    stocks=["000001.XSHE", <CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
from core.strategy_generator import StrategyGenerator

class StrategyGenerator:
    """策略生成器"""
    
    def __init__(self):
        """初始化策略生成器"""
        pass
    
    def generate_strategy(
        self,
        style: str,
        factors: List[str],
        max_position: float = 0.1,
        stop_loss: float = 0.08,
        take_profit: float = 0.2,
        platform: str = "ptrade"
    ) -> str:
        """
        生成策略代码
        
        Args:
            style: 策略风格（"multi_factor"/"momentum_growth"/"value"/"market_neutral"）
            factors: 因子列表
            max_position: 最大仓位（0-1）
            stop_loss: 止损线（0<CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1_usage_example.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
from core.strategy_generator import StrategyGenerator

# 初始化策略生成器
generator = StrategyGenerator()

# 生成策略代码
strategy_code = generator.generate_strategy(
    style="multi_factor",
    factors=["PE", "ROE", "Momentum"],
    max_position=0.1,
    stop_loss=0.08,
    take_profit=0.2,
    platform="ptrade"
)

# 保存策略代码
with open("stra<CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
from core.bullettrade import BulletTradeEngine, BTConfig

class BulletTradeEngine:
    """BulletTrade回测引擎"""
    
    def __init__(self, config: BTConfig):
        """
        初始化回测引擎
        
        Args:
            config: 回测配置
        """
        pass
    
    def run_backtest(
        self,
        strategy_code: str,
        start_date: str,
        end_date: str
    ) -> Dict:
        """
        执行回测
        
        Args:
            strategy_code: 策略代码
            start_date: 开始日期（格<CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1_usage_example.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
from core.bullettrade import BulletTradeEngine, BTConfig

# 创建回测配置
config = BTConfig(
    initial_capital=1000000,  # 初始资金
    commission=0.0003,  # 手续费率
    slippage=0.001,  # 滑点
)

# 初始化回测引擎
engine = BulletTradeEngine(config)

# 执行回测
result = engine.run_backtest(
    strategy_code=strategy_code,
    start_date="2024-01-01",
    end_date="2024-12-31"
)

# 查看结果
print(f"总收益率: {result['total_return']:.2%}")
print(f"年化收益率: {result['annual_return']:.2%}")
print(f"夏普比率: {result['sharpe_<CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1___init__.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
from core.workflow_orchestrator import WorkflowOrchestrator

class WorkflowOrchestrator:
    """工作流编排器"""
    
    def __init__(self):
        """初始化工作流编排器"""
        pass
    
    def run_full_workflow(
        self,
        callback: Optional[Callable] = None
    ) -> FullWorkflowResult:
        """
        执行完整工作流
        
        Args:
            callback: 进度回调函数（可选）
        
        Returns:
            FullWorkflowResult: 完整工作流结果
        """
        pass
    
    def check_data_sources(self) -> WorkflowResult:
        """步骤1: 检测数据源"""
        pass
    
    def analyze_market_trend(self) -> WorkflowResult:
        """步骤2: 分析市场趋势"""
        pass
    
    def identify_mainlines(self) -> WorkflowResult:
        """步骤3: 识别投资主线"""
        pass
    
    def build_candidate_pool(self) -> WorkflowResult:
        """步骤4: 构建候选池"""
        pass
    
    def recommend_factors(self) -> WorkflowResult:
        """步骤5: 推荐因子"""
        pass
    
    def generate_strat<CodeFromFile 
  filePath="code_library/012_Chapter12_API_Reference/12.1/code_12_1_progress_callback.py"
  language="python"
  showDesignPrinciples="true"
/>

<!-- 原始代码（保留作为备份）：
```python
from core.workflow_orchestrator import WorkflowOrchestrator

# 初始化工作流编排器
orchestrator = WorkflowOrchestrator()

# 执行完整工作流
def progress_callback(step_name: str, progress: int, message: str):
    print(f"[{step_name}] {progress}% - {message}")

result = orchestrator.run_full_workflow(callback=progress_callback)

# 查看结果
print(f"工作流执行: {'成功' if result.success else '失败'}")
for step_name, step_result in result.step_results.items():
    print(f"{step_name}: {step_result.summary}")

# 或执行单个步骤
trend_result = orchestrator.analyze_market_trend()
print(f"市场趋势: {trend_result.summary}")
```
-->tart_date: str,
        end_date: str
    ) -> Dict:
        """
        执行回测
        
        Args:
            strategy_code: 策略代码
            start_date: 开始日期（格式: "YYYY-MM-DD"）
            end_date: 结束日期（格式: "YYYY-MM-DD"）
        
        Returns:
            Dict: 回测结果，包含收益指标、风险指标、交易记录等
        """
        pass
```

### 使用示例

```python
from core.bullettrade import BulletTradeEngine, BTConfig

# 创建回测配置
config = BTConfig(
    initial_capital=1000000,  # 初始资金
    commission=0.0003,  # 手续费率
    slippage=0.001,  # 滑点
)

# 初始化回测引擎
engine = BulletTradeEngine(config)

# 执行回测
result = engine.run_backtest(
    strategy_code=strategy_code,
    start_date="2024-01-01",
    end_date="2024-12-31"
)

# 查看结果
print(f"总收益率: {result['total_return']:.2%}")
print(f"年化收益率: {result['annual_return']:.2%}")
print(f"夏普比率: {result['sharpe_ratio']:.2f}")
print(f"最大回撤: {result['max_drawdown']:.2%}")
```

<h2 id="section-12-1-8">🔄 12.1.8 工作流编排API</h2>

工作流编排模块提供完整工作流执行和步骤管理接口。

### WorkflowOrchestrator

```python
from core.workflow_orchestrator import WorkflowOrchestrator

class WorkflowOrchestrator:
    """工作流编排器"""
    
    def __init__(self):
        """初始化工作流编排器"""
        pass
    
    def run_full_workflow(
        self,
        callback: Optional[Callable] = None
    ) -> FullWorkflowResult:
        """
        执行完整工作流
        
        Args:
            callback: 进度回调函数（可选）
        
        Returns:
            FullWorkflowResult: 完整工作流结果
        """
        pass
    
    def check_data_sources(self) -> WorkflowResult:
        """步骤1: 检测数据源"""
        pass
    
    def analyze_market_trend(self) -> WorkflowResult:
        """步骤2: 分析市场趋势"""
        pass
    
    def identify_mainlines(self) -> WorkflowResult:
        """步骤3: 识别投资主线"""
        pass
    
    def build_candidate_pool(self) -> WorkflowResult:
        """步骤4: 构建候选池"""
        pass
    
    def recommend_factors(self) -> WorkflowResult:
        """步骤5: 推荐因子"""
        pass
    
    def generate_strategy(self) -> WorkflowResult:
        """步骤6: 生成策略"""
        pass
    
    def run_backtest(self) -> WorkflowResult:
        """步骤7: 执行回测"""
        pass
```

### 使用示例

```python
from core.workflow_orchestrator import WorkflowOrchestrator

# 初始化工作流编排器
orchestrator = WorkflowOrchestrator()

# 执行完整工作流
def progress_callback(step_name: str, progress: int, message: str):
    print(f"[{step_name}] {progress}% - {message}")

result = orchestrator.run_full_workflow(callback=progress_callback)

# 查看结果
print(f"工作流执行: {'成功' if result.success else '失败'}")
for step_name, step_result in result.step_results.items():
    print(f"{step_name}: {step_result.summary}")

# 或执行单个步骤
trend_result = orchestrator.analyze_market_trend()
print(f"市场趋势: {trend_result.summary}")
```

## 🔗 相关章节

- **12.2 数据源API**：了解数据源API的详细接口
- **12.3 配置参考**：了解系统配置参数
- **第2-8章**：了解各模块的详细功能

## 💡 关键要点

1. **统一接口**：所有模块遵循统一的API接口规范
2. **类型安全**：使用类型注解和参数验证
3. **文档完整**：完整的API文档和使用示例
4. **版本管理**：API版本标注和变更记录

## 🔮 总结与展望

<div class="summary-outlook">
  <h3>本节回顾</h3>
  <p>本节系统介绍了核心模块的API接口，包括数据源管理、市场分析、主线识别、候选池、因子库、策略开发、回测验证、工作流编排等模块的API定义和使用方法。通过理解各模块的API接口，帮助开发者掌握系统API的使用方法。</p>
  
  <h3>下节预告</h3>
  <p>掌握了模块API后，下一节将介绍数据源API，详细说明数据源模块的API接口、数据获取方法、数据查询方法等。通过理解数据源API，帮助开发者掌握数据获取和处理的详细方法。</p>
  
  <a href="/ashare-book6/012_Chapter12_API_Reference/12.2_Data_Source_API_CN" class="next-section">
    继续学习：12.2 数据源API →
  </a>
</div>

> **适用版本**: v1.0.0+  
> **最后更新**: 2025-12-12
